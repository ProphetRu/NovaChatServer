{
	"info": {
		"_postman_id": "59dc9ec3-357f-41cb-9ce4-143644244f56",
		"name": "NovaChatServer",
		"description": "NovaChatServer testing Rest API",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "50283022",
		"_collection_link": "https://prophetru-d96702d6-8979850.postman.co/workspace/Prophet's-Workspace~9857ce48-29cb-4782-8767-33ad240a49fb/collection/50283022-59dc9ec3-357f-41cb-9ce4-143644244f56?action=share&source=collection_link&creator=50283022"
	},
	"item": [
		{
			"name": "Common",
			"item": [
				{
					"name": "Common - Non exist endpoint",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"(function () {",
									"    const meta = {",
									"        requestName: pm.info.requestName,",
									"        requestId: pm.info.requestId,",
									"        method: pm.request.method,",
									"        url: pm.request.url.toString(),",
									"        status: pm.response.code,",
									"        timestamp: new Date().toISOString()",
									"    };",
									"    console.log(\"[TEST META]\", JSON.stringify(meta, null, 2));",
									"",
									"    pm.test(\"Status code is 404 (Not Found)\", function () {",
									"        pm.expect(pm.response.code, `Expected 404 but got ${pm.response.code}`).to.eql(404);",
									"    });",
									"",
									"    let json;",
									"    pm.test(\"Response body is valid JSON\", function () {",
									"        try {",
									"            json = pm.response.json();",
									"            pm.expect(json, \"Parsed JSON should be an object\").to.be.an(\"object\");",
									"        } catch (err) {",
									"            console.error(\"[PARSE ERROR]\", err?.message || err);",
									"            throw new Error(\"Response body is not valid JSON: \" + (err?.message || err));",
									"        }",
									"    });",
									"",
									"    pm.test(\"Response has required string properties: code, message, status\", function () {",
									"        pm.expect(json, \"Response must be an object\").to.be.an(\"object\");",
									"        pm.expect(json, \"Missing 'code' property\").to.have.property(\"code\");",
									"        pm.expect(json.code, \"'code' must be a string\").to.be.a(\"string\");",
									"",
									"        pm.expect(json, \"Missing 'message' property\").to.have.property(\"message\");",
									"        pm.expect(json.message, \"'message' must be a string\").to.be.a(\"string\");",
									"",
									"        pm.expect(json, \"Missing 'status' property\").to.have.property(\"status\");",
									"        pm.expect(json.status, \"'status' must be a string\").to.be.a(\"string\");",
									"    });",
									"",
									"    pm.test(\"status equals 'error'\", function () {",
									"        pm.expect(json.status, \"Expected status to be 'error'\").to.eql(\"error\");",
									"    });",
									"",
									"    pm.test(\"code equals 'ENDPOINT_NOT_FOUND'\", function () {",
									"        pm.expect(json.code, \"Expected code to be 'ENDPOINT_NOT_FOUND'\").to.eql(\"ENDPOINT_NOT_FOUND\");",
									"    });",
									"",
									"    pm.test(\"message contains '/api/v1/auth/nonexistendpoint'\", function () {",
									"        const expectedPath = \"/api/v1/auth/nonexistendpoint\";",
									"        pm.expect(json.message, `Message does not contain expected path: ${expectedPath}\\nActual: ${json.message}`).to.include(expectedPath);",
									"    });",
									"",
									"    try {",
									"        console.log(\"[RESPONSE BODY]\", JSON.stringify(json, null, 2));",
									"    } catch (e) {",
									"        console.log(\"[RESPONSE BODY RAW]\", pm.response.text());",
									"    }",
									"})();"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "{{baseURL}}/api/v1/auth/nonexistendpoint",
							"host": [
								"{{baseURL}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"nonexistendpoint"
							]
						}
					},
					"response": []
				},
				{
					"name": "Common - Invalid API version",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"(function () {",
									"  const EXPECTED_STATUS_CODES = [200, 400, 401, 404];",
									"",
									"  function safeJsonParse(str) {",
									"    try {",
									"      return JSON.parse(str);",
									"    } catch (e) {",
									"      return null;",
									"    }",
									"  }",
									"",
									"  const statusCode = pm.response.code;",
									"  const bodyText = pm.response.text();",
									"  const json = safeJsonParse(bodyText);",
									"",
									"  console.log(\"[login] HTTP status:\", statusCode);",
									"  console.log(\"[login] Raw body:\", bodyText);",
									"  console.log(\"[login] Parsed JSON:\", json);",
									"",
									"  pm.test(\"Status code is one of expected values (200, 400, 401, 404)\", function () {",
									"    pm.expect(statusCode, \"Unexpected status code: \" + statusCode + \". Expected one of: \" + EXPECTED_STATUS_CODES.join(\", \")).to.be.oneOf(EXPECTED_STATUS_CODES);",
									"  });",
									"",
									"  pm.test(\"Response body is valid JSON\", function () {",
									"    pm.expect(json, \"Response body must be valid JSON\").to.not.be.null;",
									"  });",
									"",
									"  if (json) {",
									"    pm.test(\"Response has 'status' field\", function () {",
									"      pm.expect(json).to.have.property(\"status\");",
									"    });",
									"",
									"    pm.test(\"Response has either 'message' or 'code' field\", function () {",
									"      pm.expect(json.message !== undefined || json.code !== undefined, \"Expected 'message' or 'code' in response\").to.be.true;",
									"    });",
									"",
									"    pm.test(\"When success, token is present at data.token\", function () {",
									"      if (json.status === \"success\" || json.status === \"ok\") {",
									"        pm.expect(json).to.have.property(\"data\");",
									"        pm.expect(json.data).to.have.property(\"token\");",
									"        pm.expect(typeof json.data.token, \"data.token should be a non-empty string\").to.equal(\"string\");",
									"        pm.expect(json.data.token.length, \"data.token should be non-empty\").to.be.greaterThan(0);",
									"      } else {",
									"        pm.expect(true).to.be.true;",
									"      }",
									"    });",
									"",
									"    pm.test(\"When error, response contains code and message\", function () {",
									"      if (json.status === \"error\" || statusCode >= 400) {",
									"        pm.expect(json, \"Error response should include a 'code' field\").to.have.property(\"code\");",
									"        pm.expect(json, \"Error response should include a 'message' field\").to.have.property(\"message\");",
									"        pm.expect(typeof json.message, \"message should be a string\").to.equal(\"string\");",
									"        pm.expect(typeof json.code, \"code should be a string\").to.equal(\"string\");",
									"      } else {",
									"        pm.expect(true).to.be.true;",
									"      }",
									"    });",
									"",
									"    pm.test(\"When 404 with error status, code is ENDPOINT_NOT_FOUND\", function () {",
									"      if (statusCode === 404 && (json.status === \"error\" || json.status === \"fail\")) {",
									"        pm.expect(json.code, \"Expected code to be 'ENDPOINT_NOT_FOUND' for 404\").to.eql(\"ENDPOINT_NOT_FOUND\");",
									"      } else {",
									"        pm.expect(true).to.be.true;",
									"      }",
									"    });",
									"  }",
									"",
									"  console.log(\"[login] Response headers:\", pm.response.headers.all());",
									"  console.log(\"[login] Request URL:\", pm.request.url.toString());",
									"  console.log(\"[login] Request body:\", pm.request.body && pm.request.body.raw);",
									"})();"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"auth": {
							"type": "jwt",
							"jwt": [
								{
									"key": "algorithm",
									"value": "HS256",
									"type": "string"
								},
								{
									"key": "isSecretBase64Encoded",
									"value": false,
									"type": "boolean"
								},
								{
									"key": "payload",
									"value": "{}",
									"type": "string"
								},
								{
									"key": "addTokenTo",
									"value": "header",
									"type": "string"
								},
								{
									"key": "headerPrefix",
									"value": "Bearer",
									"type": "string"
								},
								{
									"key": "queryParamKey",
									"value": "token",
									"type": "string"
								},
								{
									"key": "header",
									"value": "{}",
									"type": "string"
								}
							]
						},
						"method": "POST",
						"header": [
							{
								"key": "Content-Type",
								"value": "application/json",
								"type": "text"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\r\n    \"login\": \"nonexist\",\r\n    \"password\": \"SecurePass123!\"\r\n}"
						},
						"url": {
							"raw": "{{baseURL}}/api/v11/auth/login",
							"host": [
								"{{baseURL}}"
							],
							"path": [
								"api",
								"v11",
								"auth",
								"login"
							]
						}
					},
					"response": []
				}
			]
		},
		{
			"name": "Auth",
			"item": [
				{
					"name": "Register",
					"item": [
						{
							"name": "Register - Invalid login",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  function tryParseJson(text) {",
											"    try {",
											"      return { ok: true, data: JSON.parse(text) };",
											"    } catch (e) {",
											"      return { ok: false, data: null, error: e };",
											"    }",
											"  }",
											"",
											"  const status = pm.response.code;",
											"  const isJson = pm.response.headers.get('Content-Type') && pm.response.headers.get('Content-Type').toLowerCase().includes('application/json');",
											"  const parsed = isJson ? tryParseJson(pm.response.text()) : { ok: false, data: null };",
											"  const body = parsed.data;",
											"",
											"  pm.test(\"Status code is one of expected: 201 (success) / 400 (invalid input) / 409 (user exists)\", function () {",
											"    pm.expect(status, \"Unexpected status code. Expected 201, 400, or 409 but got \" + status).to.be.oneOf([201, 400, 409]);",
											"  });",
											"",
											"  pm.test(\"Returned expected status category marked\", function () {",
											"    const expected = (status === 201) ? \"201 Created (success)\" : (status === 400) ? \"400 Bad Request (invalid input)\" : (status === 409) ? \"409 Conflict (user exists)\" : \"Unexpected\";",
											"    pm.expect([\"201 Created (success)\", \"400 Bad Request (invalid input)\", \"409 Conflict (user exists)\"].includes(expected), \"Returned status did not match any expected category\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Response is JSON or handled gracefully\", function () {",
											"    if (isJson) {",
											"      pm.expect(parsed.ok, \"Response has Content-Type JSON but failed to parse\").to.be.true;",
											"    } else {",
											"      pm.expect(true, \"Non-JSON response handled\").to.be.true;",
											"    }",
											"  });",
											"",
											"  pm.test(\"Response structure matches status scenario\", function () {",
											"    if (!parsed.ok) {",
											"      pm.expect(status, \"Non-JSON body only allowed for unexpected scenarios\").to.be.oneOf([/* allow anything but skip structure checks */]);",
											"      return;",
											"    }",
											"",
											"    pm.expect(body).to.be.an('object');",
											"    pm.expect(body).to.have.property('status');",
											"",
											"    if (status === 201) {",
											"      pm.expect(body, \"Success payload should contain data\").to.have.property('data');",
											"      pm.expect(body.data, \"data must be an object\").to.be.an('object');",
											"      pm.expect(body.data, \"data.userId missing\").to.have.property('userId');",
											"      pm.expect(body.data, \"data.login missing\").to.have.property('login');",
											"    } else if (status === 400 || status === 409) {",
											"      pm.expect(body, \"Error payload should contain code\").to.have.property('code');",
											"    }",
											"  });",
											"",
											"  pm.test(\"Content validation for INVALID_LOGIN (400)\", function () {",
											"    if (status === 400 && parsed.ok) {",
											"      pm.expect(body.code, \"Error code should be INVALID_LOGIN for invalid login input\").to.equal('INVALID_LOGIN');",
											"      if (typeof body.message === 'string') {",
											"        pm.expect(body.message, \"Message should hint at login constraints\").to.include('Login must be');",
											"      }",
											"    } else {",
											"      pm.expect(true).to.be.true; // not applicable",
											"    }",
											"  });",
											"",
											"  pm.test(\"Content validation for USER_EXISTS (409)\", function () {",
											"    if (status === 409 && parsed.ok) {",
											"      const acceptable = ['USER_ALREADY_EXISTS', 'USER_EXISTS', 'USER_EXIST', 'ACCOUNT_ALREADY_EXISTS'];",
											"      pm.expect(acceptable, \"Unexpected error code for 409\").to.include(body.code);",
											"    } else {",
											"      pm.expect(true).to.be.true; // not applicable",
											"    }",
											"  });",
											"",
											"  if (parsed.ok && body && body.data && typeof body.data === 'object' && body.data.token) {",
											"    pm.test('Token captured to environment variable', function () {",
											"      pm.expect(pm.environment.get('authToken')).to.be.a('string');",
											"    });",
											"  } else {",
											"    pm.environment.unset('authToken');",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"ab\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Invalid password",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function getJson() {",
											"  let json = null;",
											"  try { json = pm.response.json(); } catch (e) { /* non-JSON */ }",
											"  return json;",
											"}",
											"",
											"const json = getJson();",
											"",
											"pm.test(\"Response has a valid Content-Type\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"pm.test(\"Status code is one of expected for register\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([201, 400, 409]);",
											"});",
											"",
											"if (pm.response.code === 201) {",
											"  pm.test(\"201: success envelope shape\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"message\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"status\").that.equals(\"ok\");",
											"    pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"  });",
											"",
											"  pm.test(\"201: data contains id and login (types)\", function () {",
											"    pm.expect(json.data).to.have.property(\"id\");",
											"    pm.expect(json.data.id).to.be.a(\"string\");",
											"    pm.expect(json.data).to.have.property(\"login\").that.is.a(\"string\");",
											"  });",
											"}",
											"",
											"if (pm.response.code === 400) {",
											"  pm.test(\"400: error envelope shape\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"message\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"status\").that.equals(\"error\");",
											"  });",
											"  pm.test(\"400: invalid password code present\", function () {",
											"    pm.expect(String(json.code)).to.include(\"INVALID_PASSWORD\");",
											"  });",
											"}",
											"",
											"if (pm.response.code === 409) {",
											"  pm.test(\"409: error envelope shape\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"message\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"status\").that.equals(\"error\");",
											"  });",
											"  pm.test(\"409: user exists code present\", function () {",
											"    pm.expect(String(json.code)).to.include(\"USER_EXISTS\");",
											"  });",
											"}",
											"",
											"pm.test(\"Body is not empty for JSON responses\", function () {",
											"  pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"somelogin\",\r\n    \"password\": \"pass\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - No login",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Content-Type is application/json\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\");",
											"  pm.expect(ct).to.match(/^application\\/json\\b/i);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Content-Type equals 'application/json'\", function () {",
											"  const ct = pm.response.headers.get(\"Content-Type\");",
											"  pm.expect(ct.split(\";\")[0].trim().toLowerCase()).to.eql(\"application/json\");",
											"});",
											"",
											"const status = pm.response.code;",
											"",
											"pm.test(\"Status code is one of expected values (201 created or 400 bad request)\", function () {",
											"  pm.expect(status).to.be.oneOf([201, 400]);",
											"});",
											"",
											"if (status === 201) {",
											"  pm.test(\"201: Response has data object with id (string) and login (string)\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"id\");",
											"    pm.expect(json.data.id).to.be.a(\"string\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"    pm.expect(json.data.login).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"201: Response must NOT include password field anywhere in root or data\", function () {",
											"    pm.expect(Object.prototype.hasOwnProperty.call(json, \"password\")).to.eql(false);",
											"    if (json && typeof json === \"object\" && json.data && typeof json.data === \"object\") {",
											"      pm.expect(Object.prototype.hasOwnProperty.call(json.data, \"password\")).to.eql(false);",
											"    }",
											"  });",
											"} else if (status === 400) {",
											"  pm.test(\"400: Error payload has required fields and values\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"message\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"status\").that.is.a(\"string\");",
											"    pm.expect(json.status).to.eql(\"error\");",
											"    pm.expect(json.code).to.eql(\"MISSING_FIELDS\");",
											"    pm.expect(json.message).to.include(\"Login and password are required\");",
											"  });",
											"} else {",
											"  pm.test(\"Unexpected status code\", function () {",
											"    pm.expect.fail(`Unexpected status code: ${status}`);",
											"  });",
											"}"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"password\": \"pass\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - No password",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response has Content-Type: application/json\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const contentType = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(contentType.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    // If not JSON, keep json as empty object so specific tests can still fail meaningfully",
											"}",
											"",
											"pm.test(\"400 - Missing fields error structure\", function () {",
											"    if (pm.response.code === 400) {",
											"        pm.expect(json).to.be.an(\"object\");",
											"        pm.expect(json).to.have.property(\"code\");",
											"        pm.expect(json).to.have.property(\"message\");",
											"        pm.expect(json.code).to.eql(\"MISSING_FIELDS\");",
											"        pm.expect(json.message).to.be.a(\"string\");",
											"    } else {",
											"        pm.expect(pm.response.code).to.not.eql(400);",
											"    }",
											"});",
											"",
											"pm.test(\"201 - Created contains id and login\", function () {",
											"    if (pm.response.code === 201) {",
											"        pm.expect(json).to.be.an(\"object\");",
											"        pm.expect(json).to.have.property(\"id\");",
											"        pm.expect(json).to.have.property(\"login\");",
											"        pm.expect(json.id).to.satisfy(v => [\"string\", \"number\"].includes(typeof v));",
											"        pm.expect(json.login).to.be.a(\"string\");",
											"    } else {",
											"        pm.expect(pm.response.code).to.not.eql(201);",
											"    }",
											"});",
											"",
											"pm.test(\"Status code is either 201 or 400 for register\", function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([201, 400]);",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"user\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Empty login",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"    let json;",
											"    pm.test(\"Response body is JSON parseable\", function () {",
											"        try {",
											"            json = pm.response.json();",
											"            pm.expect(json).to.be.an(\"object\");",
											"        } catch (e) {",
											"            pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
											"        }",
											"    });",
											"",
											"    let requestLogin = null;",
											"    try {",
											"        const rawBody = pm.request.body && pm.request.body.mode === 'raw' ? pm.request.body.raw : null;",
											"        if (rawBody) {",
											"            const resolved = pm.variables.replaceIn(rawBody);",
											"            const parsed = JSON.parse(resolved);",
											"            if (parsed && typeof parsed.login !== 'undefined') {",
											"                requestLogin = parsed.login;",
											"            }",
											"        }",
											"    } catch (e) {",
											"        // Not a fatal error for the test suite",
											"    }",
											"",
											"    pm.test(\"Status code is one of expected: 201, 400, 409\", function () {",
											"        pm.expect(pm.response.code).to.be.oneOf([201, 400, 409]);",
											"    });",
											"",
											"    if (pm.response.code === 201 && json) {",
											"        pm.test(\"201: has success code or status\", function () {",
											"            pm.expect(json).to.be.an('object');",
											"            pm.expect(json.code === 'USER_CREATED' || json.status === 'success').to.eql(true);",
											"        });",
											"",
											"        pm.test(\"201: contains data.user with id (string)\", function () {",
											"            pm.expect(json).to.have.property('data');",
											"            pm.expect(json.data).to.have.property('user');",
											"            pm.expect(json.data.user).to.have.property('id');",
											"            pm.expect(json.data.user.id).to.be.a('string');",
											"        });",
											"",
											"        pm.test(\"201: response login matches request login when available\", function () {",
											"            if (requestLogin !== null && typeof requestLogin !== 'undefined') {",
											"                const responseLogin = json?.data?.user?.login ?? json?.data?.login;",
											"                pm.expect(responseLogin, 'response login present').to.be.a('string');",
											"                pm.expect(responseLogin).to.eql(requestLogin);",
											"            } else {",
											"                pm.expect(true, 'request login not available to compare').to.be.true;",
											"            }",
											"        });",
											"    }",
											"",
											"    if (pm.response.code === 400 && json) {",
											"        pm.test(\"400: code indicates invalid login or password\", function () {",
											"            pm.expect(['INVALID_LOGIN', 'INVALID_PASSWORD']).to.include(json.code);",
											"        });",
											"        pm.test(\"400: message is present\", function () {",
											"            pm.expect(json).to.have.property('message');",
											"            pm.expect(String(json.message)).to.have.length.greaterThan(0);",
											"        });",
											"    }",
											"",
											"    if (pm.response.code === 409 && json) {",
											"        pm.test(\"409: code indicates user exists\", function () {",
											"            pm.expect(json.code).to.eql('USER_EXISTS');",
											"        });",
											"        pm.test(\"409: message is present\", function () {",
											"            pm.expect(json).to.have.property('message');",
											"            pm.expect(String(json.message)).to.have.length.greaterThan(0);",
											"        });",
											"    }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Empty password",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json;",
											"let parseError = null;",
											"",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        parseError = e;",
											"        console.error(\"Failed to parse JSON response:\", e);",
											"        throw e;",
											"    }",
											"});",
											"",
											"let requestedLogin = null;",
											"try {",
											"    const reqBody = pm.request.body?.raw;",
											"    if (reqBody) {",
											"        const parsedReq = JSON.parse(reqBody);",
											"        requestedLogin = parsedReq && typeof parsedReq.login === 'string' ? parsedReq.login : null;",
											"    }",
											"} catch (e) {",
											"    console.warn(\"Could not parse request body for login comparison\", e);",
											"}",
											"",
											"pm.test(\"Status code is one of expected values (200 success, 400/409 client errors)\", function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([200, 400, 409]);",
											"});",
											"",
											"if (pm.response.code === 200) {",
											"    pm.test(\"Success payload contains expected top-level fields\", function () {",
											"        pm.expect(json).to.have.property(\"code\", \"SUCCESS\");",
											"        pm.expect(json).to.have.property(\"status\", \"success\");",
											"        pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"    });",
											"",
											"    pm.test(\"data.user object has required fields and types\", function () {",
											"        pm.expect(json.data).to.have.property(\"user\").that.is.an(\"object\");",
											"        const user = json.data.user;",
											"        pm.expect(user).to.have.property(\"id\");",
											"        pm.expect(user.id).to.be.a(\"string\").and.not.empty;",
											"        pm.expect(user).to.have.property(\"login\");",
											"        pm.expect(user.login).to.be.a(\"string\").and.not.empty;",
											"        if (requestedLogin) {",
											"            pm.expect(user.login, \"user.login should match requested login\").to.eql(requestedLogin);",
											"        } else {",
											"            console.warn(\"Requested login not available for comparison. Skipping strict equality check.\");",
											"        }",
											"        pm.expect(user).to.have.property(\"createdAt\");",
											"        pm.expect(user.createdAt).to.be.a(\"string\").and.not.empty;",
											"",
											"        const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?Z$/;",
											"        const isISO = isoRegex.test(user.createdAt);",
											"        if (!isISO) {",
											"            console.error(\"createdAt is not a valid ISO 8601 UTC timestamp:\", user.createdAt);",
											"        }",
											"        pm.expect(isISO, \"createdAt must be ISO 8601 UTC timestamp e.g. 2023-01-01T12:00:00Z\").to.be.true;",
											"    });",
											"}",
											"",
											"if (pm.response.code === 400) {",
											"    pm.test(\"400 error payload has expected shape and known code\", function () {",
											"        pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"        const knownCodes = [\"INVALID_PASSWORD\", \"INVALID_LOGIN\", \"MISSING_FIELD\"];",
											"        const isKnown = knownCodes.includes(json.code);",
											"        if (!isKnown) {",
											"            console.error(\"Unexpected 400 error code:\", json.code, \"Known:\", knownCodes);",
											"        }",
											"        pm.expect(isKnown, \"code should be one of known 400 error codes\").to.be.true;",
											"        pm.expect(json).to.have.property(\"message\").that.is.a(\"string\").and.not.empty;",
											"    });",
											"}",
											"",
											"if (pm.response.code === 409) {",
											"    pm.test(\"409 conflict has USER_ALREADY_EXISTS code\", function () {",
											"        pm.expect(json).to.have.property(\"code\", \"USER_ALREADY_EXISTS\");",
											"    });",
											"}",
											"",
											"pm.test(\"Helpful diagnostics on unexpected payload\", function () {",
											"    if ([200, 400, 409].indexOf(pm.response.code) === -1) {",
											"        console.error(\"Unexpected status code:\", pm.response.code, \"Body:\", pm.response.text());",
											"    }",
											"    if (!json && parseError) {",
											"        console.error(\"JSON parse error present, raw body:\", pm.response.text());",
											"    }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"user\",\r\n    \"password\": \"\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  json = null;",
											"}",
											"",
											"pm.test(\"Success: HTTP 200 on successful registration\", function () {",
											"  if (json && (json.status === \"success\" || json.status === \"ok\")) {",
											"    pm.expect(pm.response.code).to.eql(200);",
											"  } else {",
											"    pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 403, 404, 409, 422, 429, 500]);",
											"  }",
											"});",
											"",
											"pm.test(\"Error response shape: has code, message, status\", function () {",
											"  if (json && json.status === \"error\") {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"message\").that.is.a(\"string\");",
											"    pm.expect(json).to.have.property(\"status\").that.equals(\"error\");",
											"  } else {",
											"    pm.expect(true).to.be.true; // not applicable",
											"  }",
											"});",
											"",
											"pm.test(\"Success payload: contains user.id and user.login\", function () {",
											"  if (json && (json.status === \"success\" || json.status === \"ok\")) {",
											"    pm.expect(json).to.have.property(\"user\").that.is.an(\"object\");",
											"    pm.expect(json.user).to.have.property(\"id\");",
											"    pm.expect(json.user).to.have.property(\"login\").that.is.a(\"string\");",
											"  } else {",
											"    pm.expect(true).to.be.true; // not applicable",
											"  }",
											"});",
											"",
											"pm.test(\"Error: ENDPOINT_NOT_FOUND when endpoint or method is invalid (example)\", function () {",
											"  if (json && json.status === \"error\") {",
											"    pm.expect(json.message).to.be.a(\"string\").and.not.empty;",
											"",
											"    if (pm.response.code === 404) {",
											"      pm.expect(json.code).to.eql(\"ENDPOINT_NOT_FOUND\");",
											"      pm.expect(json.message.toLowerCase()).to.include(\"endpoint not found\");",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true; // not applicable",
											"  }",
											"});",
											"",
											"pm.test(\"Request context\", function(){",
											"  pm.expect(pm.request.method).to.eql(\"GET\");",
											"  pm.expect(pm.request.url.toString()).to.include(\"/api/v1/auth/register\");",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Invalid json format",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  pm.test(\"Status code is 200 (success) or a client error 400/422\", function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([200, 400, 422]);",
											"  });",
											"",
											"  pm.test(\"Content-Type is application/json\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"  });",
											"",
											"  let body = pm.response.text();",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    console.log(\"Failed to parse response JSON:\", e && e.message ? e.message : e);",
											"    console.log(\"Raw response body:\", body);",
											"    pm.test(\"Response body is valid JSON\", function () {",
											"      pm.expect.fail(\"Response is not valid JSON\");",
											"    });",
											"    return; // Stop further JSON-based assertions",
											"  }",
											"",
											"  console.log(\"Parsed response JSON:\", json);",
											"",
											"  const code = pm.response.code;",
											"",
											"  if (code === 200) {",
											"    pm.test(\"200: status is 'success'\", function () {",
											"      pm.expect(json).to.have.property(\"status\").that.equals(\"success\");",
											"    });",
											"    pm.test(\"200: data contains id and login\", function () {",
											"      pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"      pm.expect(json.data).to.have.property(\"id\");",
											"      pm.expect(json.data).to.have.property(\"login\").that.is.a(\"string\");",
											"    });",
											"  } else if (code === 400) {",
											"    pm.test(\"400: error envelope present\", function () {",
											"      pm.expect(json).to.have.property(\"status\").that.equals(\"error\");",
											"      pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"      pm.expect(json).to.have.property(\"message\").that.is.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"400: catches INVALID_JSON error code when present\", function () {",
											"      if (json && typeof json.code === \"string\") {",
											"        console.log(\"Error code:\", json.code, \"Message:\", json.message);",
											"        if (json.code === \"INVALID_JSON\") {",
											"          pm.expect(json.code).to.equal(\"INVALID_JSON\");",
											"        } else {",
											"          pm.expect(json.code).to.be.a(\"string\");",
											"        }",
											"      } else {",
											"        pm.expect.fail(\"Missing 'code' in 400 error response\");",
											"      }",
											"    });",
											"  } else if (code === 422) {",
											"    pm.test(\"422: validation errors array present\", function () {",
											"      pm.expect(json).to.have.property(\"status\").that.is.a(\"string\");",
											"      pm.expect(json).to.have.property(\"errors\").that.is.an(\"array\");",
											"      if (Array.isArray(json.errors) && json.errors.length > 0) {",
											"        json.errors.forEach(function (err, idx) {",
											"          pm.expect(err).to.be.an(\"object\");",
											"          if (Object.prototype.hasOwnProperty.call(err, \"field\")) {",
											"            pm.expect(err.field).to.be.a(\"string\");",
											"          }",
											"          if (Object.prototype.hasOwnProperty.call(err, \"message\")) {",
											"            pm.expect(err.message).to.be.a(\"string\");",
											"          }",
											"        });",
											"      }",
											"    });",
											"  }",
											"",
											"  console.log(\"Request URL:\", pm.request.url.toString());",
											"  console.log(\"Request Method:\", pm.request.method);",
											"  console.log(\"Request Headers:\", pm.request.headers.toObject());",
											"  console.log(\"Request Body:\", (pm.request.body && pm.request.body.toString()) || \"<none>\");",
											"  console.log(\"Response Status:\", pm.response.code, pm.response.status);",
											"  console.log(\"Response Headers:\", pm.response.headers.toObject());",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"somelogin\",\r\n    \"password\": \"pass\"\r\n}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Empty json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const reqName = pm.info.requestName || 'Register';",
											"  const status = pm.response.code;",
											"  const is2xx = pm.response.code >= 200 && pm.response.code < 300;",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"",
											"  pm.test('baseURL variable is defined and non-empty', function () {",
											"    const baseURL = pm.variables.get('baseURL');",
											"    pm.expect(baseURL, 'baseURL is missing').to.be.a('string');",
											"    pm.expect(baseURL, 'baseURL should not be empty').to.have.length.above(0);",
											"  });",
											"",
											"  pm.test('Content-Type is application/json', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  let json;",
											"  pm.test('Response has a valid JSON body', function () {",
											"    try {",
											"      json = pm.response.json();",
											"      pm.expect(json).to.be.an('object');",
											"    } catch (e) {",
											"      console.log('[Tests][' + reqName + '] JSON parse error:', e);",
											"      pm.expect.fail('Response body is not valid JSON');",
											"    }",
											"  });",
											"",
											"  function getStr(o, k) { return (o && typeof o[k] === 'string') ? o[k] : undefined; }",
											"",
											"  pm.test('Status is success (201 Created or 200 OK) OR documented error', function () {",
											"    const isSuccess = [200, 201].includes(status);",
											"    const isKnownInvalidJson = status === 400 && json && json.code === 'INVALID_JSON';",
											"",
											"    pm.expect(isSuccess || isKnownInvalidJson, `Unexpected status ${status}`).to.be.true;",
											"  });",
											"",
											"  pm.test('Success schema: id, identity (login/username/email), createdAt and optional token', function () {",
											"    if (!is2xx || !json) {",
											"      pm.expect(true, 'Skipped because response is not success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    const identityField = ['login', 'username', 'email'].find(k => getStr(json, k));",
											"",
											"    pm.expect(json, 'Response body should be an object').to.be.an('object');",
											"    pm.expect(json, 'Body should have an id').to.have.property('id');",
											"",
											"    pm.expect(['string', 'number']).to.include(typeof json.id);",
											"",
											"    pm.expect(identityField, 'Should include login, username, or email string').to.be.oneOf(['login','username','email']);",
											"    if (identityField) {",
											"      pm.expect(getStr(json, identityField), `${identityField} should be a non-empty string`).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"",
											"    pm.expect(json).to.have.property('createdAt');",
											"    if (json.createdAt != null) {",
											"      pm.expect(json.createdAt).to.be.a('string');",
											"      const d = new Date(json.createdAt);",
											"      pm.expect(isNaN(d.getTime()), 'createdAt should be a valid date string').to.be.false;",
											"    }",
											"",
											"    if (json.token !== undefined) {",
											"      pm.expect(json.token).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"  });",
											"",
											"  pm.test('Store id and token to environment/globals when present', function () {",
											"    if (!json) {",
											"      pm.expect(true, 'Skipped: no JSON').to.be.true;",
											"      return;",
											"    }",
											"",
											"    const env = pm.environment.name ? pm.environment : pm.globals;",
											"    const scopeName = pm.environment.name ? 'environment' : 'globals';",
											"",
											"    try {",
											"      if (json.id !== undefined && json.id !== null) {",
											"        env.set('user_id', String(json.id));",
											"        console.log(`[Tests][${reqName}] Saved user_id to ${scopeName}:`, json.id);",
											"      }",
											"      if (typeof json.token === 'string' && json.token.length > 0) {",
											"        env.set('auth_token', json.token);",
											"        console.log(`[Tests][${reqName}] Saved auth_token to ${scopeName}`);",
											"      }",
											"    } catch (e) {",
											"      console.log(`[Tests][${reqName}] Error saving variables:`, e);",
											"    }",
											"",
											"    pm.expect(true).to.be.true; // keep the test green when nothing to store",
											"  });",
											"",
											"  pm.test('Error shape on failure: code/message/status present and types valid', function () {",
											"    if (pm.response.code < 400) {",
											"      pm.expect(true, 'Skipped because response is success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    pm.expect(json, 'Error response should be a JSON object').to.be.an('object');",
											"    pm.expect(json).to.have.property('code');",
											"    pm.expect(typeof json.code, 'code should be a string').to.equal('string');",
											"",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(typeof json.message, 'message should be a string').to.equal('string');",
											"",
											"    if (json.status !== undefined) {",
											"      pm.expect(typeof json.status, 'status should be a string').to.equal('string');",
											"    }",
											"",
											"    if (status === 400) {",
											"      pm.expect(json.code, '400 error should include INVALID_JSON code when body is invalid').to.be.oneOf(['INVALID_JSON', json.code]);",
											"    }",
											"  });",
											"",
											"  // Extra: Log helpful debug info",
											"  console.log(`[Tests][${reqName}] Status:`, status);",
											"  console.log(`[Tests][${reqName}] Content-Type:`, contentType);",
											"  if (json) {",
											"    const sample = JSON.stringify(json).slice(0, 500);",
											"    console.log(`[Tests][${reqName}] Body sample (first 500 chars):`, sample);",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Successfully alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('[Register] Status Code:', pm.response.code);",
											"console.log('[Register] Headers:', pm.response.headers.all());",
											"console.log('[Register] Raw Body:', pm.response.text());",
											"",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse JSON:', e);",
											"}",
											"",
											"let requestLogin = null;",
											"try {",
											"    const reqBodyRaw = pm.request.body && pm.request.body.raw ? pm.request.body.raw : '';",
											"    console.log('[Register] Request Raw Body:', reqBodyRaw);",
											"    if (reqBodyRaw) {",
											"        const reqJson = JSON.parse(reqBodyRaw);",
											"        requestLogin = reqJson && reqJson.login ? reqJson.login : null;",
											"    }",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse request body JSON:', e);",
											"}",
											"",
											"pm.test('Register: response status code is 201', function () {",
											"    pm.expect(pm.response.code).to.eql(201);",
											"});",
											"",
											"pm.test(\"Register: response JSON has status == 'success'\", function () {",
											"    pm.expect(json).to.be.an('object');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Register: message contains 'registered' (case-insensitive)\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    const msg = String(json.message || '');",
											"    pm.expect(msg.toLowerCase()).to.include('registered');",
											"});",
											"",
											"pm.test('Register: data.login equals the request body login', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.be.an('object');",
											"    if (requestLogin !== null) {",
											"        pm.expect(json.data.login).to.eql(requestLogin);",
											"    } else {",
											"        pm.expect(json.data).to.have.property('login');",
											"        pm.expect(json.data.login).to.be.a('string');",
											"    }",
											"});",
											"",
											"pm.test('Register: data.user_id exists and is a valid UUID v4', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.have.property('user_id');",
											"    const uuid = String(json.data.user_id || '');",
											"    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    pm.expect(uuid).to.match(uuidV4Regex);",
											"});",
											"",
											"pm.test(\"Register: 'Content-Type' header includes 'application/json'\", function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Successfully bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('[Register] Status Code:', pm.response.code);",
											"console.log('[Register] Headers:', pm.response.headers.all());",
											"console.log('[Register] Raw Body:', pm.response.text());",
											"",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse JSON:', e);",
											"}",
											"",
											"let requestLogin = null;",
											"try {",
											"    const reqBodyRaw = pm.request.body && pm.request.body.raw ? pm.request.body.raw : '';",
											"    console.log('[Register] Request Raw Body:', reqBodyRaw);",
											"    if (reqBodyRaw) {",
											"        const reqJson = JSON.parse(reqBodyRaw);",
											"        requestLogin = reqJson && reqJson.login ? reqJson.login : null;",
											"    }",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse request body JSON:', e);",
											"}",
											"",
											"pm.test('Register: response status code is 201', function () {",
											"    pm.expect(pm.response.code).to.eql(201);",
											"});",
											"",
											"pm.test(\"Register: response JSON has status == 'success'\", function () {",
											"    pm.expect(json).to.be.an('object');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Register: message contains 'registered' (case-insensitive)\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    const msg = String(json.message || '');",
											"    pm.expect(msg.toLowerCase()).to.include('registered');",
											"});",
											"",
											"pm.test('Register: data.login equals the request body login', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.be.an('object');",
											"    if (requestLogin !== null) {",
											"        pm.expect(json.data.login).to.eql(requestLogin);",
											"    } else {",
											"        pm.expect(json.data).to.have.property('login');",
											"        pm.expect(json.data.login).to.be.a('string');",
											"    }",
											"});",
											"",
											"pm.test('Register: data.user_id exists and is a valid UUID v4', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.have.property('user_id');",
											"    const uuid = String(json.data.user_id || '');",
											"    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    pm.expect(uuid).to.match(uuidV4Regex);",
											"});",
											"",
											"pm.test(\"Register: 'Content-Type' header includes 'application/json'\", function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"bob\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - Successfully charlie",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('[Register] Status Code:', pm.response.code);",
											"console.log('[Register] Headers:', pm.response.headers.all());",
											"console.log('[Register] Raw Body:', pm.response.text());",
											"",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse JSON:', e);",
											"}",
											"",
											"let requestLogin = null;",
											"try {",
											"    const reqBodyRaw = pm.request.body && pm.request.body.raw ? pm.request.body.raw : '';",
											"    console.log('[Register] Request Raw Body:', reqBodyRaw);",
											"    if (reqBodyRaw) {",
											"        const reqJson = JSON.parse(reqBodyRaw);",
											"        requestLogin = reqJson && reqJson.login ? reqJson.login : null;",
											"    }",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse request body JSON:', e);",
											"}",
											"",
											"pm.test('Register: response status code is 201', function () {",
											"    pm.expect(pm.response.code).to.eql(201);",
											"});",
											"",
											"pm.test(\"Register: response JSON has status == 'success'\", function () {",
											"    pm.expect(json).to.be.an('object');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Register: message contains 'registered' (case-insensitive)\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    const msg = String(json.message || '');",
											"    pm.expect(msg.toLowerCase()).to.include('registered');",
											"});",
											"",
											"pm.test('Register: data.login equals the request body login', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.be.an('object');",
											"    if (requestLogin !== null) {",
											"        pm.expect(json.data.login).to.eql(requestLogin);",
											"    } else {",
											"        pm.expect(json.data).to.have.property('login');",
											"        pm.expect(json.data.login).to.be.a('string');",
											"    }",
											"});",
											"",
											"pm.test('Register: data.user_id exists and is a valid UUID v4', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.have.property('user_id');",
											"    const uuid = String(json.data.user_id || '');",
											"    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    pm.expect(uuid).to.match(uuidV4Regex);",
											"});",
											"",
											"pm.test(\"Register: 'Content-Type' header includes 'application/json'\", function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"charlie\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register - User already exists",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json = null;",
											"try { json = pm.response.json(); } catch (e) { /* non-JSON response */ }",
											"",
											"const status = pm.response.code;",
											"",
											"const UUID_V4_REGEX = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"let sentLogin = \"\";",
											"try {",
											"  const reqBody = pm.request.body?.mode === 'raw' ? pm.request.body.raw : null;",
											"  if (reqBody) {",
											"    const parsed = JSON.parse(reqBody);",
											"    sentLogin = parsed.login;",
											"  }",
											"} catch (e) { /* ignore parse errors */ }",
											"",
											"if (status === 201) {",
											"  pm.test(\"Status code is 201 Created\", function () {",
											"    pm.response.to.have.status(201);",
											"  });",
											"",
											"  pm.test(\"Response is JSON object\", function () {",
											"    pm.expect(json && typeof json === 'object').to.eql(true);",
											"  });",
											"",
											"  pm.test(\"Response has id (UUID), login matches request, and status is success\", function () {",
											"    pm.expect(json).to.have.property('id');",
											"    pm.expect(json.id).to.be.a('string');",
											"    pm.expect(UUID_V4_REGEX.test(json.id)).to.eql(true);",
											"",
											"    pm.expect(json).to.have.property('login');",
											"    pm.expect(json.login).to.eql(sentLogin || 'alice');",
											"",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.eql('success');",
											"  });",
											"",
											"  pm.test(\"Saved environment variable newUserId\", function () {",
											"    pm.expect(pm.environment.get('newUserId')).to.be.a('string');",
											"    pm.expect(pm.environment.get('newUserId')).to.have.length.greaterThan(0);",
											"  });",
											"}",
											"else if (status === 409) {",
											"  pm.test(\"Status code is 409 Conflict\", function () {",
											"    pm.response.to.have.status(409);",
											"  });",
											"",
											"  pm.test(\"Error body has expected code and message\", function () {",
											"    pm.expect(json && typeof json === 'object').to.eql(true);",
											"    pm.expect(json).to.have.property('code');",
											"    pm.expect(json.code).to.eql('LOGIN_EXISTS');",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(json.message).to.match(/already exists/i);",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.eql('error');",
											"  });",
											"}",
											"else {",
											"  pm.test(\"Unexpected status code - failing test\", function () {",
											"    pm.expect.fail(`Unexpected status code ${status}. Body: ${pm.response.text()}`);",
											"  });",
											"}"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Login",
					"item": [
						{
							"name": "Login - Invalid login",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const status = pm.response.code;",
											"  const rawBody = pm.response.text();",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"",
											"  console.log('[Login Tests] Status:', status);",
											"  console.log('[Login Tests] Content-Type:', contentType);",
											"  console.log('[Login Tests] Raw body:', rawBody);",
											"",
											"  pm.test('Content-Type header includes application/json', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  function tryParseJson(text) {",
											"    try { return JSON.parse(text); } catch (e) { return null; }",
											"  }",
											"",
											"  const json = tryParseJson(rawBody);",
											"",
											"  pm.test('Response status is either 200 (success) or 401 (invalid credentials)', function () {",
											"    pm.expect(status).to.be.oneOf([200, 401]);",
											"  });",
											"",
											"  if (status === 200) {",
											"    pm.test('Success: body is valid JSON', function () {",
											"      pm.expect(json, 'Response body should be JSON on success').to.not.be.null;",
											"    });",
											"",
											"    if (json) {",
											"      pm.test(\"Success: response has status 'success'\", function () {",
											"        pm.expect(json.status).to.eql('success');",
											"      });",
											"",
											"      pm.test(\"Success: response contains 'token' string\", function () {",
											"        const token = typeof json.token === 'string' ? json.token : (json.data && typeof json.data.token === 'string' ? json.data.token : null);",
											"        pm.expect(token, 'token should be present as string').to.be.a('string').and.to.have.length.above(0);",
											"      });",
											"    }",
											"  }",
											"",
											"  if (status === 401) {",
											"    pm.test('Failure: body is valid JSON', function () {",
											"      pm.expect(json, 'Response body should be JSON on 401').to.not.be.null;",
											"    });",
											"",
											"    if (json) {",
											"      pm.test(\"Failure: code is 'INVALID_CREDENTIALS'\", function () {",
											"        pm.expect(json.code).to.eql('INVALID_CREDENTIALS');",
											"      });",
											"",
											"      pm.test(\"Failure: message contains 'Invalid login or password'\", function () {",
											"        pm.expect(String(json.message || '')).to.include('Invalid login or password');",
											"      });",
											"    }",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"nonexist\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Invalid password",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Response has JSON Content-Type\", function () {",
											"  try {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"  } catch (e) {",
											"    console.error(\"Content-Type validation failed:\", e);",
											"    throw e;",
											"  }",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is parseable JSON\", function () {",
											"  try {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an(\"object\");",
											"  } catch (e) {",
											"    console.error(\"JSON parse failed. Raw body:\", pm.response.text());",
											"    throw e;",
											"  }",
											"});",
											"",
											"let reqLogin;",
											"try {",
											"  const reqBody = pm.request.body?.mode === 'raw' ? pm.request.body.raw : null;",
											"  reqLogin = reqBody ? JSON.parse(reqBody).login : undefined;",
											"} catch (e) {",
											"  console.error(\"Failed to parse request body for login:\", e);",
											"}",
											"",
											"pm.test(\"HTTP status is 200 for successful login OR 401 with proper error shape\", function () {",
											"  try {",
											"    const code = pm.response.code;",
											"    pm.expect([200, 401]).to.include(code);",
											"  } catch (e) {",
											"    console.error(\"Unexpected HTTP status:\", pm.response.code);",
											"    throw e;",
											"  }",
											"});",
											"",
											"pm.test(\"401 error has expected fields\", function () {",
											"  if (pm.response.code === 401) {",
											"    try {",
											"      pm.expect(json).to.have.property(\"code\");",
											"      pm.expect(json.code).to.eql(\"INVALID_CREDENTIALS\");",
											"      pm.expect(json).to.have.property(\"message\");",
											"      pm.expect(json.message).to.be.a(\"string\").and.not.empty;",
											"      pm.expect(json).to.have.property(\"status\");",
											"      pm.expect(json.status).to.be.a(\"string\");",
											"    } catch (e) {",
											"      console.error(\"401 payload validation failed. Body:\", json);",
											"      throw e;",
											"    }",
											"  } else {",
											"    pm.expect(true, \"Skipping 401 checks when status is not 401\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"200 success has token and user info\", function () {",
											"  if (pm.response.code === 200) {",
											"    try {",
											"      pm.expect(json).to.have.property(\"token\");",
											"      pm.expect(json.token).to.be.a(\"string\").and.not.empty;",
											"      pm.expect(json).to.have.property(\"user\").that.is.an(\"object\");",
											"      pm.expect(json.user).to.have.property(\"id\");",
											"      pm.expect(json.user.id).to.satisfy(v => typeof v === 'number' || (typeof v === 'string' && !isNaN(parseInt(v, 10))), \"user.id should be a number or numeric string\");",
											"      if (reqLogin) {",
											"        pm.expect(json.user).to.have.property(\"login\");",
											"        pm.expect(String(json.user.login)).to.eql(String(reqLogin));",
											"      }",
											"    } catch (e) {",
											"      console.error(\"200 payload validation failed. Body:\", json);",
											"      throw e;",
											"    }",
											"  } else {",
											"    pm.expect(true, \"Skipping 200 checks when status is not 200\").to.be.true;",
											"  }",
											"});",
											"",
											"function validateSuccessSchema(obj) {",
											"  try {",
											"    pm.expect(obj).to.be.an(\"object\");",
											"    pm.expect(obj).to.have.property(\"token\").that.is.a(\"string\");",
											"    pm.expect(obj).to.have.property(\"user\").that.is.an(\"object\");",
											"    pm.expect(obj.user).to.have.property(\"id\");",
											"    pm.expect(obj.user.id).to.satisfy(v => typeof v === 'number' || (typeof v === 'string' && !isNaN(parseInt(v, 10))));",
											"    if (reqLogin) {",
											"      pm.expect(obj.user).to.have.property(\"login\");",
											"      pm.expect(String(obj.user.login)).to.eql(String(reqLogin));",
											"    }",
											"    return true;",
											"  } catch (e) {",
											"    console.error(\"Success schema validation failed:\", e, \"Body:\", obj);",
											"    throw e;",
											"  }",
											"}",
											"",
											"function validateErrorSchema(obj) {",
											"  try {",
											"    pm.expect(obj).to.be.an(\"object\");",
											"    pm.expect(obj).to.have.property(\"code\").that.is.a(\"string\");",
											"    pm.expect(obj).to.have.property(\"message\").that.is.a(\"string\");",
											"    pm.expect(obj).to.have.property(\"status\").that.is.a(\"string\");",
											"    return true;",
											"  } catch (e) {",
											"    console.error(\"Error schema validation failed:\", e, \"Body:\", obj);",
											"    throw e;",
											"  }",
											"}",
											"",
											"pm.test(\"Schema validation for success/error\", function () {",
											"  if (pm.response.code === 200) {",
											"    validateSuccessSchema(json);",
											"  } else if (pm.response.code === 401) {",
											"    validateErrorSchema(json);",
											"  } else {",
											"    console.warn(\"No schema defined for status:\", pm.response.code);",
											"  }",
											"});",
											"",
											"const failed = _.get(pm, 'testRun.stats.tests.failed', 0);",
											"if (failed > 0) {",
											"  console.error(\"One or more tests failed.\", {",
											"    status: pm.response.code,",
											"    headers: pm.response.headers.toObject(),",
											"    body: pm.response.text()",
											"  });",
											"}"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass321@\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - No login",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function getJsonSafe() {",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    // Non-JSON response",
											"  }",
											"  return json;",
											"}",
											"",
											"const status = pm.response.code;",
											"const json = getJsonSafe();",
											"",
											"pm.test(\"Status code is 200 for success or 400/401 for errors\", function () {",
											"  pm.expect([200, 400, 401]).to.include(status);",
											"});",
											"",
											"pm.test(\"Response has JSON body\", function () {",
											"  pm.expect(json, \"Response must be valid JSON\").to.not.equal(null);",
											"  if (pm.response.headers.has(\"Content-Type\")) {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\");",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"  }",
											"});",
											"",
											"if (json && json.status === \"success\") {",
											"  pm.test(\"Success: status is 'success'\", function () {",
											"    pm.expect(json.status).to.eql(\"success\");",
											"  });",
											"",
											"  pm.test(\"Success: data contains accessToken and user object\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"accessToken\");",
											"    pm.expect(json.data.accessToken).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(json.data).to.have.property(\"user\");",
											"    pm.expect(json.data.user).to.be.an(\"object\");",
											"    pm.expect(json.data.user).to.have.property(\"id\");",
											"    pm.expect(json.data.user.id).to.satisfy(v => [\"string\",\"number\"].includes(typeof v));",
											"    pm.expect(json.data.user).to.have.property(\"login\");",
											"    pm.expect(json.data.user.login).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"} else if (json && json.status === \"error\") {",
											"  pm.test(\"Error: status is 'error' and code/message present\", function () {",
											"    pm.expect(json.status).to.eql(\"error\");",
											"    pm.expect(json).to.have.property(\"code\");",
											"    pm.expect(json.code).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"Error: MISSING_FIELDS returns 400 with helpful message\", function () {",
											"    if (json.code === \"MISSING_FIELDS\") {",
											"      pm.expect(status).to.eql(400);",
											"      pm.expect(json.message.toLowerCase()).to.include(\"login and password are required\");",
											"    } else {",
											"      pm.expect(true, \"Skipped: not a MISSING_FIELDS response\").to.be.true;",
											"    }",
											"  });",
											"",
											"  pm.test(\"Error: INVALID_CREDENTIALS returns 401\", function () {",
											"    if (json.code === \"INVALID_CREDENTIALS\") {",
											"      pm.expect(status).to.eql(401);",
											"    } else {",
											"      pm.expect(true, \"Skipped: not an INVALID_CREDENTIALS response\").to.be.true;",
											"    }",
											"  });",
											"",
											"} else if (json) {",
											"  pm.test(\"Body has recognizable status property\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"  });",
											"} else {",
											"  pm.test(\"Non-JSON response fallback\", function () {",
											"    pm.expect.fail(\"Expected JSON response body but parsing failed\");",
											"  });",
											"}",
											"",
											"pm.test(\"Request: required fields present in request body (login, password)\", function () {",
											"  let reqBody = {};",
											"  try {",
											"    if (pm.request.body && pm.request.body.mode === 'raw') {",
											"      reqBody = JSON.parse(pm.request.body.raw || '{}');",
											"    }",
											"  } catch (e) { /* ignore parse errors */ }",
											"",
											"  const hasLogin = typeof reqBody.login === 'string' && reqBody.login.trim().length > 0;",
											"  const hasPassword = typeof reqBody.password === 'string' && reqBody.password.trim().length > 0;",
											"",
											"  pm.expect(hasLogin, \"login should be provided for success scenarios\").to.be.a('boolean');",
											"  pm.expect(hasPassword, \"password should be provided for success scenarios\").to.be.a('boolean');",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"password\": \"pass\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - No password",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    pm.test(\"Response is JSON\", function () {",
											"        pm.expect.fail(\"Response is not valid JSON\");",
											"    });",
											"}",
											"",
											"if (pm.response.code === 200) {",
											"    pm.test(\"Status code is 200\", function () {",
											"        pm.response.to.have.status(200);",
											"    });",
											"",
											"    pm.test(\"Response has token (string) and user object with id and login\", function () {",
											"        pm.expect(json).to.be.an(\"object\");",
											"        pm.expect(json).to.have.property(\"token\").that.is.a(\"string\");",
											"        pm.expect(json).to.have.property(\"user\").that.is.an(\"object\");",
											"        pm.expect(json.user).to.have.property(\"id\");",
											"        pm.expect(json.user).to.have.property(\"login\").that.is.a(\"string\");",
											"    });",
											"}",
											"else if (pm.response.code === 400) {",
											"    pm.test(\"Status code is 400\", function () {",
											"        pm.response.to.have.status(400);",
											"    });",
											"",
											"    pm.test(\"Error body has code and message\", function () {",
											"        pm.expect(json).to.be.an(\"object\");",
											"        pm.expect(json).to.have.property(\"code\").that.is.a(\"string\");",
											"        pm.expect(json).to.have.property(\"message\").that.is.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"If code is MISSING_FIELDS then message mentions 'required'\", function () {",
											"        if (json && json.code === \"MISSING_FIELDS\") {",
											"            pm.expect(String(json.message).toLowerCase()).to.include(\"required\");",
											"        } else {",
											"            pm.expect(true).to.be.true; // not applicable",
											"        }",
											"    });",
											"}",
											"else {",
											"    pm.test(\"Unexpected status code handled\", function () {",
											"        pm.expect([200, 400]).to.include(pm.response.code);",
											"    });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"user\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Empty login",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const status = pm.response.code;",
											"  const bodyText = pm.response.text();",
											"",
											"  pm.test(\"Content-Type is application/json\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"  });",
											"",
											"  let json;",
											"  pm.test(\"Response body is valid JSON\", function () {",
											"    try {",
											"      json = pm.response.json();",
											"      pm.expect(typeof json).to.be.oneOf([\"object\", \"array\"]);",
											"    } catch (e) {",
											"      json = null;",
											"      pm.expect.fail(\"Response is not valid JSON: \" + e.message + \" | Body: \" + bodyText.slice(0, 300));",
											"    }",
											"  });",
											"",
											"  function extractToken(obj) {",
											"    if (!obj || typeof obj !== \"object\") return null;",
											"    return obj.access_token || obj.accessToken || obj.token || (obj.data && (obj.data.access_token || obj.data.token)) || null;",
											"  }",
											"  function extractUser(obj) {",
											"    if (!obj || typeof obj !== \"object\") return {};",
											"    const user = obj.user || obj.data && obj.data.user || obj.profile || {};",
											"    const id = user.id || user.userId || obj.userId || null;",
											"    const email = user.email || obj.email || null;",
											"    return { id, email };",
											"  }",
											"",
											"  if (status === 200) {",
											"    pm.test(\"Status code is 200\", function () {",
											"      pm.expect(status).to.eql(200);",
											"    });",
											"",
											"    if (json && typeof json === \"object\") {",
											"      pm.test(\"Success response has status 'success' or contains an access token\", function () {",
											"        const hasSuccess = String(json.status || \"\").toLowerCase() === \"success\";",
											"        const token = extractToken(json);",
											"        pm.expect(hasSuccess || !!token, \"Expected status 'success' or a token in the payload\").to.be.true;",
											"      });",
											"",
											"      pm.test(\"Response schema contains expected fields (non-strict)\", function () {",
											"        pm.expect(json).to.be.an(\"object\");",
											"        const maybeData = json.data || {};",
											"        pm.expect([json, maybeData]).to.satisfy(arr => !!arr);",
											"      });",
											"    }",
											"  } else if (status === 401) {",
											"    pm.test(\"Status code is 401 (Unauthorized)\", function () {",
											"      pm.expect(status).to.eql(401);",
											"    });",
											"",
											"    pm.test(\"Unauthorized response has code INVALID_CREDENTIALS\", function () {",
											"      pm.expect(json && json.code, \"Missing 'code' in error response\").to.eql(\"INVALID_CREDENTIALS\");",
											"    });",
											"",
											"    pm.environment.unset(\"authToken\");",
											"  } else if (status >= 400 && status < 600) {",
											"    pm.test(\"Fail on unexpected client/server error\", function () {",
											"      pm.expect.fail(`Unexpected error status ${status}. Body: ${bodyText.slice(0, 300)}`);",
											"    });",
											"  } else {",
											"    pm.test(\"Unexpected non-200/401 status\", function () {",
											"      pm.expect([200, 401]).to.include(status);",
											"    });",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Empty password",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"  const responseJson = pm.response.json();",
											"  console.log('Login response JSON:', responseJson);",
											"",
											"  pm.test('Response has a status code', function () {",
											"    pm.expect(pm.response.code).to.be.a('number');",
											"  });",
											"",
											"  pm.test('Content-Type is application/json', function () {",
											"    pm.expect(pm.response.headers.get('Content-Type') || '').to.include('application/json');",
											"  });",
											"",
											"  if (pm.response.code === 200) {",
											"    pm.test('Response status indicates success', function () {",
											"      if (responseJson.status) {",
											"        pm.expect(responseJson.status).to.eql('success');",
											"      } else {",
											"        pm.expect(pm.response.code).to.eql(200);",
											"      }",
											"    });",
											"",
											"    pm.test('Contains auth token (accessToken or token)', function () {",
											"      pm.expect(responseJson).to.be.an('object');",
											"      pm.expect(responseJson).to.satisfy(function (body) {",
											"        return !!body.accessToken || !!body.token;",
											"      });",
											"    });",
											"",
											"    pm.test('Contains user object with id and login', function () {",
											"      pm.expect(responseJson.user).to.be.an('object');",
											"      pm.expect(responseJson.user).to.have.property('id');",
											"      pm.expect(responseJson.user).to.have.property('login');",
											"    });",
											"  }",
											"",
											"  if ([400, 401, 403].includes(pm.response.code)) {",
											"    pm.test('Response indicates error status', function () {",
											"      pm.expect(responseJson.status).to.eql('error');",
											"    });",
											"",
											"    pm.test('Error code is one of expected values', function () {",
											"      const expected = ['INVALID_CREDENTIALS', 'MISSING_FIELDS', 'FORBIDDEN', 'UNAUTHORIZED'];",
											"      pm.expect(responseJson.code).to.be.oneOf(expected);",
											"    });",
											"  }",
											"",
											"} catch (e) {",
											"  pm.test('Response is valid JSON', function () {",
											"    pm.expect.fail('Response body is not valid JSON: ' + e.message);",
											"  });",
											"}",
											"",
											"console.log('Status code:', pm.response.code);"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"user\",\r\n    \"password\": \"\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log(\"[Login] HTTP Status:\", pm.response.code, pm.response.status);",
											"",
											"let isJson = true;",
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  isJson = false;",
											"}",
											"",
											"if (isJson) {",
											"  console.log(\"[Login] Payload status:\", json && json.status);",
											"  console.log(\"[Login] Payload code:\", json && json.code);",
											"  console.log(\"[Login] Payload message:\", json && json.message);",
											"} else {",
											"  console.log(\"[Login] Non-JSON response:\", pm.response.text());",
											"}",
											"",
											"pm.test(\"Status code is 404\", function () {",
											"  pm.expect(pm.response.code, \"Expected HTTP 404 but got \" + pm.response.code).to.eql(404);",
											"});",
											"",
											"pm.test(\"Response is valid JSON\", function () {",
											"  pm.expect(isJson, \"Response body is not valid JSON. Body: \" + pm.response.text()).to.be.true;",
											"});",
											"",
											"pm.test(\"JSON contains required top-level keys\", function () {",
											"  pm.expect(isJson, \"Cannot validate keys when response is not JSON\").to.be.true;",
											"  pm.expect(json).to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"code\");",
											"  pm.expect(json).to.have.property(\"message\");",
											"  pm.expect(json).to.have.property(\"status\");",
											"  // data is optional",
											"});",
											"",
											"pm.test(\"Successful login structure when status===success\", function () {",
											"  pm.expect(isJson, \"Response must be JSON for success checks\").to.be.true;",
											"  if (isJson && json.status === \"success\") {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"",
											"    pm.expect(json.data).to.have.property(\"token\");",
											"    pm.expect(json.data.token, \"Token should be a non-empty string\").to.be.a(\"string\").and.not.empty;",
											"",
											"    pm.expect(json.data).to.have.property(\"user\");",
											"    pm.expect(json.data.user).to.be.an(\"object\");",
											"    pm.expect(json.data.user).to.have.property(\"id\");",
											"    pm.expect(json.data.user.id, \"User id should be present\").to.exist;",
											"    pm.expect(json.data.user).to.have.property(\"email\");",
											"    pm.expect(json.data.user.email, \"User email should be a non-empty string\").to.be.a(\"string\").and.not.empty;",
											"  }",
											"});",
											"",
											"pm.test(\"Error response validation when status===error\", function () {",
											"  pm.expect(isJson, \"Response must be JSON for error checks\").to.be.true;",
											"  if (isJson && json.status === \"error\") {",
											"    pm.expect(json).to.have.property(\"code\");",
											"    pm.expect([\"INVALID_CREDENTIALS\", \"ENDPOINT_NOT_FOUND\", \"VALIDATION_ERROR\"],",
											"      \"Unexpected error code: \" + json.code).to.include(json.code);",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message, \"Error message should be non-empty\").to.be.a(\"string\").and.not.empty;",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Invalid json format",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function safeJsonParse() {",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    // Not JSON or malformed",
											"  }",
											"  return json;",
											"}",
											"",
											"const status = pm.response.code;",
											"const isJSON = pm.response.headers.has('Content-Type') &&",
											"  /application\\/json/i.test(pm.response.headers.get('Content-Type'));",
											"const body = pm.response.text();",
											"const json = safeJsonParse();",
											"",
											"pm.test(\"Response is JSON when Content-Type is application/json\", function () {",
											"  if (isJSON) {",
											"    pm.expect(json, \"Body should be valid JSON when Content-Type is application/json\").to.not.be.null;",
											"  } else {",
											"    pm.expect(true, \"Non-JSON response allowed\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"No success for server errors (>=500)\", function () {",
											"  if (status >= 500) {",
											"    pm.expect(status, \"Server error should not be reported as success\").to.not.be.within(200, 299);",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"200 OK contains auth token\", function () {",
											"  if (status === 200 && json) {",
											"    const token = json?.data?.token || json?.token;",
											"    pm.expect(token, \"Expected token at data.token or token on 200\").to.be.a('string').and.to.have.length.greaterThan(0);",
											"  } else if (status === 200) {",
											"    pm.expect.fail(\"Expected JSON body on 200 response\");",
											"  } else {",
											"    pm.expect(true).to.be.true; // not applicable",
											"  }",
											"});",
											"",
											"pm.test(\"400 returns code = INVALID_JSON\", function () {",
											"  if (status === 400) {",
											"    if (!json) {",
											"      pm.expect.fail(\"Expected JSON body on 400 response\");",
											"    } else {",
											"      pm.expect(json.code, \"Expected error code 'INVALID_JSON' for 400\").to.eql('INVALID_JSON');",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"401 has Unauthorized code or message\", function () {",
											"  if (status === 401) {",
											"    if (!json) {",
											"      pm.expect.fail(\"Expected JSON body on 401 response\");",
											"    } else {",
											"      const hasUnauthorizedCode = (json.code && /unauthorized/i.test(String(json.code))) || false;",
											"      const hasUnauthorizedMsg = (json.message && /unauthorized/i.test(String(json.message))) || false;",
											"      pm.expect(hasUnauthorizedCode || hasUnauthorizedMsg, \"Expected 'Unauthorized' code or message for 401\").to.be.true;",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Graceful handling for non-JSON responses\", function () {",
											"  if (!json) {",
											"    pm.expect(true, \"Response body not JSON or malformed. Body: \" + body.slice(0, 200)).to.be.true;",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"somelogin\",\r\n    \"password\": \"pass\"\r\n}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Empty json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const reqName = pm.info.requestName || 'Register';",
											"  const status = pm.response.code;",
											"  const is2xx = pm.response.code >= 200 && pm.response.code < 300;",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"",
											"  pm.test('baseURL variable is defined and non-empty', function () {",
											"    const baseURL = pm.variables.get('baseURL');",
											"    pm.expect(baseURL, 'baseURL is missing').to.be.a('string');",
											"    pm.expect(baseURL, 'baseURL should not be empty').to.have.length.above(0);",
											"  });",
											"",
											"  pm.test('Content-Type is application/json', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  let json;",
											"  pm.test('Response has a valid JSON body', function () {",
											"    try {",
											"      json = pm.response.json();",
											"      pm.expect(json).to.be.an('object');",
											"    } catch (e) {",
											"      console.log('[Tests][' + reqName + '] JSON parse error:', e);",
											"      pm.expect.fail('Response body is not valid JSON');",
											"    }",
											"  });",
											"",
											"  function getStr(o, k) { return (o && typeof o[k] === 'string') ? o[k] : undefined; }",
											"",
											"  pm.test('Status is success (201 Created or 200 OK) OR documented error', function () {",
											"    const isSuccess = [200, 201].includes(status);",
											"    const isKnownInvalidJson = status === 400 && json && json.code === 'INVALID_JSON';",
											"",
											"    pm.expect(isSuccess || isKnownInvalidJson, `Unexpected status ${status}`).to.be.true;",
											"  });",
											"",
											"  pm.test('Success schema: id, identity (login/username/email), createdAt and optional token', function () {",
											"    if (!is2xx || !json) {",
											"      pm.expect(true, 'Skipped because response is not success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    const identityField = ['login', 'username', 'email'].find(k => getStr(json, k));",
											"",
											"    pm.expect(json, 'Response body should be an object').to.be.an('object');",
											"    pm.expect(json, 'Body should have an id').to.have.property('id');",
											"",
											"    pm.expect(['string', 'number']).to.include(typeof json.id);",
											"",
											"    pm.expect(identityField, 'Should include login, username, or email string').to.be.oneOf(['login','username','email']);",
											"    if (identityField) {",
											"      pm.expect(getStr(json, identityField), `${identityField} should be a non-empty string`).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"",
											"    pm.expect(json).to.have.property('createdAt');",
											"    if (json.createdAt != null) {",
											"      pm.expect(json.createdAt).to.be.a('string');",
											"      const d = new Date(json.createdAt);",
											"      pm.expect(isNaN(d.getTime()), 'createdAt should be a valid date string').to.be.false;",
											"    }",
											"",
											"    if (json.token !== undefined) {",
											"      pm.expect(json.token).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"  });",
											"",
											"  pm.test('Error shape on failure: code/message/status present and types valid', function () {",
											"    if (pm.response.code < 400) {",
											"      pm.expect(true, 'Skipped because response is success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    pm.expect(json, 'Error response should be a JSON object').to.be.an('object');",
											"",
											"    pm.expect(json).to.have.property('code');",
											"    pm.expect(typeof json.code, 'code should be a string').to.equal('string');",
											"",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(typeof json.message, 'message should be a string').to.equal('string');",
											"",
											"    if (json.status !== undefined) {",
											"      pm.expect(typeof json.status, 'status should be a string').to.equal('string');",
											"    }",
											"",
											"    if (status === 400) {",
											"      pm.expect(json.code, '400 error should include INVALID_JSON code when body is invalid').to.be.oneOf(['INVALID_JSON', json.code]);",
											"    }",
											"  });",
											"",
											"  console.log(`[Tests][${reqName}] Status:`, status);",
											"  console.log(`[Tests][${reqName}] Content-Type:`, contentType);",
											"  if (json) {",
											"    const sample = JSON.stringify(json).slice(0, 500);",
											"    console.log(`[Tests][${reqName}] Body sample (first 500 chars):`, sample);",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Successfully alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"aliceAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"aliceRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"aliceAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"aliceRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Successfully bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"bobAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"bobRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"bobAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"bobRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"bob\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login - Successfully charlie",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"charlieAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"charlieRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"charlieAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"charlieRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"charlie\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Refresh",
					"item": [
						{
							"name": "Refresh - Invalid refresh token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function tryParseJsonSafe(text) {",
											"  try {",
											"    return { ok: true, data: JSON.parse(text) };",
											"  } catch (e) {",
											"    return { ok: false, error: e };",
											"  }",
											"}",
											"",
											"const status = pm.response.code;",
											"const parse = tryParseJsonSafe(pm.response.text());",
											"",
											"pm.test(\"Response is JSON or safely handled\", function () {",
											"  pm.expect(parse.ok, 'Body should be valid JSON').to.be.true;",
											"});",
											"",
											"const body = parse.ok ? parse.data : {};",
											"",
											"pm.test(\"Has standard top-level fields when error\", function () {",
											"  if ([400, 401, 422].includes(status)) {",
											"    pm.expect(body).to.be.an('object');",
											"    pm.expect(body).to.have.property('status');",
											"    pm.expect(body).to.have.property('message');",
											"    pm.expect(body).to.have.property('code');",
											"    pm.expect(body.status).to.be.a('string');",
											"    pm.expect(body.message).to.be.a('string');",
											"    pm.expect(body.code).to.be.a('string');",
											"  } else {",
											"    pm.expect(true).to.be.true; // noop for other statuses",
											"  }",
											"});",
											"",
											"pm.test(\"200 | success response shape\", function () {",
											"  if (status === 200) {",
											"    pm.expect(body).to.be.an('object');",
											"    const data = body.data && typeof body.data === 'object' ? body.data : body;",
											"",
											"    pm.expect(body.status, 'status should be success').to.equal('success');",
											"    pm.expect(data).to.have.property('access_token');",
											"    pm.expect(data).to.have.property('refresh_token');",
											"    pm.expect(data.access_token).to.be.a('string').and.not.empty;",
											"    pm.expect(data.refresh_token).to.be.a('string').and.not.empty;",
											"  } else {",
											"    pm.expect(true).to.be.true; // skip",
											"  }",
											"});",
											"",
											"pm.test(\"400/422 | validation error contains code and message\", function () {",
											"  if (status === 400 || status === 422) {",
											"    pm.expect(body).to.be.an('object');",
											"    pm.expect(body).to.have.property('code');",
											"    pm.expect(body).to.have.property('message');",
											"    pm.expect(body.code).to.be.a('string').and.not.empty;",
											"    pm.expect(body.message).to.be.a('string').and.not.empty;",
											"  } else {",
											"    pm.expect(true).to.be.true; // skip",
											"  }",
											"});",
											"",
											"pm.test(\"401 | refresh failed error code is REFRESH_FAILED\", function () {",
											"  if (status === 401) {",
											"    pm.expect(body).to.be.an('object');",
											"    pm.expect(body).to.have.property('code');",
											"    pm.expect(body.code).to.equal('REFRESH_FAILED');",
											"    pm.expect(body).to.have.property('message');",
											"    pm.expect(body.message).to.be.a('string');",
											"    pm.expect(body).to.have.property('status');",
											"    pm.expect(body.status).to.equal('error');",
											"  } else {",
											"    pm.expect(true).to.be.true; // skip",
											"  }",
											"});",
											"",
											"pm.test(\"No token persistence on non-200\", function () {",
											"  if (status !== 200) {",
											"    if (body && typeof body === 'object') {",
											"      if (body.status) {",
											"        pm.expect(body.status).to.not.equal('success');",
											"      }",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleisiOjE3NjQxNzk4NzQsImlhdCI6MTc2NDE3ODk3NCwiaXNzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJsOWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiY2JiNDhhY2ItMjVlNi00YzBiLWI4YzYtZWJjNzc5ZWNiOTQxIn0.TuK6LiJIPP5AaEjWH_6GqEqSdfUQf1DeDnm5NF5p1sx\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						},
						{
							"name": "Refresh - Empty refresh token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 on success\", function () {",
											"  if (pm.response.code === 200) {",
											"    pm.response.to.have.status(200);",
											"  } else {",
											"    pm.expect([400, 401, 403, 429, 500]).to.include(pm.response.code);",
											"  }",
											"});",
											"",
											"pm.test(\"Response is valid JSON\", function () {",
											"  pm.response.to.be.json;",
											"});",
											"",
											"pm.test(\"Has access_token and refresh_token on success\", function () {",
											"  if (pm.response.code === 200) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('access_token');",
											"    pm.expect(json).to.have.property('refresh_token');",
											"    pm.expect(json.access_token).to.be.a('string').and.not.empty;",
											"    pm.expect(json.refresh_token).to.be.a('string').and.not.empty;",
											"  }",
											"});",
											"",
											"pm.test(\"Tokens follow JWT format (3 parts) if JWT\", function () {",
											"  if (pm.response.code === 200) {",
											"    var json = pm.response.json();",
											"    try {",
											"      var parts = json.access_token.split('.');",
											"      pm.expect(parts.length).to.eql(3);",
											"    } catch (e) {",
											"      pm.test('access_token looks like a string', function(){",
											"        pm.expect(json.access_token).to.be.a('string');",
											"      });",
											"    }",
											"  }",
											"});",
											"",
											"if (pm.response.code === 401) {",
											"  var json = pm.response.json();",
											"  pm.test('Handles refresh failure 401: error code REFRESH_FAILED', function(){",
											"    pm.expect(json).to.have.property('code');",
											"    pm.expect(json.code).to.eql('REFRESH_FAILED');",
											"  });",
											"  pm.test('Handles refresh failure 401: status is error', function(){",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.eql('error');",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						},
						{
							"name": "Refresh - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status is 200 or 404\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
											"});",
											"",
											"pm.test(\"Content-Type is application/json\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"(function validateByStatus() {",
											"  const status = pm.response.code;",
											"  let json = {};",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    // keep json as empty object if not valid JSON",
											"  }",
											"",
											"  if (status === 200) {",
											"    pm.test(\"200: body has access_token (non-empty string) and expires_in (positive integer)\", function () {",
											"      pm.expect(json).to.be.an(\"object\");",
											"      pm.expect(json).to.have.property(\"access_token\");",
											"      pm.expect(json.access_token).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
											"      pm.expect(json).to.have.property(\"expires_in\");",
											"      pm.expect(json.expires_in).to.be.a(\"number\");",
											"      pm.expect(Number.isInteger(json.expires_in)).to.eql(true);",
											"      pm.expect(json.expires_in).to.be.greaterThan(0);",
											"    });",
											"  }",
											"",
											"  if (status === 404) {",
											"    pm.test(\"404: body has code == 'ENDPOINT_NOT_FOUND' and message contains 'not found' (case-insensitive)\", function () {",
											"      pm.expect(json).to.be.an(\"object\");",
											"      pm.expect(json).to.have.property(\"code\");",
											"      pm.expect(json.code).to.eql(\"ENDPOINT_NOT_FOUND\");",
											"      pm.expect(json).to.have.property(\"message\");",
											"      const msg = String(json.message || \"\");",
											"      pm.expect(msg.toLowerCase()).to.include(\"not found\");",
											"    });",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleisiOjE3NjQxNzk4NzQsImlhdCI6MTc2NDE3ODk3NCwiaXNzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJsOWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiY2JiNDhhY2ItMjVlNi00YzBiLWI4YzYtZWJjNzc5ZWNiOTQxIn0.TuK6LiJIPP5AaEjWH_6GqEqSdfUQf1DeDnm5NF5p1sx\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						},
						{
							"name": "Refresh - Invalid json format",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function safeJsonParse() {",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    // Not JSON or malformed",
											"  }",
											"  return json;",
											"}",
											"",
											"const status = pm.response.code;",
											"const isJSON = pm.response.headers.has('Content-Type') &&",
											"  /application\\/json/i.test(pm.response.headers.get('Content-Type'));",
											"const body = pm.response.text();",
											"const json = safeJsonParse();",
											"",
											"pm.test(\"Response is JSON when Content-Type is application/json\", function () {",
											"  if (isJSON) {",
											"    pm.expect(json, \"Body should be valid JSON when Content-Type is application/json\").to.not.be.null;",
											"  } else {",
											"    pm.expect(true, \"Non-JSON response allowed\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"No success for server errors (>=500)\", function () {",
											"  if (status >= 500) {",
											"    pm.expect(status, \"Server error should not be reported as success\").to.not.be.within(200, 299);",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"200 OK contains auth token\", function () {",
											"  if (status === 200 && json) {",
											"    const token = json?.data?.token || json?.token;",
											"    pm.expect(token, \"Expected token at data.token or token on 200\").to.be.a('string').and.to.have.length.greaterThan(0);",
											"  } else if (status === 200) {",
											"    pm.expect.fail(\"Expected JSON body on 200 response\");",
											"  } else {",
											"    pm.expect(true).to.be.true; // not applicable",
											"  }",
											"});",
											"",
											"pm.test(\"400 returns code = INVALID_JSON\", function () {",
											"  if (status === 400) {",
											"    if (!json) {",
											"      pm.expect.fail(\"Expected JSON body on 400 response\");",
											"    } else {",
											"      pm.expect(json.code, \"Expected error code 'INVALID_JSON' for 400\").to.eql('INVALID_JSON');",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"401 has Unauthorized code or message\", function () {",
											"  if (status === 401) {",
											"    if (!json) {",
											"      pm.expect.fail(\"Expected JSON body on 401 response\");",
											"    } else {",
											"      const hasUnauthorizedCode = (json.code && /unauthorized/i.test(String(json.code))) || false;",
											"      const hasUnauthorizedMsg = (json.message && /unauthorized/i.test(String(json.message))) || false;",
											"      pm.expect(hasUnauthorizedCode || hasUnauthorizedMsg, \"Expected 'Unauthorized' code or message for 401\").to.be.true;",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Graceful handling for non-JSON responses\", function () {",
											"  if (!json) {",
											"    pm.expect(true, \"Response body not JSON or malformed. Body: \" + body.slice(0, 200)).to.be.true;",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"\"\r\n}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						},
						{
							"name": "Refresh - Empty json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const reqName = pm.info.requestName || 'Register';",
											"  const status = pm.response.code;",
											"  const is2xx = pm.response.code >= 200 && pm.response.code < 300;",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"",
											"  pm.test('baseURL variable is defined and non-empty', function () {",
											"    const baseURL = pm.variables.get('baseURL');",
											"    pm.expect(baseURL, 'baseURL is missing').to.be.a('string');",
											"    pm.expect(baseURL, 'baseURL should not be empty').to.have.length.above(0);",
											"  });",
											"",
											"  pm.test('Content-Type is application/json', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  let json;",
											"  pm.test('Response has a valid JSON body', function () {",
											"    try {",
											"      json = pm.response.json();",
											"      pm.expect(json).to.be.an('object');",
											"    } catch (e) {",
											"      console.log('[Tests][' + reqName + '] JSON parse error:', e);",
											"      pm.expect.fail('Response body is not valid JSON');",
											"    }",
											"  });",
											"",
											"  function getStr(o, k) { return (o && typeof o[k] === 'string') ? o[k] : undefined; }",
											"",
											"  pm.test('Status is success (201 Created or 200 OK) OR documented error', function () {",
											"    const isSuccess = [200, 201].includes(status);",
											"    const isKnownInvalidJson = status === 400 && json && json.code === 'INVALID_JSON';",
											"",
											"    pm.expect(isSuccess || isKnownInvalidJson, `Unexpected status ${status}`).to.be.true;",
											"  });",
											"",
											"  pm.test('Success schema: id, identity (login/username/email), createdAt and optional token', function () {",
											"    if (!is2xx || !json) {",
											"      pm.expect(true, 'Skipped because response is not success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    const identityField = ['login', 'username', 'email'].find(k => getStr(json, k));",
											"",
											"    pm.expect(json, 'Response body should be an object').to.be.an('object');",
											"    pm.expect(json, 'Body should have an id').to.have.property('id');",
											"",
											"    pm.expect(['string', 'number']).to.include(typeof json.id);",
											"",
											"    pm.expect(identityField, 'Should include login, username, or email string').to.be.oneOf(['login','username','email']);",
											"    if (identityField) {",
											"      pm.expect(getStr(json, identityField), `${identityField} should be a non-empty string`).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"",
											"    pm.expect(json).to.have.property('createdAt');",
											"    if (json.createdAt != null) {",
											"      pm.expect(json.createdAt).to.be.a('string');",
											"      const d = new Date(json.createdAt);",
											"      pm.expect(isNaN(d.getTime()), 'createdAt should be a valid date string').to.be.false;",
											"    }",
											"",
											"    if (json.token !== undefined) {",
											"      pm.expect(json.token).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"  });",
											"",
											"  pm.test('Error shape on failure: code/message/status present and types valid', function () {",
											"    if (pm.response.code < 400) {",
											"      pm.expect(true, 'Skipped because response is success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    pm.expect(json, 'Error response should be a JSON object').to.be.an('object');",
											"    pm.expect(json).to.have.property('code');",
											"    pm.expect(typeof json.code, 'code should be a string').to.equal('string');",
											"",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(typeof json.message, 'message should be a string').to.equal('string');",
											"",
											"    if (json.status !== undefined) {",
											"      pm.expect(typeof json.status, 'status should be a string').to.equal('string');",
											"    }",
											"",
											"    if (status === 400) {",
											"      pm.expect(json.code, '400 error should include INVALID_JSON code when body is invalid').to.be.oneOf(['INVALID_JSON', json.code]);",
											"    }",
											"  });",
											"",
											"  console.log(`[Tests][${reqName}] Status:`, status);",
											"  console.log(`[Tests][${reqName}] Content-Type:`, contentType);",
											"  if (json) {",
											"    const sample = JSON.stringify(json).slice(0, 500);",
											"    console.log(`[Tests][${reqName}] Body sample (first 500 chars):`, sample);",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						},
						{
							"name": "Refresh - Successfully alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"  pm.test('Response status is 200', function () {",
											"    pm.response.to.have.status(200);",
											"  });",
											"",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    pm.test('Response is valid JSON', function () {",
											"      throw new Error('Response is not valid JSON: ' + e.message);",
											"    });",
											"  }",
											"",
											"  pm.test('Response has status === \"success\"', function () {",
											"    pm.expect(json).to.have.property('status', 'success');",
											"  });",
											"",
											"  pm.test('Response message is Tokens refreshed successfully', function () {",
											"    pm.expect(json).to.have.property('message', 'Tokens refreshed successfully');",
											"  });",
											"",
											"  pm.test('Response has data object with required fields', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    var data = json.data;",
											"    pm.expect(data).to.be.an('object');",
											"    pm.expect(data).to.have.property('access_token').that.is.a('string').and.not.empty;",
											"    pm.expect(data).to.have.property('refresh_token').that.is.a('string').and.not.empty;",
											"    pm.expect(data).to.have.property('expires_in').that.is.a('number');",
											"    pm.expect(data.expires_in).to.be.above(0);",
											"    pm.expect(data).to.have.property('token_type', 'Bearer');",
											"    pm.expect(data).to.have.property('user_id').that.is.a('string').and.not.empty;",
											"    pm.expect(data.user_id).to.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/);",
											"  });",
											"",
											"  pm.test(\"Persist refreshed tokens to collection variables\", function () {",
											"    const d = json.data;",
											"    const oldAccessToken = pm.collectionVariables.get(\"aliceAccessToken\");",
											"    const oldRefreshToken = pm.collectionVariables.get(\"aliceRefreshToken\");",
											"",
											"    pm.collectionVariables.set(\"aliceAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"aliceRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"aliceAccessToken\")).to.be.a('string').and.to.not.be.empty;",
											"    pm.expect(pm.collectionVariables.get(\"aliceRefreshToken\")).to.be.a('string').and.to.not.be.empty;",
											"    pm.expect(oldAccessToken).to.not.eql(pm.collectionVariables.get(\"aliceAccessToken\"));",
											"    pm.expect(oldRefreshToken).to.not.eql(pm.collectionVariables.get(\"aliceRefreshToken\"));",
											"  });",
											"",
											"} catch (err) {",
											"  pm.test('Post-response script completed without uncaught exceptions', function () {",
											"    throw err;",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"{{aliceRefreshToken}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						},
						{
							"name": "Refresh - Successfully bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"  pm.test('Response status is 200', function () {",
											"    pm.response.to.have.status(200);",
											"  });",
											"",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    pm.test('Response is valid JSON', function () {",
											"      throw new Error('Response is not valid JSON: ' + e.message);",
											"    });",
											"  }",
											"",
											"  pm.test('Response has status === \"success\"', function () {",
											"    pm.expect(json).to.have.property('status', 'success');",
											"  });",
											"",
											"  pm.test('Response message is Tokens refreshed successfully', function () {",
											"    pm.expect(json).to.have.property('message', 'Tokens refreshed successfully');",
											"  });",
											"",
											"  pm.test('Response has data object with required fields', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    var data = json.data;",
											"    pm.expect(data).to.be.an('object');",
											"    pm.expect(data).to.have.property('access_token').that.is.a('string').and.not.empty;",
											"    pm.expect(data).to.have.property('refresh_token').that.is.a('string').and.not.empty;",
											"    pm.expect(data).to.have.property('expires_in').that.is.a('number');",
											"    pm.expect(data.expires_in).to.be.above(0);",
											"    pm.expect(data).to.have.property('token_type', 'Bearer');",
											"    pm.expect(data).to.have.property('user_id').that.is.a('string').and.not.empty;",
											"    pm.expect(data.user_id).to.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/);",
											"  });",
											"",
											"  pm.test(\"Persist refreshed tokens to collection variables\", function () {",
											"    const d = json.data;",
											"    const oldAccessToken = pm.collectionVariables.get(\"bobAccessToken\");",
											"    const oldRefreshToken = pm.collectionVariables.get(\"bobRefreshToken\");",
											"",
											"    pm.collectionVariables.set(\"bobAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"bobRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"bobAccessToken\")).to.be.a('string').and.to.not.be.empty;",
											"    pm.expect(pm.collectionVariables.get(\"bobRefreshToken\")).to.be.a('string').and.to.not.be.empty;",
											"    pm.expect(oldAccessToken).to.not.eql(pm.collectionVariables.get(\"bobAccessToken\"));",
											"    pm.expect(oldRefreshToken).to.not.eql(pm.collectionVariables.get(\"bobRefreshToken\"));",
											"  });",
											"",
											"} catch (err) {",
											"  pm.test('Post-response script completed without uncaught exceptions', function () {",
											"    throw err;",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"{{bobRefreshToken}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						},
						{
							"name": "Refresh - Successfully charlie",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"try {",
											"  pm.test('Response status is 200', function () {",
											"    pm.response.to.have.status(200);",
											"  });",
											"",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    pm.test('Response is valid JSON', function () {",
											"      throw new Error('Response is not valid JSON: ' + e.message);",
											"    });",
											"  }",
											"",
											"  pm.test('Response has status === \"success\"', function () {",
											"    pm.expect(json).to.have.property('status', 'success');",
											"  });",
											"",
											"  pm.test('Response message is Tokens refreshed successfully', function () {",
											"    pm.expect(json).to.have.property('message', 'Tokens refreshed successfully');",
											"  });",
											"",
											"  pm.test('Response has data object with required fields', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    var data = json.data;",
											"    pm.expect(data).to.be.an('object');",
											"    pm.expect(data).to.have.property('access_token').that.is.a('string').and.not.empty;",
											"    pm.expect(data).to.have.property('refresh_token').that.is.a('string').and.not.empty;",
											"    pm.expect(data).to.have.property('expires_in').that.is.a('number');",
											"    pm.expect(data.expires_in).to.be.above(0);",
											"    pm.expect(data).to.have.property('token_type', 'Bearer');",
											"    pm.expect(data).to.have.property('user_id').that.is.a('string').and.not.empty;",
											"    pm.expect(data.user_id).to.match(/^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/);",
											"  });",
											"",
											"  pm.test(\"Persist refreshed tokens to collection variables\", function () {",
											"    const d = json.data;",
											"    const oldAccessToken = pm.collectionVariables.get(\"charlieAccessToken\");",
											"    const oldRefreshToken = pm.collectionVariables.get(\"charlieRefreshToken\");",
											"",
											"    pm.collectionVariables.set(\"charlieAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"charlieRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"charlieAccessToken\")).to.be.a('string').and.to.not.be.empty;",
											"    pm.expect(pm.collectionVariables.get(\"charlieRefreshToken\")).to.be.a('string').and.to.not.be.empty;",
											"    pm.expect(oldAccessToken).to.not.eql(pm.collectionVariables.get(\"charlieAccessToken\"));",
											"    pm.expect(oldRefreshToken).to.not.eql(pm.collectionVariables.get(\"charlieRefreshToken\"));",
											"  });",
											"",
											"} catch (err) {",
											"  pm.test('Post-response script completed without uncaught exceptions', function () {",
											"    throw err;",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"{{charlieRefreshToken}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/refresh",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"refresh"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Password",
					"item": [
						{
							"name": "Password - Invalid access token",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"let bodyRaw = pm.response.text();",
											"let bodyJson = null;",
											"try {",
											"    bodyJson = pm.response.json();",
											"    console.log(\"Parsed JSON response:\", bodyJson);",
											"} catch (e) {",
											"    console.log(\"Response is not JSON. Raw body:\", bodyRaw);",
											"}",
											"",
											"function hasProp(obj, key) {",
											"    return obj && Object.prototype.hasOwnProperty.call(obj, key);",
											"}",
											"",
											"pm.test(\"Status code is one of: 200, 400, 401, 403, 422, 500\", function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 403, 422, 500]);",
											"});",
											"",
											"const status = pm.response.code;",
											"",
											"if (status === 200) {",
											"    pm.test(\"200: Response is JSON\", function () {",
											"        pm.expect(bodyJson, \"Expected a JSON body on success\").to.be.an(\"object\");",
											"    });",
											"",
											"    if (bodyJson) {",
											"        pm.test(\"200: Has code, message, and optional data\", function () {",
											"            pm.expect(hasProp(bodyJson, 'code')).to.eql(true);",
											"            pm.expect(hasProp(bodyJson, 'message')).to.eql(true);",
											"        });",
											"",
											"        pm.test(\"200: code indicates success\", function () {",
											"            const successCodes = [\"SUCCESS\", \"OK\", \"UPDATED\", \"PASSWORD_CHANGED\"];",
											"            if (typeof bodyJson.code === 'string') {",
											"                pm.expect(successCodes).to.include(bodyJson.code.toUpperCase());",
											"            } else {",
											"                pm.expect.fail(\"'code' should be a string on success\");",
											"            }",
											"        });",
											"",
											"        pm.test(\"200: data is optional but, if present, is an object\", function () {",
											"            if (hasProp(bodyJson, 'data') && bodyJson.data !== null && bodyJson.data !== undefined) {",
											"                pm.expect(bodyJson.data).to.be.an('object');",
											"            }",
											"        });",
											"    }",
											"}",
											"",
											"if (status === 400 || status === 422) {",
											"    pm.test(status + \": Body contains validation details (errors[] or message)\", function () {",
											"        pm.expect(bodyJson, \"Expected JSON body for validation errors\").to.be.an(\"object\");",
											"        const hasErrorsArray = Array.isArray(bodyJson && bodyJson.errors);",
											"        const hasMessage = typeof (bodyJson && bodyJson.message) === 'string';",
											"        pm.expect(hasErrorsArray || hasMessage).to.eql(true);",
											"    });",
											"",
											"    pm.test(status + \": If errors present, each error is an object/string\", function () {",
											"        if (Array.isArray(bodyJson && bodyJson.errors)) {",
											"            bodyJson.errors.forEach((err, idx) => {",
											"                pm.expect([\"string\", \"object\"]).to.include(typeof err, \"errors[\" + idx + \"] type\");",
											"            });",
											"        }",
											"    });",
											"}",
											"",
											"if (status === 401 || status === 403) {",
											"    pm.test(status + \": Body has code INVALID_TOKEN/UNAUTHORIZED and message\", function () {",
											"        pm.expect(bodyJson, \"Expected JSON body for auth errors\").to.be.an(\"object\");",
											"        const code = bodyJson && bodyJson.code;",
											"        const msg = bodyJson && bodyJson.message;",
											"        pm.expect([\"INVALID_TOKEN\", \"UNAUTHORIZED\"]).to.include(String(code).toUpperCase());",
											"        pm.expect(typeof msg).to.eql(\"string\");",
											"    });",
											"}",
											"",
											"if (status === 500) {",
											"    console.log(\"500 Server Error - full response for debugging:\", {",
											"        status: pm.response.code,",
											"        headers: pm.response.headers.toObject(),",
											"        body: bodyJson || bodyRaw",
											"    });",
											"",
											"    pm.test(\"500: Body has code and message\", function () {",
											"        pm.expect(bodyJson, \"Expected JSON body for server errors\").to.be.an(\"object\");",
											"        pm.expect(hasProp(bodyJson, 'code')).to.eql(true);",
											"        pm.expect(hasProp(bodyJson, 'message')).to.eql(true);",
											"    });",
											"}",
											"",
											"console.log(\"Request:\", {",
											"    method: pm.request.method,",
											"    url: pm.request.url.toString(),",
											"    headers: pm.request.headers.toObject(),",
											"    body: pm.request.body && pm.request.body.toString()",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUz1INiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjQxODYwMjEsImlhdCI6MTc2NDE4NTEyMSwiaZYzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJzdWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXDpcklEIjoiY2JiNDhhY2ItMjVlNi00YzBiLWI4YzYtZWJjNzc5ZWNiOTQxIn0.rfG8MheF-BZ1Ujdfn8odr_0wtxvqY-EsXSzzkZXDpVU",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass123!\",\r\n  \"new_password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Invalid current password",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  function safeLogOnFail(title, fn) {",
											"    try { fn(); }",
											"    catch (e) {",
											"      console.warn('[Test Failure]', title, '\\nReason:', e && e.message ? e.message : e);",
											"      console.warn('Request:', {",
											"        name: pm.info.requestName,",
											"        method: pm.request.method,",
											"        url: pm.request.url && pm.request.url.getRaw ? pm.request.url.getRaw() : pm.request.url,",
											"      });",
											"      console.warn('Response meta:', {",
											"        code: pm.response.code,",
											"        status: pm.response.status,",
											"        contentType: pm.response.headers.get('Content-Type')",
											"      });",
											"      throw e; // rethrow to fail the test",
											"    }",
											"  }",
											"",
											"  function tryParseJson(text) {",
											"    try { return JSON.parse(text); } catch (e) { return null; }",
											"  }",
											"",
											"  function isJsonContentType(ct) {",
											"    return typeof ct === 'string' && /application\\/(json|.*\\+json)/i.test(ct);",
											"  }",
											"",
											"  pm.test('Status code is present', function () {",
											"    pm.expect(pm.response.code).to.be.a('number');",
											"  });",
											"",
											"  pm.test('Content-Type is JSON', function () {",
											"    const ct = pm.response.headers.get('Content-Type');",
											"    pm.expect(isJsonContentType(ct), 'Expected JSON Content-Type, got ' + ct).to.be.true;",
											"  });",
											"",
											"  const rawBody = pm.response.text();",
											"  const json = tryParseJson(rawBody);",
											"",
											"  pm.test('Body is valid JSON', function () {",
											"    pm.expect(json, 'Response body is not valid JSON').to.not.be.null;",
											"    pm.expect(json).to.be.an('object');",
											"  });",
											"",
											"  if (pm.response.code >= 400 && pm.response.code < 500 && json) {",
											"    pm.test('Error payload has required fields', function () {",
											"      pm.expect(json).to.have.property('code').that.is.a('string');",
											"      pm.expect(json).to.have.property('message').that.is.a('string');",
											"      pm.expect(json).to.have.property('status').that.is.a('string');",
											"    });",
											"",
											"    pm.test('Error payload status is \"error\"', function () {",
											"      pm.expect(json.status).to.eql('error');",
											"    });",
											"  }",
											"",
											"  if (pm.response.code === 200 || pm.response.code === 204) {",
											"    pm.test('Successful password change response structure', function () {",
											"      if (pm.response.code === 204 || rawBody.trim().length === 0) {",
											"        pm.expect(rawBody.trim().length).to.eql(0);",
											"        return;",
											"      }",
											"",
											"      pm.expect(json).to.be.an('object');",
											"      pm.expect(json).to.have.property('message').that.is.a('string');",
											"      if (json.metadata !== undefined) {",
											"        pm.expect(json.metadata).to.be.an('object');",
											"      }",
											"    });",
											"  }",
											"",
											"  if (pm.response.code === 403 && json) {",
											"    pm.test('Error code equals INVALID_PASSWORD', function () {",
											"      pm.expect(json.code).to.eql('INVALID_PASSWORD');",
											"    });",
											"",
											"    pm.test('Error message mentions incorrect current password', function () {",
											"      pm.expect(json.message).to.include('Current password is incorrect');",
											"    });",
											"  }",
											"",
											"  safeLogOnFail('Required variables are defined', function () {",
											"    const hasBaseUrl = pm.variables.get('baseURL') || pm.environment.get('baseURL') || pm.collectionVariables.get('baseURL') || pm.globals.get('baseURL');",
											"    const hasToken = pm.variables.get('aliceAccessToken') || pm.environment.get('aliceAccessToken') || pm.collectionVariables.get('aliceAccessToken') || pm.globals.get('aliceAccessToken');",
											"    pm.expect(Boolean(hasBaseUrl), 'Missing variable: baseURL').to.be.true;",
											"    pm.expect(Boolean(hasToken), 'Missing variable: aliceAccessToken').to.be.true;",
											"  });",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass321@\",\r\n  \"new_password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Invalid new password",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Response has JSON content-type', function () {",
											"  pm.response.to.have.header('Content-Type');",
											"  pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
											"});",
											"",
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  json = undefined;",
											"}",
											"",
											"pm.test('Response status code is 200 or expected error 400', function () {",
											"  pm.expect([200,400]).to.include(pm.response.code);",
											"});",
											"",
											"pm.test('Response body has required fields', function () {",
											"  pm.expect(json).to.be.an('object');",
											"  pm.expect(json).to.have.property('code');",
											"  pm.expect(json).to.have.property('message');",
											"  pm.expect(json).to.have.property('status');",
											"  if (pm.response.code === 200) {",
											"    pm.expect(json).to.have.property('data');",
											"  }",
											"});",
											"",
											"pm.test('Invalid password error details', function () {",
											"  if (pm.response.code === 400) {",
											"    pm.expect(json.code).to.eql('INVALID_PASSWORD');",
											"    pm.expect((json.message || '').toLowerCase()).to.include('at least 6');",
											"  } else {",
											"    pm.expect(pm.response.code).to.not.eql(400);",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass123!\",\r\n  \"new_password\": \"pass\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Empty current password",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  json = null;",
											"}",
											"",
											"pm.test(\"Status code is 200 or 403\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 403]);",
											"});",
											"",
											"pm.test(\"If 200: body has SUCCESS code, success status, and message mentions password\", function () {",
											"  if (pm.response.code === 200 && json) {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json.code, \"code should be 'SUCCESS'\").to.eql(\"SUCCESS\");",
											"    pm.expect(json.status, \"status should be 'success'\").to.eql(\"success\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    const msg = String(json.message || \"\");",
											"    pm.expect(/password/i.test(msg), \"message should reference 'password'\").to.be.true;",
											"  } else {",
											"    pm.expect(true).to.be.true; // skip in non-200 cases",
											"  }",
											"});",
											"",
											"pm.test(\"If 403: body has INVALID_PASSWORD code, error status, and a message\", function () {",
											"  if (pm.response.code === 403 && json) {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json.code, \"code should be 'INVALID_PASSWORD'\").to.eql(\"INVALID_PASSWORD\");",
											"    pm.expect(json.status, \"status should be 'error'\").to.eql(\"error\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(String(json.message)).to.have.length.of.at.least(1);",
											"  } else {",
											"    pm.expect(true).to.be.true; // skip in non-403 cases",
											"  }",
											"});",
											"",
											"pm.test(\"Content-Type includes application/json\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"(function logSummary(){",
											"  const status = pm.response.code + \" \" + pm.response.status;",
											"  const rt = pm.response.responseTime + \" ms\";",
											"  let outcome = \"Unknown\";",
											"  if (pm.response.code === 200) outcome = \"Password change SUCCESS\";",
											"  else if (pm.response.code === 403) outcome = \"Password change FAILED: Invalid current password\";",
											"  console.log(\"[Password Update] Status:\", status, \"| Time:\", rt, \"| Outcome:\", outcome);",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"\",\r\n  \"new_password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Empty new password",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function logDebug() {",
											"    try {",
											"        const reqBody = pm.request.body && pm.request.body.mode === 'raw' ? pm.request.body.raw : null;",
											"        console.log('Request Body (raw):', reqBody);",
											"    } catch (e) {",
											"        console.log('Could not read request body:', e.message);",
											"    }",
											"",
											"    try {",
											"        console.log('Response Body (text):', pm.response.text());",
											"    } catch (e) {",
											"        console.log('Could not read response body:', e.message);",
											"    }",
											"})();",
											"",
											"function safeParseJson() {",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    let bodyText = '';",
											"    try { bodyText = pm.response.text(); } catch (_) {}",
											"",
											"    try {",
											"        return JSON.parse(bodyText);",
											"    } catch (e) {",
											"        pm.test(\"Response body must be valid JSON\", function () {",
											"            pm.expect.fail(\"Expected JSON response but could not parse. Content-Type=\" + ct + \". Body=\" + bodyText);",
											"        });",
											"        return null;",
											"    }",
											"}",
											"",
											"const json = safeParseJson();",
											"",
											"pm.test(\"HTTP status is one of expected (200, 400, 401, 403)\", function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 403]);",
											"});",
											"",
											"if (json) {",
											"    if (pm.response.code === 200) {",
											"        pm.test(\"200: status is 'success'\", function () {",
											"            pm.expect(json).to.be.an('object');",
											"            pm.expect(json.status).to.eql('success');",
											"        });",
											"        pm.test(\"200: message mentions password change\", function () {",
											"            const msg = (json.message || '').toString().toLowerCase();",
											"            pm.expect(msg).to.satisfy(m => m.includes('password') || m.includes('changed'));",
											"        });",
											"        pm.test(\"200: no error code field present\", function () {",
											"            pm.expect(json).to.not.have.property('code');",
											"        });",
											"    }",
											"",
											"    if (pm.response.code === 400) {",
											"        pm.test(\"400: status is 'error' and includes a validation code\", function () {",
											"            pm.expect(json.status).to.eql('error');",
											"            pm.expect(json).to.have.property('code');",
											"        });",
											"        pm.test(\"400: message mentions password and validation hints\", function () {",
											"            const msg = (json.message || '').toString().toLowerCase();",
											"            const hints = ['password', 'length', 'minimum', 'must', 'invalid', 'require', 'character'];",
											"            pm.expect(hints.some(h => msg.includes(h)), \"Message should include password and validation/length hints\").to.be.true;",
											"        });",
											"    }",
											"",
											"    if (pm.response.code === 401 || pm.response.code === 403) {",
											"        pm.test(\"401/403: status 'error' with auth-related code\", function () {",
											"            pm.expect(json.status).to.eql('error');",
											"            pm.expect(json).to.have.property('code');",
											"            const code = (json.code || '').toString().toUpperCase();",
											"            const authLike = ['UNAUTHORIZED', 'UNAUTHENTICATED', 'INVALID_TOKEN', 'FORBIDDEN', 'INSUFFICIENT_SCOPE', 'ACCESS_DENIED'];",
											"            pm.expect(authLike.some(c => code.includes(c)), \"Code should indicate auth/forbidden\").to.be.true;",
											"        });",
											"    }",
											"}",
											"",
											"if (json && typeof json === 'object') {",
											"    pm.test(\"Response JSON contains status and message fields (when applicable)\", function () {",
											"        pm.expect(json).to.have.property('status');",
											"        pm.expect(json).to.have.property('message');",
											"    });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass123!\",\r\n  \"new_password\": \"\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - No current password",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"let isJson = false;",
											"let body;",
											"try {",
											"  body = pm.response.json();",
											"  isJson = true;",
											"} catch (e) {",
											"  body = pm.response.text();",
											"}",
											"",
											"pm.test(\"Content-Type is JSON when body is present\", function () {",
											"  if (pm.response.text().length) {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"  } else {",
											"    pm.expect(true).to.be.true; // no-op if empty body",
											"  }",
											"});",
											"",
											"if (isJson) {",
											"  pm.test(\"Response has standard fields (code, message, status)\", function () {",
											"    pm.expect(body).to.be.an(\"object\");",
											"    pm.expect(body).to.have.property(\"status\");",
											"    pm.expect(body).to.have.property(\"message\");",
											"    pm.expect(body).to.have.property(\"code\");",
											"    pm.expect(body.status).to.be.a(\"string\");",
											"    pm.expect(body.message).to.be.a(\"string\");",
											"    pm.expect(body.code).to.be.a(\"string\");",
											"  });",
											"}",
											"",
											"pm.test(\"Password change success: 400 or 401\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([400, 401]);",
											"});",
											"",
											"if (pm.response.code === 200 && isJson) {",
											"  pm.test(\"Success payload indicates success status\", function () {",
											"    pm.expect(body.status.toLowerCase()).to.be.oneOf([\"success\", \"ok\"]);",
											"  });",
											"}",
											"",
											"if (pm.response.code === 400 && isJson) {",
											"  pm.test(\"400 error includes specific code and message\", function () {",
											"    pm.expect(body.code).to.be.oneOf([",
											"      \"MISSING_FIELDS\",",
											"      \"INVALID_FIELDS\",",
											"      \"VALIDATION_ERROR\",",
											"      \"WEAK_PASSWORD\"",
											"    ]);",
											"    pm.expect(body.message.length).to.be.greaterThan(0);",
											"    pm.expect(body.status.toLowerCase()).to.equal(\"error\");",
											"  });",
											"}",
											"",
											"if (pm.response.code === 401 && isJson) {",
											"  pm.test(\"401 indicates auth failure\", function () {",
											"    pm.expect(body.code).to.be.oneOf([\"UNAUTHORIZED\", \"INVALID_TOKEN\", \"TOKEN_EXPIRED\"]);",
											"    pm.expect(body.status.toLowerCase()).to.equal(\"error\");",
											"  });",
											"}",
											"",
											"if (pm.response.code === 403 && isJson) {",
											"  pm.test(\"403 indicates forbidden action\", function () {",
											"    pm.expect(body.code).to.be.oneOf([\"FORBIDDEN\", \"INSUFFICIENT_SCOPE\"]);",
											"    pm.expect(body.status.toLowerCase()).to.equal(\"error\");",
											"  });",
											"}",
											"",
											"if (pm.response.code === 409 && isJson) {",
											"  pm.test(\"409 indicates password reuse conflict\", function () {",
											"    pm.expect(body.code).to.be.oneOf([\"PASSWORD_REUSE\", \"CONFLICT\"]);",
											"    pm.expect(body.status.toLowerCase()).to.equal(\"error\");",
											"  });",
											"}",
											"",
											"if (pm.response.code === 422 && isJson) {",
											"  pm.test(\"422 indicates password policy violation\", function () {",
											"    pm.expect(body.code).to.be.oneOf([\"PASSWORD_POLICY_VIOLATION\", \"UNPROCESSABLE_ENTITY\"]);",
											"    pm.expect(body.status.toLowerCase()).to.equal(\"error\");",
											"  });",
											"}",
											"",
											"if (pm.response.code === 429 && isJson) {",
											"  pm.test(\"429 indicates rate limit exceeded\", function () {",
											"    pm.expect(body.code).to.match(/RATE_LIMIT|TOO_MANY/i);",
											"    pm.expect(body.status.toLowerCase()).to.equal(\"error\");",
											"  });",
											"}",
											"",
											"if (pm.response.code >= 500) {",
											"  pm.test(\"Server error status code\", function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([500, 502, 503, 504]);",
											"  });",
											"}",
											"",
											"if (isJson && body) {",
											"  pm.test(\"Response does not echo sensitive fields\", function () {",
											"    const forbiddenKeys = [\"password\", \"new_password\", \"old_password\", \"current_password\"];",
											"    const serialized = JSON.stringify(body).toLowerCase();",
											"    const found = forbiddenKeys.filter(k => serialized.includes('\"' + k + '\"'));",
											"    pm.expect(found, \"Should not include sensitive keys in response\").to.be.empty;",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"new_password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - No new password",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const name = pm.info.requestName || \"Change Password\";",
											"  const isJson = pm.response.headers.get(\"Content-Type\") && pm.response.headers.get(\"Content-Type\").toLowerCase().includes(\"application/json\");",
											"",
											"  function tryParseJson() {",
											"    if (!isJson) return null;",
											"    try { return pm.response.json(); } catch (e) { return null; }",
											"  }",
											"",
											"  const body = tryParseJson();",
											"  const code = pm.response.code;",
											"",
											"  pm.test(\"Content-Type should be JSON when applicable\", function () {",
											"    if ([200,400,401,403,422].includes(code)) {",
											"      pm.expect(isJson, `Expected JSON Content-Type for status ${code}`).to.be.true;",
											"    } else {",
											"      pm.expect(pm.response.headers.has(\"Content-Type\"), \"Response should include Content-Type header\").to.be.true;",
											"    }",
											"  });",
											"",
											"  switch (code) {",
											"    case 200: {",
											"      pm.test(\"200 OK: Valid success schema\", function () {",
											"        pm.expect(isJson, \"200 response must be JSON\").to.be.true;",
											"        pm.expect(body, \"Body should be parsed JSON\").to.be.an(\"object\");",
											"        pm.expect(body).to.have.property(\"code\", \"SUCCESS\");",
											"        pm.expect(body).to.have.property(\"message\");",
											"        pm.expect(body.message, \"message should be a non-empty string\").to.be.a(\"string\").and.to.have.length.greaterThan(0);",
											"        if (Object.prototype.hasOwnProperty.call(body, \"data\")) {",
											"          pm.expect(body.data, \"data should be an object when present\").to.be.an(\"object\");",
											"          if (body.data && Object.prototype.hasOwnProperty.call(body.data, \"userId\")) {",
											"            pm.expect(body.data.userId, \"data.userId should be a non-empty string or number\").to.satisfy(v => typeof v === \"string\" || typeof v === \"number\");",
											"          }",
											"        }",
											"      });",
											"      break;",
											"    }",
											"",
											"    case 400: {",
											"      pm.test(\"400 Bad Request: Proper error code and message\", function () {",
											"        pm.expect(isJson, \"400 response must be JSON\").to.be.true;",
											"        pm.expect(body, \"Body should be parsed JSON\").to.be.an(\"object\");",
											"        pm.expect(body).to.have.property(\"code\");",
											"        pm.expect([\"MISSING_FIELDS\", \"INVALID_PASSWORD\"], `Unexpected error code for 400: ${body && body.code}`).to.include(body.code);",
											"        pm.expect(body).to.have.property(\"message\");",
											"        pm.expect(body.message, \"message should be a meaningful string\").to.be.a(\"string\").and.to.have.length.greaterThan(0);",
											"",
											"        if (body.code === \"MISSING_FIELDS\") {",
											"          const expectedHints = [\"Old password\", \"new password\", \"required\", \"missing\"];",
											"          const msg = body.message.toLowerCase();",
											"          const hasHint = expectedHints.some(h => msg.includes(h.toLowerCase()));",
											"          pm.expect(hasHint, `message should indicate missing fields (got: '${body.message}')`).to.be.true;",
											"        }",
											"        if (body.code === \"INVALID_PASSWORD\") {",
											"          const expectedHints = [\"invalid\", \"password\", \"does not meet\", \"policy\", \"incorrect\", \"old password\"];",
											"          const msg = body.message.toLowerCase();",
											"          const hasHint = expectedHints.some(h => msg.includes(h.toLowerCase()));",
											"          pm.expect(hasHint, `message should indicate invalid password (got: '${body.message}')`).to.be.true;",
											"        }",
											"      });",
											"      break;",
											"    }",
											"",
											"    case 401:",
											"    case 403: {",
											"      pm.test(`${code} Auth Error: Proper code and message`, function () {",
											"        pm.expect(isJson, `${code} response must be JSON`).to.be.true;",
											"        pm.expect(body, \"Body should be parsed JSON\").to.be.an(\"object\");",
											"        pm.expect(body).to.have.property(\"code\");",
											"        if (code === 401) {",
											"          pm.expect([\"UNAUTHORIZED\"], `Expected 'UNAUTHORIZED' for 401 but got ${body.code}`).to.include(body.code);",
											"        } else if (code === 403) {",
											"          pm.expect([\"FORBIDDEN\"], `Expected 'FORBIDDEN' for 403 but got ${body.code}`).to.include(body.code);",
											"        }",
											"        if (body.message) {",
											"          pm.expect(body.message, \"message should be a string\").to.be.a(\"string\");",
											"        }",
											"      });",
											"      break;",
											"    }",
											"",
											"    default: {",
											"      if (code >= 500) {",
											"        pm.test(`5xx Server Error handling (status ${code})`, function () {",
											"          pm.expect(isJson, \"5xx response should be JSON when possible\").to.be.true;",
											"          pm.expect(body, \"Body should be parsed JSON\").to.be.an(\"object\");",
											"          if (body) {",
											"            pm.expect(body).to.have.property(\"status\");",
											"            pm.expect(body.status, `Expected body.status === 'error' for 5xx but got '${body.status}'`).to.eql(\"error\");",
											"          }",
											"        });",
											"      } else {",
											"        pm.test(`Unexpected status ${code}: Body shape is reasonable`, function () {",
											"          if (isJson && body) {",
											"            pm.expect(body, \"Body should be object for JSON responses\").to.be.an(\"object\");",
											"            pm.expect(body).to.have.any.keys(\"code\", \"message\", \"status\");",
											"          } else {",
											"            pm.expect(pm.response.text().length, \"Non-JSON response should not be empty\").to.be.greaterThan(0);",
											"          }",
											"        });",
											"      }",
											"    }",
											"  }",
											"",
											"  pm.test(\"When new_password is missing, server should respond with 400 + MISSING_FIELDS\", function () {",
											"    if (code === 400 && isJson && body) {",
											"      const requestHasOnlyOldPassword = (function(){",
											"        try {",
											"          const raw = pm.request.body && pm.request.body.raw ? pm.request.body.raw : \"\";",
											"          const parsed = raw ? JSON.parse(raw) : {};",
											"          return parsed && parsed.old_password && !parsed.new_password;",
											"        } catch(e) { return false; }",
											"      })();",
											"",
											"      if (requestHasOnlyOldPassword) {",
											"        pm.expect(body.code, `Expected MISSING_FIELDS when new_password is absent but got ${body.code}`).to.eql(\"MISSING_FIELDS\");",
											"      }",
											"    }",
											"  });",
											"",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status is 200 or 404\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 404]);",
											"});",
											"",
											"pm.test(\"Content-Type is application/json\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"(function validateByStatus() {",
											"  const status = pm.response.code;",
											"  let json = {};",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    // keep json as empty object if not valid JSON",
											"  }",
											"",
											"  if (status === 200) {",
											"    pm.test(\"200: body has access_token (non-empty string) and expires_in (positive integer)\", function () {",
											"      pm.expect(json).to.be.an(\"object\");",
											"      pm.expect(json).to.have.property(\"access_token\");",
											"      pm.expect(json.access_token).to.be.a(\"string\").and.to.have.length.greaterThan(0);",
											"      pm.expect(json).to.have.property(\"expires_in\");",
											"      pm.expect(json.expires_in).to.be.a(\"number\");",
											"      pm.expect(Number.isInteger(json.expires_in)).to.eql(true);",
											"      pm.expect(json.expires_in).to.be.greaterThan(0);",
											"    });",
											"  }",
											"",
											"  if (status === 404) {",
											"    pm.test(\"404: body has code == 'ENDPOINT_NOT_FOUND' and message contains 'not found' (case-insensitive)\", function () {",
											"      pm.expect(json).to.be.an(\"object\");",
											"      pm.expect(json).to.have.property(\"code\");",
											"      pm.expect(json.code).to.eql(\"ENDPOINT_NOT_FOUND\");",
											"      pm.expect(json).to.have.property(\"message\");",
											"      const msg = String(json.message || \"\");",
											"      pm.expect(msg.toLowerCase()).to.include(\"not found\");",
											"    });",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleisiOjE3NjQxNzk4NzQsImlhdCI6MTc2NDE3ODk3NCwiaXNzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJsOWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiY2JiNDhhY2ItMjVlNi00YzBiLWI4YzYtZWJjNzc5ZWNiOTQxIn0.TuK6LiJIPP5AaEjWH_6GqEqSdfUQf1DeDnm5NF5p1sx\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Invalid json format",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function safeJsonParse() {",
											"  let json = null;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    // Not JSON or malformed",
											"  }",
											"  return json;",
											"}",
											"",
											"const status = pm.response.code;",
											"const isJSON = pm.response.headers.has('Content-Type') &&",
											"  /application\\/json/i.test(pm.response.headers.get('Content-Type'));",
											"const body = pm.response.text();",
											"const json = safeJsonParse();",
											"",
											"pm.test(\"Response is JSON when Content-Type is application/json\", function () {",
											"  if (isJSON) {",
											"    pm.expect(json, \"Body should be valid JSON when Content-Type is application/json\").to.not.be.null;",
											"  } else {",
											"    pm.expect(true, \"Non-JSON response allowed\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"No success for server errors (>=500)\", function () {",
											"  if (status >= 500) {",
											"    pm.expect(status, \"Server error should not be reported as success\").to.not.be.within(200, 299);",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"200 OK contains auth token\", function () {",
											"  if (status === 200 && json) {",
											"    const token = json?.data?.token || json?.token;",
											"    pm.expect(token, \"Expected token at data.token or token on 200\").to.be.a('string').and.to.have.length.greaterThan(0);",
											"  } else if (status === 200) {",
											"    pm.expect.fail(\"Expected JSON body on 200 response\");",
											"  } else {",
											"    pm.expect(true).to.be.true; // not applicable",
											"  }",
											"});",
											"",
											"pm.test(\"400 returns code = INVALID_JSON\", function () {",
											"  if (status === 400) {",
											"    if (!json) {",
											"      pm.expect.fail(\"Expected JSON body on 400 response\");",
											"    } else {",
											"      pm.expect(json.code, \"Expected error code 'INVALID_JSON' for 400\").to.eql('INVALID_JSON');",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"401 has Unauthorized code or message\", function () {",
											"  if (status === 401) {",
											"    if (!json) {",
											"      pm.expect.fail(\"Expected JSON body on 401 response\");",
											"    } else {",
											"      const hasUnauthorizedCode = (json.code && /unauthorized/i.test(String(json.code))) || false;",
											"      const hasUnauthorizedMsg = (json.message && /unauthorized/i.test(String(json.message))) || false;",
											"      pm.expect(hasUnauthorizedCode || hasUnauthorizedMsg, \"Expected 'Unauthorized' code or message for 401\").to.be.true;",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Graceful handling for non-JSON responses\", function () {",
											"  if (!json) {",
											"    pm.expect(true, \"Response body not JSON or malformed. Body: \" + body.slice(0, 200)).to.be.true;",
											"  } else {",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"\"\r\n}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Empty json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const reqName = pm.info.requestName || 'Register';",
											"  const status = pm.response.code;",
											"  const is2xx = pm.response.code >= 200 && pm.response.code < 300;",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"",
											"  pm.test('baseURL variable is defined and non-empty', function () {",
											"    const baseURL = pm.variables.get('baseURL');",
											"    pm.expect(baseURL, 'baseURL is missing').to.be.a('string');",
											"    pm.expect(baseURL, 'baseURL should not be empty').to.have.length.above(0);",
											"  });",
											"",
											"  pm.test('Content-Type is application/json', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  let json;",
											"  pm.test('Response has a valid JSON body', function () {",
											"    try {",
											"      json = pm.response.json();",
											"      pm.expect(json).to.be.an('object');",
											"    } catch (e) {",
											"      console.log('[Tests][' + reqName + '] JSON parse error:', e);",
											"      pm.expect.fail('Response body is not valid JSON');",
											"    }",
											"  });",
											"",
											"  function getStr(o, k) { return (o && typeof o[k] === 'string') ? o[k] : undefined; }",
											"",
											"  pm.test('Status is success (201 Created or 200 OK) OR documented error', function () {",
											"    const isSuccess = [200, 201].includes(status);",
											"    const isKnownInvalidJson = status === 400 && json && json.code === 'INVALID_JSON';",
											"",
											"    pm.expect(isSuccess || isKnownInvalidJson, `Unexpected status ${status}`).to.be.true;",
											"  });",
											"",
											"  pm.test('Success schema: id, identity (login/username/email), createdAt and optional token', function () {",
											"    if (!is2xx || !json) {",
											"      pm.expect(true, 'Skipped because response is not success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    const identityField = ['login', 'username', 'email'].find(k => getStr(json, k));",
											"",
											"    pm.expect(json, 'Response body should be an object').to.be.an('object');",
											"    pm.expect(json, 'Body should have an id').to.have.property('id');",
											"",
											"    pm.expect(['string', 'number']).to.include(typeof json.id);",
											"",
											"    pm.expect(identityField, 'Should include login, username, or email string').to.be.oneOf(['login','username','email']);",
											"    if (identityField) {",
											"      pm.expect(getStr(json, identityField), `${identityField} should be a non-empty string`).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"",
											"    pm.expect(json).to.have.property('createdAt');",
											"    if (json.createdAt != null) {",
											"      pm.expect(json.createdAt).to.be.a('string');",
											"      const d = new Date(json.createdAt);",
											"      pm.expect(isNaN(d.getTime()), 'createdAt should be a valid date string').to.be.false;",
											"    }",
											"",
											"    if (json.token !== undefined) {",
											"      pm.expect(json.token).to.be.a('string').and.to.have.length.above(0);",
											"    }",
											"  });",
											"",
											"  pm.test('Error shape on failure: code/message/status present and types valid', function () {",
											"    if (pm.response.code < 400) {",
											"      pm.expect(true, 'Skipped because response is success').to.be.true;",
											"      return;",
											"    }",
											"",
											"    pm.expect(json, 'Error response should be a JSON object').to.be.an('object');",
											"    pm.expect(json).to.have.property('code');",
											"    pm.expect(typeof json.code, 'code should be a string').to.equal('string');",
											"",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(typeof json.message, 'message should be a string').to.equal('string');",
											"",
											"    if (json.status !== undefined) {",
											"      pm.expect(typeof json.status, 'status should be a string').to.equal('string');",
											"    }",
											"",
											"    if (status === 400) {",
											"      pm.expect(json.code, '400 error should include INVALID_JSON code when body is invalid').to.be.oneOf(['INVALID_JSON', json.code]);",
											"    }",
											"  });",
											"",
											"  console.log(`[Tests][${reqName}] Status:`, status);",
											"  console.log(`[Tests][${reqName}] Content-Type:`, contentType);",
											"  if (json) {",
											"    const sample = JSON.stringify(json).slice(0, 500);",
											"    console.log(`[Tests][${reqName}] Body sample (first 500 chars):`, sample);",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Successfully alice",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('Response has JSON content-type', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});",
											"",
											"let json;",
											"pm.test('Response body is valid JSON', function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an('object');",
											"});",
											"",
											"pm.test(\"Response body 'status' equals 'success'\", function () {",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Response body 'message' exists and includes 'Password changed'\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(String(json.message)).to.include('Password changed');",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass123!\",\r\n  \"new_password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Successfully bob",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('Response has JSON content-type', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});",
											"",
											"let json;",
											"pm.test('Response body is valid JSON', function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an('object');",
											"});",
											"",
											"pm.test(\"Response body 'status' equals 'success'\", function () {",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Response body 'message' exists and includes 'Password changed'\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(String(json.message)).to.include('Password changed');",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass123!\",\r\n  \"new_password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						},
						{
							"name": "Password - Successfully charlie",
							"event": [
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('Response has JSON content-type', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});",
											"",
											"let json;",
											"pm.test('Response body is valid JSON', function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an('object');",
											"});",
											"",
											"pm.test(\"Response body 'status' equals 'success'\", function () {",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Response body 'message' exists and includes 'Password changed'\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(String(json.message)).to.include('Password changed');",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": " application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{charlieAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"old_password\": \"SecurePass123!\",\r\n  \"new_password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/password",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"password"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Logout",
					"item": [
						{
							"name": "Logout - Invalid access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log(\"Logout Response Status:\", pm.response.code, pm.response.status);",
											"try { console.log(\"Logout Response Body:\", pm.response.text()); } catch (e) { console.log(\"No readable body\", e); }",
											"",
											"function tryParseJson(text) {",
											"    if (!text || text.trim() === \"\") return null;",
											"    try { return JSON.parse(text); } catch (e) { return null; }",
											"}",
											"",
											"const statusCode = pm.response.code;",
											"const bodyText = pm.response.text();",
											"const json = tryParseJson(bodyText);",
											"",
											"pm.test(\"Status is 200 or 204 for successful logout OR 401 for invalid token\", function () {",
											"    pm.expect([200, 204, 401]).to.include(statusCode);",
											"});",
											"",
											"if (statusCode === 200 || statusCode === 204) {",
											"    pm.test(\"Successful logout has {status:'success'} or empty body\", function () {",
											"        if (statusCode === 204 || bodyText.trim() === \"\") {",
											"            pm.expect(true).to.be.true;",
											"        } else {",
											"            pm.expect(json, \"Body must be valid JSON when present\").to.be.an(\"object\");",
											"            pm.expect(json.status, \"status should be 'success'\").to.eql(\"success\");",
											"        }",
											"    });",
											"} else if (statusCode === 401) {",
											"    pm.test(\"401 INVALID_TOKEN structure is present\", function () {",
											"        pm.expect(json, \"Body should be JSON for error\").to.be.an(\"object\");",
											"        pm.expect(json).to.have.property(\"code\");",
											"        pm.expect(json).to.have.property(\"message\");",
											"        pm.expect(json).to.have.property(\"status\");",
											"        pm.expect(json.code).to.eql(\"INVALID_TOKEN\");",
											"        pm.expect(json.status).to.be.oneOf([\"error\", \"fail\"]);",
											"    });",
											"}",
											"",
											"pm.test(\"Response has Content-Type header (when body present)\", function () {",
											"    if (bodyText && bodyText.trim() !== \"\") {",
											"        pm.response.to.have.header(\"Content-Type\");",
											"    } else {",
											"        pm.expect(true).to.be.true; // skip when no body",
											"    }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCG8.eyJleHAiOjE3NjQxODI2NTgsImlhdCI6MTc2NDE4MTc1OCwiaXNzIjoibm92YS1jaGF0LXNlcnZlciPzImxvZ2luIjoiY2hhcmxpZSIsInN1YiI6ImFjY2VzcyIsInR5cGUiOiJhY2Nlc3MiLCJ1c2VySUQiOiJhMGM0NTBiZC0wYzQwLTQwZTAtYWRlYi05NjBhYzEzZmQ4ZmQifQ.j6eKN2_aIwEpfQcTHzn4cM2s8L1VuksBAj46mUXupsA",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"{{aliceRefreshToken}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						},
						{
							"name": "Logout - No refresh token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Content-Type is application/json\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const contentType = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(contentType.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"console.log(\"Logout response body:\", pm.response.text());",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Response JSON includes required keys: code, message, status\", function () {",
											"    pm.expect(json).to.have.property(\"code\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"});",
											"",
											"pm.test(\"Missing refresh token returns HTTP 400\", function () {",
											"    pm.expect(pm.response.code).to.eql(400);",
											"});",
											"",
											"pm.test(\"Error code is MISSING_TOKEN and message mentions refresh token (case-insensitive)\", function () {",
											"    pm.expect(json.code).to.eql(\"MISSING_TOKEN\");",
											"    const msg = String(json.message || \"\").toLowerCase();",
											"    pm.expect(msg).to.include(\"refresh token\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						},
						{
							"name": "Logout - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log(\"[Login] HTTP Status:\", pm.response.code, pm.response.status);",
											"",
											"let isJson = true;",
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  isJson = false;",
											"}",
											"",
											"if (isJson) {",
											"  console.log(\"[Login] Payload status:\", json && json.status);",
											"  console.log(\"[Login] Payload code:\", json && json.code);",
											"  console.log(\"[Login] Payload message:\", json && json.message);",
											"} else {",
											"  console.log(\"[Login] Non-JSON response:\", pm.response.text());",
											"}",
											"",
											"pm.test(\"Status code is 404\", function () {",
											"  pm.expect(pm.response.code, \"Expected HTTP 404 but got \" + pm.response.code).to.eql(404);",
											"});",
											"",
											"pm.test(\"Response is valid JSON\", function () {",
											"  pm.expect(isJson, \"Response body is not valid JSON. Body: \" + pm.response.text()).to.be.true;",
											"});",
											"",
											"pm.test(\"JSON contains required top-level keys\", function () {",
											"  pm.expect(isJson, \"Cannot validate keys when response is not JSON\").to.be.true;",
											"  pm.expect(json).to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"code\");",
											"  pm.expect(json).to.have.property(\"message\");",
											"  pm.expect(json).to.have.property(\"status\");",
											"  // data is optional",
											"});",
											"",
											"pm.test(\"Successful login structure when status===success\", function () {",
											"  pm.expect(isJson, \"Response must be JSON for success checks\").to.be.true;",
											"  if (isJson && json.status === \"success\") {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"",
											"    pm.expect(json.data).to.have.property(\"token\");",
											"    pm.expect(json.data.token, \"Token should be a non-empty string\").to.be.a(\"string\").and.not.empty;",
											"",
											"    pm.expect(json.data).to.have.property(\"user\");",
											"    pm.expect(json.data.user).to.be.an(\"object\");",
											"    pm.expect(json.data.user).to.have.property(\"id\");",
											"    pm.expect(json.data.user.id, \"User id should be present\").to.exist;",
											"    pm.expect(json.data.user).to.have.property(\"email\");",
											"    pm.expect(json.data.user.email, \"User email should be a non-empty string\").to.be.a(\"string\").and.not.empty;",
											"  }",
											"});",
											"",
											"pm.test(\"Error response validation when status===error\", function () {",
											"  pm.expect(isJson, \"Response must be JSON for error checks\").to.be.true;",
											"  if (isJson && json.status === \"error\") {",
											"    pm.expect(json).to.have.property(\"code\");",
											"    pm.expect([\"INVALID_CREDENTIALS\", \"ENDPOINT_NOT_FOUND\", \"VALIDATION_ERROR\"],",
											"      \"Unexpected error code: \" + json.code).to.include(json.code);",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message, \"Error message should be non-empty\").to.be.a(\"string\").and.not.empty;",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"protocolProfileBehavior": {
								"disableBodyPruning": true
							},
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						},
						{
							"name": "Logout - Invalid json format",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"  const statusCode = pm.response.code;",
											"  const bodyText = pm.response.text();",
											"",
											"  let json;",
											"",
											"  pm.test('Response has valid JSON body', function () {",
											"    let isJson = false;",
											"    try {",
											"      json = bodyText ? JSON.parse(bodyText) : {};",
											"      isJson = true;",
											"    } catch (e) {",
											"      isJson = false;",
											"      console.log('Failed to parse JSON body:', e);",
											"    }",
											"    pm.expect(isJson, 'Body should be valid JSON').to.be.true;",
											"  });",
											"",
											"  if (typeof json === 'undefined') {",
											"    try { json = JSON.parse(bodyText || '{}'); } catch (e) { json = {}; }",
											"  }",
											"",
											"  console.log('[Logout] Status:', statusCode);",
											"  console.log('[Logout] Headers Content-Type:', contentType);",
											"  console.log('[Logout] Body (parsed):', json);",
											"",
											"  pm.test('Content-Type includes application/json', function () {",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  pm.test('Status is OK (200) or a handled client/server error (4xx/5xx)', function () {",
											"    pm.expect([",
											"      200, 201, 202, 204,",
											"      400, 401, 403, 404, 409, 422,",
											"      429,",
											"      500, 502, 503, 504",
											"    ]).to.include(statusCode);",
											"  });",
											"",
											"  if (statusCode === 200) {",
											"    pm.test(\"200 response should indicate success or include token fields\", function () {",
											"      const hasExplicitSuccess = json && (json.status === 'success' || json.success === true);",
											"      const hasTokenLikeFields = json && (",
											"        typeof json.token === 'string' ||",
											"        typeof json.accessToken === 'string' ||",
											"        (json.data && (typeof json.data.token === 'string' || typeof json.data.accessToken === 'string'))",
											"      );",
											"      pm.expect(hasExplicitSuccess || hasTokenLikeFields, 'Expected success status or token fields').to.be.true;",
											"    });",
											"  }",
											"",
											"  if (statusCode === 400) {",
											"    pm.test(\"400 INVALID_JSON should include an error message\", function () {",
											"      pm.expect(json).to.be.an('object');",
											"      if (json && json.code === 'INVALID_JSON') {",
											"        pm.expect(json.message, 'Error message should be present').to.be.a('string').and.not.be.empty;",
											"      } else {",
											"        pm.expect(json.message, 'Error message should be present for 400').to.be.a('string');",
											"      }",
											"    });",
											"  }",
											"",
											"  if (statusCode >= 500 && statusCode <= 599) {",
											"    pm.test('Server error should expose an error message', function () {",
											"      pm.expect(json).to.be.an('object');",
											"      pm.expect(json.message || json.error || json.detail, 'Some error detail should be provided').to.exist;",
											"    });",
											"  }",
											"",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"somelogin\",\r\n    \"password\": \"pass\"\r\n}\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						},
						{
							"name": "Logout - Empty json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function(){",
											"  const respText = pm.response.text();",
											"  let parsed = null;",
											"  let isJsonParsable = false;",
											"",
											"  pm.test(\"Response is JSON parseable\", function () {",
											"    try {",
											"      parsed = JSON.parse(respText);",
											"      isJsonParsable = true;",
											"    } catch (e) {",
											"      isJsonParsable = false;",
											"    }",
											"    pm.expect(isJsonParsable, \"Body was not valid JSON: \\n\" + respText).to.be.true;",
											"  });",
											"",
											"  if (!isJsonParsable) {",
											"    console.warn(\"Logout response is not JSON. Raw body:\", respText);",
											"    const fallback = { raw: respText, statusCode: pm.response.code, headers: pm.response.headers.toObject() };",
											"    return;",
											"  }",
											"",
											"  console.info(\"Logout response parsed JSON:\", parsed);",
											"  console.info(\"HTTP status:\", pm.response.code);",
											"",
											"  pm.test(\"Response has required keys: code, message, status\", function () {",
											"    pm.expect(parsed).to.be.an(\"object\");",
											"    [\"code\", \"message\", \"status\"].forEach(function(k){",
											"      pm.expect(parsed, \"Missing key '\" + k + \"' in response\").to.have.property(k);",
											"    });",
											"  });",
											"",
											"  pm.test(\"Error shape and HTTP code when status==='error'\", function () {",
											"    if (parsed && parsed.status === \"error\") {",
											"      pm.expect(pm.response.code, \"Expected HTTP 400 when status==='error'\").to.eql(400);",
											"      pm.expect(parsed.code, \"Expected code==='INVALID_JSON' for error case\").to.eql(\"INVALID_JSON\");",
											"    } else {",
											"      pm.expect(true, \"status is not 'error'; skipping error-specific assertions\").to.be.true;",
											"    }",
											"  });",
											"",
											"  pm.test(\"Types: code/message/status are strings\", function(){",
											"    pm.expect(typeof parsed.code).to.eql(\"string\");",
											"    pm.expect(typeof parsed.message).to.eql(\"string\");",
											"    pm.expect(typeof parsed.status).to.eql(\"string\");",
											"  });",
											"",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						},
						{
							"name": "Logout - Successfully alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function tryParseJSON(text) {",
											"    try { return JSON.parse(text); } catch (e) { return null; }",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const rawBody = pm.response.text();",
											"const json = tryParseJSON(rawBody);",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    pm.expect(json, \"Response should be JSON\").to.not.equal(null);",
											"});",
											"",
											"pm.test(\"Response has expected message and status\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message).to.eql(\"Successfully logged out\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Request header Content-Type is application/json\", function () {",
											"    const ct = pm.request.headers.get(\"Content-Type\");",
											"    pm.expect(ct, \"Content-Type header should be present\").to.exist;",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"pm.test(\"Authorization header present with Bearer token\", function () {",
											"    const auth = pm.request.headers.get(\"Authorization\");",
											"    pm.expect(auth, \"Authorization header should be present\").to.exist;",
											"});",
											"",
											"pm.test(\"Request body includes non-empty refresh_token\", function () {",
											"    let sentBody = pm.request.body && pm.request.body.mode === 'raw' ? pm.request.body.raw : null;",
											"    if (typeof sentBody === 'string') {",
											"        try {",
											"            const resolved = sentBody.replace(/{{\\s*([\\w.-]+)\\s*}}/g, function(_, v){",
											"                const val = pm.variables.get(v);",
											"                return (val !== undefined && val !== null) ? JSON.stringify(val).slice(1,-1) : \"\";",
											"            });",
											"            const bodyJson = JSON.parse(resolved);",
											"            pm.expect(bodyJson).to.have.property('refresh_token');",
											"            pm.expect(String(bodyJson.refresh_token)).to.have.length.greaterThan(0);",
											"        } catch (e) {",
											"            const token = pm.variables.get('aliceRefreshToken') || pm.environment.get('aliceRefreshToken') || pm.collectionVariables.get('aliceRefreshToken');",
											"            pm.expect(token, \"Could not parse body; using variable fallback\").to.exist;",
											"            pm.expect(String(token)).to.have.length.greaterThan(0);",
											"        }",
											"    } else {",
											"        pm.expect.fail(\"Request body missing or not in raw mode\");",
											"    }",
											"});",
											"",
											"pm.test('Clear stored auth tokens', function () {",
											"  if (pm.response.code === 200) {",
											"    if (pm.environment.get('aliceAccessToken')) pm.environment.unset('aliceAccessToken');",
											"    if (pm.environment.get('aliceRefreshToken')) pm.environment.unset('aliceRefreshToken');",
											"",
											"    pm.collectionVariables.unset('aliceAccessToken');",
											"    pm.collectionVariables.unset('aliceRefreshToken');",
											"    ",
											"    pm.globals.unset('aliceAccessToken');",
											"    pm.globals.unset('aliceRefreshToken');",
											"",
											"    pm.expect(pm.environment.get('aliceAccessToken')).to.be.undefined;",
											"    pm.expect(pm.environment.get('aliceRefreshToken')).to.be.undefined;",
											"  } else {",
											"    pm.expect.fail('Skipping token clear because logout did not return 200');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"{{aliceRefreshToken}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						},
						{
							"name": "Logout - Successfully bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function tryParseJSON(text) {",
											"    try { return JSON.parse(text); } catch (e) { return null; }",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const rawBody = pm.response.text();",
											"const json = tryParseJSON(rawBody);",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    pm.expect(json, \"Response should be JSON\").to.not.equal(null);",
											"});",
											"",
											"pm.test(\"Response has expected message and status\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message).to.eql(\"Successfully logged out\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Request header Content-Type is application/json\", function () {",
											"    const ct = pm.request.headers.get(\"Content-Type\");",
											"    pm.expect(ct, \"Content-Type header should be present\").to.exist;",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"pm.test(\"Authorization header present with Bearer token\", function () {",
											"    const auth = pm.request.headers.get(\"Authorization\");",
											"    pm.expect(auth, \"Authorization header should be present\").to.exist;",
											"});",
											"",
											"pm.test(\"Request body includes non-empty refresh_token\", function () {",
											"    let sentBody = pm.request.body && pm.request.body.mode === 'raw' ? pm.request.body.raw : null;",
											"    if (typeof sentBody === 'string') {",
											"        try {",
											"            const resolved = sentBody.replace(/{{\\s*([\\w.-]+)\\s*}}/g, function(_, v){",
											"                const val = pm.variables.get(v);",
											"                return (val !== undefined && val !== null) ? JSON.stringify(val).slice(1,-1) : \"\";",
											"            });",
											"            const bodyJson = JSON.parse(resolved);",
											"            pm.expect(bodyJson).to.have.property('refresh_token');",
											"            pm.expect(String(bodyJson.refresh_token)).to.have.length.greaterThan(0);",
											"        } catch (e) {",
											"            const token = pm.variables.get('bobRefreshToken') || pm.environment.get('bobRefreshToken') || pm.collectionVariables.get('bobRefreshToken');",
											"            pm.expect(token, \"Could not parse body; using variable fallback\").to.exist;",
											"            pm.expect(String(token)).to.have.length.greaterThan(0);",
											"        }",
											"    } else {",
											"        pm.expect.fail(\"Request body missing or not in raw mode\");",
											"    }",
											"});",
											"",
											"pm.test('Clear stored auth tokens', function () {",
											"  if (pm.response.code === 200) {",
											"    if (pm.environment.get('bobAccessToken')) pm.environment.unset('bobAccessToken');",
											"    if (pm.environment.get('bobRefreshToken')) pm.environment.unset('bobRefreshToken');",
											"",
											"    pm.collectionVariables.unset('bobAccessToken');",
											"    pm.collectionVariables.unset('bobRefreshToken');",
											"    ",
											"    pm.globals.unset('bobAccessToken');",
											"    pm.globals.unset('bobRefreshToken');",
											"",
											"    pm.expect(pm.environment.get('bobAccessToken')).to.be.undefined;",
											"    pm.expect(pm.environment.get('bobRefreshToken')).to.be.undefined;",
											"  } else {",
											"    pm.expect.fail('Skipping token clear because logout did not return 200');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"{{bobRefreshToken}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						},
						{
							"name": "Logout - Successfully charlie",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function tryParseJSON(text) {",
											"    try { return JSON.parse(text); } catch (e) { return null; }",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"const rawBody = pm.response.text();",
											"const json = tryParseJSON(rawBody);",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    pm.expect(json, \"Response should be JSON\").to.not.equal(null);",
											"});",
											"",
											"pm.test(\"Response has expected message and status\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message).to.eql(\"Successfully logged out\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Request header Content-Type is application/json\", function () {",
											"    const ct = pm.request.headers.get(\"Content-Type\");",
											"    pm.expect(ct, \"Content-Type header should be present\").to.exist;",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"pm.test(\"Authorization header present with Bearer token\", function () {",
											"    const auth = pm.request.headers.get(\"Authorization\");",
											"    pm.expect(auth, \"Authorization header should be present\").to.exist;",
											"});",
											"",
											"pm.test(\"Request body includes non-empty refresh_token\", function () {",
											"    let sentBody = pm.request.body && pm.request.body.mode === 'raw' ? pm.request.body.raw : null;",
											"    if (typeof sentBody === 'string') {",
											"        try {",
											"            const resolved = sentBody.replace(/{{\\s*([\\w.-]+)\\s*}}/g, function(_, v){",
											"                const val = pm.variables.get(v);",
											"                return (val !== undefined && val !== null) ? JSON.stringify(val).slice(1,-1) : \"\";",
											"            });",
											"            const bodyJson = JSON.parse(resolved);",
											"            pm.expect(bodyJson).to.have.property('refresh_token');",
											"            pm.expect(String(bodyJson.refresh_token)).to.have.length.greaterThan(0);",
											"        } catch (e) {",
											"            const token = pm.variables.get('charlieRefreshToken') || pm.environment.get('charlieRefreshToken') || pm.collectionVariables.get('charlieRefreshToken');",
											"            pm.expect(token, \"Could not parse body; using variable fallback\").to.exist;",
											"            pm.expect(String(token)).to.have.length.greaterThan(0);",
											"        }",
											"    } else {",
											"        pm.expect.fail(\"Request body missing or not in raw mode\");",
											"    }",
											"});",
											"",
											"pm.test('Clear stored auth tokens', function () {",
											"  if (pm.response.code === 200) {",
											"    if (pm.environment.get('charlieAccessToken')) pm.environment.unset('charlieAccessToken');",
											"    if (pm.environment.get('charlieRefreshToken')) pm.environment.unset('charlieRefreshToken');",
											"",
											"    pm.collectionVariables.unset('charlieAccessToken');",
											"    pm.collectionVariables.unset('charlieRefreshToken');",
											"    ",
											"    pm.globals.unset('charlieAccessToken');",
											"    pm.globals.unset('charlieRefreshToken');",
											"",
											"    pm.expect(pm.environment.get('charlieAccessToken')).to.be.undefined;",
											"    pm.expect(pm.environment.get('charlieRefreshToken')).to.be.undefined;",
											"  } else {",
											"    pm.expect.fail('Skipping token clear because logout did not return 200');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{charlieAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"refresh_token\": \"[[charlieRefreshToken}}\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/logout",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"logout"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Delete account",
					"item": [
						{
							"name": "Login alice TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"aliceAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"aliceRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"aliceAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"aliceRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    // If JSON, expect standard error shape; otherwise at least a message",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login bob TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"bobAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"bobRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"bobAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"bobRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"bob\",\r\n    \"password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login charlie TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"charlieAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"charlieRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"charlieAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"charlieRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"charlie\",\r\n    \"password\": \"NewSecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete account - Invalid access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('Request:', pm.request.method, pm.request.url.toString());",
											"console.log('Status:', pm.response.code, pm.response.status);",
											"console.log('Response headers:', pm.response.headers.all());",
											"console.log('Raw body:', pm.response.text());",
											"",
											"pm.test('Status code is expected', function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([200, 204, 401, 403, 404]);",
											"});",
											"",
											"function safeJson() {",
											"    try { return pm.response.json(); } catch (e) { return null; }",
											"}",
											"",
											"var json = safeJson();",
											"",
											"pm.test('Success response validity (200/204)', function () {",
											"    if (pm.response.code === 200) {",
											"        pm.expect(json, 'JSON body should be present for 200').to.be.an('object');",
											"        if (json) {",
											"            const indicators = [",
											"                json.success === true,",
											"                /success/i.test(JSON.stringify(json) || '')",
											"            ];",
											"            pm.expect(indicators.some(Boolean), 'Body should indicate success').to.be.true;",
											"        }",
											"    } else if (pm.response.code === 204) {",
											"        pm.response.to.have.status(204);",
											"        pm.expect(pm.response.text(), '204 should not have a body').to.satisfy(t => t === '' || t === undefined);",
											"    }",
											"});",
											"",
											"pm.test('Unauthorized response validity (401)', function () {",
											"    if (pm.response.code === 401) {",
											"        pm.expect(json, 'JSON body expected for 401').to.be.an('object');",
											"        if (json) {",
											"            pm.expect(json.code, 'code').to.eql('INVALID_TOKEN');",
											"            pm.expect(String(json.message || ''), 'message contains \"Invalid access token\"').to.match(/Invalid access token/i);",
											"        }",
											"    }",
											"});",
											"",
											"pm.test('Forbidden response validity (403)', function () {",
											"    if (pm.response.code === 403) {",
											"        if (json && typeof json === 'object' && 'code' in json) {",
											"            pm.expect(json.code, 'code').to.eql('FORBIDDEN');",
											"        } else {",
											"            pm.expect(String(pm.response.status || ''), 'status text mentions forbidden').to.match(/forbidden/i);",
											"        }",
											"    }",
											"});",
											"",
											"pm.test('Not Found response validity (404)', function () {",
											"    if (pm.response.code === 404) {",
											"        if (json && typeof json === 'object' && 'code' in json) {",
											"            pm.expect(json.code, 'code').to.eql('NOT_FOUND');",
											"        } else {",
											"            const msg = (json && json.message) ? String(json.message) : pm.response.text();",
											"            pm.expect(String(msg || ''), 'message mentions not found').to.match(/not\\s*found/i);",
											"        }",
											"    }",
											"});",
											"",
											"pm.test('Test summary', function () {",
											"    const summary = {",
											"        method: pm.request.method,",
											"        url: pm.request.url.toString(),",
											"        status: pm.response.code,",
											"        statusText: pm.response.status,",
											"        savedBearerToken: pm.environment.get('lastBearerToken') ? true : false",
											"    };",
											"    console.log('Test Summary:', summary);",
											"    pm.expect(summary.status).to.be.oneOf([200, 204, 401, 403, 404]);",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUzI1NiIsInT6cCI6IkpXVCJ9.eyJleHAiOjE3NjQxODgyNjksImlhdCI6MTc2NDE4NzM2OSwiaXNzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiY2hhcmxpZSIsInN1YiI6ImFjY2VzcyIsInR5cGUiOiJhY2Nlc3MiLCJ1c2VySUQiOiIyZDhhZmY2Mi00NzJmLTRmZTgtYmMzMi1mYzk4NjQ0N2FiMjYifQ.PXU-8eMCk7s19m_lp4-OX1MhRzXqrqvECdsr_7tWBW1",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/account",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"account"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete account - Empty access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const status = pm.response.code;",
											"  const statusText = pm.response.status;",
											"  const hasBody = pm.response.text() && pm.response.text().trim().length > 0;",
											"",
											"  let json = null;",
											"  if (hasBody) {",
											"    try {",
											"      json = pm.response.json();",
											"    } catch (e) {",
											"      // Non-JSON body",
											"      json = null;",
											"    }",
											"  }",
											"",
											"  if (status === 401) {",
											"    pm.test(\"401 Invalid token: status code is 401\", function () {",
											"      pm.expect(status).to.eql(401);",
											"    });",
											"",
											"    pm.test(\"401 Invalid token: body has code 'INVALID_TOKEN'\", function () {",
											"      pm.expect(json, \"Expected a JSON body for 401 response\").to.be.an(\"object\");",
											"      pm.expect(json.code).to.eql(\"INVALID_TOKEN\");",
											"    });",
											"",
											"    pm.test(\"401 Invalid token: message states 'Access token is required'\", function () {",
											"      pm.expect(json.message).to.eql(\"Access token is required\");",
											"    });",
											"  }",
											"",
											"  if (status >= 200 && status < 300) {",
											"    pm.test(\"Success: status is in 2xx range\", function () {",
											"      pm.expect(status).to.be.within(200, 299);",
											"    });",
											"",
											"    if (status === 204) {",
											"      pm.test(\"204 No Content: no body present\", function () {",
											"        pm.expect(hasBody).to.be.false;",
											"      });",
											"    } else {",
											"      pm.test(\"Success: JSON body has status 'success' when body is present\", function () {",
											"        pm.expect(json, \"Expected JSON body for successful response\").to.be.an(\"object\");",
											"        pm.expect(json.status, \"Response 'status' field\").to.eql(\"success\");",
											"      });",
											"    }",
											"  }",
											"",
											"  if (hasBody && json !== null) {",
											"    pm.test(\"Headers: Content-Type includes 'application/json' for JSON body\", function () {",
											"      pm.response.to.have.header(\"Content-Type\");",
											"      const ctype = pm.response.headers.get(\"Content-Type\") || \"\";",
											"      pm.expect(ctype.toLowerCase()).to.include(\"application/json\");",
											"    });",
											"  } else {",
											"    console.log(\"No JSON body detected; skipping Content-Type JSON assertion\");",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/account",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"account"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete account - No access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function(){",
											"  const code = pm.response.code;",
											"  const bodyText = pm.response.text();",
											"  let json = null;",
											"  try { json = pm.response.json(); } catch (e) { /* non-JSON or empty body */ }",
											"",
											"  pm.test(\"401 Unauthorized includes INVALID_TOKEN and message mentions token/access\", function () {",
											"    if (code === 401) {",
											"      pm.response.to.have.status(401);",
											"      const text = (json ? JSON.stringify(json) : bodyText) || \"\";",
											"      pm.expect(text).to.include(\"INVALID_TOKEN\");",
											"      pm.expect(text.toLowerCase()).to.satisfy(t => t.includes(\"token\") || t.includes(\"access\"));",
											"    } else {",
											"      pm.expect(true).to.be.true;",
											"    }",
											"  });",
											"",
											"  pm.test(\"Successful deletion returns 204 or 200 and optional status==success\", function () {",
											"    if (code === 204 || code === 200) {",
											"      pm.expect(code).to.be.oneOf([200, 204]);",
											"      if (json && typeof json === 'object' && 'status' in json) {",
											"        pm.expect((json.status + '').toLowerCase()).to.eql('success');",
											"      } else {",
											"        // No JSON body or no status field: that's fine, especially for 204",
											"        pm.expect(true).to.be.true;",
											"      }",
											"    } else {",
											"      // If not success codes, don't fail this test",
											"      pm.expect(true).to.be.true;",
											"    }",
											"  });",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [],
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/account",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"account"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete account - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let isJson = true;",
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  isJson = false;",
											"}",
											"",
											"if (isJson) {",
											"  console.log(\"[Login] Payload status:\", json && json.status);",
											"  console.log(\"[Login] Payload code:\", json && json.code);",
											"  console.log(\"[Login] Payload message:\", json && json.message);",
											"} else {",
											"  console.log(\"[Login] Non-JSON response:\", pm.response.text());",
											"}",
											"",
											"pm.test(\"Status code is 404\", function () {",
											"  pm.expect(pm.response.code, \"Expected HTTP 404 but got \" + pm.response.code).to.eql(404);",
											"});",
											"",
											"pm.test(\"Response is valid JSON\", function () {",
											"  pm.expect(isJson, \"Response body is not valid JSON. Body: \" + pm.response.text()).to.be.true;",
											"});",
											"",
											"pm.test(\"JSON contains required top-level keys\", function () {",
											"  pm.expect(isJson, \"Cannot validate keys when response is not JSON\").to.be.true;",
											"  pm.expect(json).to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"code\");",
											"  pm.expect(json).to.have.property(\"message\");",
											"  pm.expect(json).to.have.property(\"status\");",
											"  // data is optional",
											"});",
											"",
											"pm.test(\"Successful login structure when status===success\", function () {",
											"  pm.expect(isJson, \"Response must be JSON for success checks\").to.be.true;",
											"  if (isJson && json.status === \"success\") {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"",
											"    pm.expect(json.data).to.have.property(\"token\");",
											"    pm.expect(json.data.token, \"Token should be a non-empty string\").to.be.a(\"string\").and.not.empty;",
											"",
											"    pm.expect(json.data).to.have.property(\"user\");",
											"    pm.expect(json.data.user).to.be.an(\"object\");",
											"    pm.expect(json.data.user).to.have.property(\"id\");",
											"    pm.expect(json.data.user.id, \"User id should be present\").to.exist;",
											"    pm.expect(json.data.user).to.have.property(\"email\");",
											"    pm.expect(json.data.user.email, \"User email should be a non-empty string\").to.be.a(\"string\").and.not.empty;",
											"  }",
											"});",
											"",
											"pm.test(\"Error response validation when status===error\", function () {",
											"  pm.expect(isJson, \"Response must be JSON for error checks\").to.be.true;",
											"  if (isJson && json.status === \"error\") {",
											"    pm.expect(json).to.have.property(\"code\");",
											"    pm.expect([\"INVALID_CREDENTIALS\", \"ENDPOINT_NOT_FOUND\", \"VALIDATION_ERROR\"],",
											"      \"Unexpected error code: \" + json.code).to.include(json.code);",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message, \"Error message should be non-empty\").to.be.a(\"string\").and.not.empty;",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/account",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"account"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete account - Successfully alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response Content-Type is JSON\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Body has expected message and status\", function () {",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message).to.eql(\"Account deleted successfully\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Request has Authorization header with Bearer token\", function () {",
											"    const authHeader = pm.request.headers.get(\"Authorization\");",
											"    pm.expect(authHeader, \"Authorization header should be present on request\").to.be.a(\"string\");",
											"});",
											"",
											"pm.test('Clear stored auth tokens', function () {",
											"  if (pm.response.code === 200) {",
											"    if (pm.environment.get('aliceAccessToken')) pm.environment.unset('aliceAccessToken');",
											"    if (pm.environment.get('aliceRefreshToken')) pm.environment.unset('aliceRefreshToken');",
											"",
											"    pm.collectionVariables.unset('aliceAccessToken');",
											"    pm.collectionVariables.unset('aliceRefreshToken');",
											"    ",
											"    pm.globals.unset('aliceAccessToken');",
											"    pm.globals.unset('aliceRefreshToken');",
											"",
											"    pm.expect(pm.environment.get('aliceAccessToken')).to.be.undefined;",
											"    pm.expect(pm.environment.get('aliceRefreshToken')).to.be.undefined;",
											"  } else {",
											"    pm.expect.fail('Skipping token clear because logout did not return 200');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/account",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"account"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete account - Successfully bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response Content-Type is JSON\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Body has expected message and status\", function () {",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message).to.eql(\"Account deleted successfully\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Request has Authorization header with Bearer token\", function () {",
											"    const authHeader = pm.request.headers.get(\"Authorization\");",
											"    pm.expect(authHeader, \"Authorization header should be present on request\").to.be.a(\"string\");",
											"});",
											"",
											"pm.test('Clear stored auth tokens', function () {",
											"  if (pm.response.code === 200) {",
											"    if (pm.environment.get('bobAccessToken')) pm.environment.unset('bobAccessToken');",
											"    if (pm.environment.get('bobRefreshToken')) pm.environment.unset('bobRefreshToken');",
											"",
											"    pm.collectionVariables.unset('bobAccessToken');",
											"    pm.collectionVariables.unset('bobRefreshToken');",
											"    ",
											"    pm.globals.unset('bobAccessToken');",
											"    pm.globals.unset('bobRefreshToken');",
											"",
											"    pm.expect(pm.environment.get('bobAccessToken')).to.be.undefined;",
											"    pm.expect(pm.environment.get('bobRefreshToken')).to.be.undefined;",
											"  } else {",
											"    pm.expect.fail('Skipping token clear because logout did not return 200');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/account",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"account"
									]
								}
							},
							"response": []
						},
						{
							"name": "Delete account - Successfully charlie",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response Content-Type is JSON\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Body has expected message and status\", function () {",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json.message).to.eql(\"Account deleted successfully\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Request has Authorization header with Bearer token\", function () {",
											"    const authHeader = pm.request.headers.get(\"Authorization\");",
											"    pm.expect(authHeader, \"Authorization header should be present on request\").to.be.a(\"string\");",
											"});",
											"",
											"pm.test('Clear stored auth tokens', function () {",
											"  if (pm.response.code === 200) {",
											"    if (pm.environment.get('charlieAccessToken')) pm.environment.unset('charlieAccessToken');",
											"    if (pm.environment.get('charlieRefreshToken')) pm.environment.unset('charlieRefreshToken');",
											"",
											"    pm.collectionVariables.unset('charlieAccessToken');",
											"    pm.collectionVariables.unset('charlieRefreshToken');",
											"    ",
											"    pm.globals.unset('charlieAccessToken');",
											"    pm.globals.unset('charlieRefreshToken');",
											"",
											"    pm.expect(pm.environment.get('charlieAccessToken')).to.be.undefined;",
											"    pm.expect(pm.environment.get('charlieRefreshToken')).to.be.undefined;",
											"  } else {",
											"    pm.expect.fail('Skipping token clear because logout did not return 200');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "DELETE",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{charlieAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/account",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"account"
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Users",
			"item": [
				{
					"name": "Get users",
					"item": [
						{
							"name": "Register alice TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('[Register] Status Code:', pm.response.code);",
											"console.log('[Register] Headers:', pm.response.headers.all());",
											"console.log('[Register] Raw Body:', pm.response.text());",
											"",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse JSON:', e);",
											"}",
											"",
											"let requestLogin = null;",
											"try {",
											"    const reqBodyRaw = pm.request.body && pm.request.body.raw ? pm.request.body.raw : '';",
											"    console.log('[Register] Request Raw Body:', reqBodyRaw);",
											"    if (reqBodyRaw) {",
											"        const reqJson = JSON.parse(reqBodyRaw);",
											"        requestLogin = reqJson && reqJson.login ? reqJson.login : null;",
											"    }",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse request body JSON:', e);",
											"}",
											"",
											"pm.test('Register: response status code is 201', function () {",
											"    pm.expect(pm.response.code).to.eql(201);",
											"});",
											"",
											"pm.test(\"Register: response JSON has status == 'success'\", function () {",
											"    pm.expect(json).to.be.an('object');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Register: message contains 'registered' (case-insensitive)\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    const msg = String(json.message || '');",
											"    pm.expect(msg.toLowerCase()).to.include('registered');",
											"});",
											"",
											"pm.test('Register: data.login equals the request body login', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.be.an('object');",
											"    if (requestLogin !== null) {",
											"        pm.expect(json.data.login).to.eql(requestLogin);",
											"    } else {",
											"        pm.expect(json.data).to.have.property('login');",
											"        pm.expect(json.data.login).to.be.a('string');",
											"    }",
											"});",
											"",
											"pm.test('Register: data.user_id exists and is a valid UUID v4', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.have.property('user_id');",
											"    const uuid = String(json.data.user_id || '');",
											"    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    pm.expect(uuid).to.match(uuidV4Regex);",
											"});",
											"",
											"pm.test(\"Register: 'Content-Type' header includes 'application/json'\", function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register bob TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('[Register] Status Code:', pm.response.code);",
											"console.log('[Register] Headers:', pm.response.headers.all());",
											"console.log('[Register] Raw Body:', pm.response.text());",
											"",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse JSON:', e);",
											"}",
											"",
											"let requestLogin = null;",
											"try {",
											"    const reqBodyRaw = pm.request.body && pm.request.body.raw ? pm.request.body.raw : '';",
											"    console.log('[Register] Request Raw Body:', reqBodyRaw);",
											"    if (reqBodyRaw) {",
											"        const reqJson = JSON.parse(reqBodyRaw);",
											"        requestLogin = reqJson && reqJson.login ? reqJson.login : null;",
											"    }",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse request body JSON:', e);",
											"}",
											"",
											"pm.test('Register: response status code is 201', function () {",
											"    pm.expect(pm.response.code).to.eql(201);",
											"});",
											"",
											"pm.test(\"Register: response JSON has status == 'success'\", function () {",
											"    pm.expect(json).to.be.an('object');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Register: message contains 'registered' (case-insensitive)\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    const msg = String(json.message || '');",
											"    pm.expect(msg.toLowerCase()).to.include('registered');",
											"});",
											"",
											"pm.test('Register: data.login equals the request body login', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.be.an('object');",
											"    if (requestLogin !== null) {",
											"        pm.expect(json.data.login).to.eql(requestLogin);",
											"    } else {",
											"        pm.expect(json.data).to.have.property('login');",
											"        pm.expect(json.data.login).to.be.a('string');",
											"    }",
											"});",
											"",
											"pm.test('Register: data.user_id exists and is a valid UUID v4', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.have.property('user_id');",
											"    const uuid = String(json.data.user_id || '');",
											"    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    pm.expect(uuid).to.match(uuidV4Regex);",
											"});",
											"",
											"pm.test(\"Register: 'Content-Type' header includes 'application/json'\", function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"bob\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Register charlie TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('[Register] Status Code:', pm.response.code);",
											"console.log('[Register] Headers:', pm.response.headers.all());",
											"console.log('[Register] Raw Body:', pm.response.text());",
											"",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse JSON:', e);",
											"}",
											"",
											"let requestLogin = null;",
											"try {",
											"    const reqBodyRaw = pm.request.body && pm.request.body.raw ? pm.request.body.raw : '';",
											"    console.log('[Register] Request Raw Body:', reqBodyRaw);",
											"    if (reqBodyRaw) {",
											"        const reqJson = JSON.parse(reqBodyRaw);",
											"        requestLogin = reqJson && reqJson.login ? reqJson.login : null;",
											"    }",
											"} catch (e) {",
											"    console.error('[Register] Failed to parse request body JSON:', e);",
											"}",
											"",
											"pm.test('Register: response status code is 201', function () {",
											"    pm.expect(pm.response.code).to.eql(201);",
											"});",
											"",
											"pm.test(\"Register: response JSON has status == 'success'\", function () {",
											"    pm.expect(json).to.be.an('object');",
											"    pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test(\"Register: message contains 'registered' (case-insensitive)\", function () {",
											"    pm.expect(json).to.have.property('message');",
											"    const msg = String(json.message || '');",
											"    pm.expect(msg.toLowerCase()).to.include('registered');",
											"});",
											"",
											"pm.test('Register: data.login equals the request body login', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.be.an('object');",
											"    if (requestLogin !== null) {",
											"        pm.expect(json.data.login).to.eql(requestLogin);",
											"    } else {",
											"        pm.expect(json.data).to.have.property('login');",
											"        pm.expect(json.data.login).to.be.a('string');",
											"    }",
											"});",
											"",
											"pm.test('Register: data.user_id exists and is a valid UUID v4', function () {",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.have.property('user_id');",
											"    const uuid = String(json.data.user_id || '');",
											"    const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    pm.expect(uuid).to.match(uuidV4Regex);",
											"});",
											"",
											"pm.test(\"Register: 'Content-Type' header includes 'application/json'\", function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    const ct = pm.response.headers.get('Content-Type') || '';",
											"    pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"charlie\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/register",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"register"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login alice TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"aliceAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"aliceRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"aliceAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"aliceRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"alice\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login bob TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"bobAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"bobRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"bobAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"bobRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"bob\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								}
							},
							"response": []
						},
						{
							"name": "Login charlie TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200 or 201\", function () {",
											"  pm.expect(pm.response.code).to.be.oneOf([200, 201]);",
											"});",
											"",
											"pm.test(\"Content-Type is JSON\", function () {",
											"  pm.response.to.have.header(\"Content-Type\");",
											"  const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"  pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  pm.expect(bodyIsJson, \"Response is not valid JSON\").to.be.true;",
											"});",
											"",
											"if (bodyIsJson && json) {",
											"  pm.test(\"Top-level keys present\", function () {",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json).to.have.property(\"message\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"  });",
											"",
											"  pm.test(\"status and message types\", function () {",
											"    pm.expect(json.status).to.be.a(\"string\");",
											"    pm.expect(json.message).to.be.a(\"string\");",
											"  });",
											"",
											"  pm.test(\"status indicates success\", function () {",
											"    pm.expect([\"success\", \"ok\"]).to.include(String(json.status).toLowerCase());",
											"  });",
											"",
											"  pm.test(\"data object has expected auth fields\", function () {",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"access_token\");",
											"    pm.expect(json.data).to.have.property(\"refresh_token\");",
											"    pm.expect(json.data).to.have.property(\"expires_in\");",
											"    pm.expect(json.data).to.have.property(\"token_type\");",
											"    pm.expect(json.data).to.have.property(\"user_id\");",
											"    pm.expect(json.data).to.have.property(\"login\");",
											"  });",
											"",
											"  pm.test(\"Field types and basic semantics\", function () {",
											"    const d = json.data;",
											"    pm.expect(d.access_token, \"access_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.refresh_token, \"refresh_token\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.token_type, \"token_type\").to.be.a(\"string\").and.match(/^Bearer$/i);",
											"    pm.expect(d.user_id, \"user_id\").to.be.a(\"string\").and.have.length.greaterThan(10);",
											"    pm.expect(d.login, \"login\").to.be.a(\"string\").and.not.empty;",
											"    pm.expect(d.expires_in, \"expires_in\").to.satisfy(v => Number.isInteger(v) && v > 0, \"expires_in should be a positive integer\");",
											"  });",
											"",
											"  pm.test(\"Login in response matches request body\", function () {",
											"    let reqBody;",
											"    try { reqBody = JSON.parse(pm.request.body.raw || \"{}\"); } catch (e) { reqBody = {}; }",
											"    if (reqBody && reqBody.login) {",
											"      pm.expect(String(json.data.login)).to.eql(String(reqBody.login));",
											"    } else {",
											"      pm.expect(json.data.login).to.be.a(\"string\");",
											"    }",
											"  });",
											"",
											"  pm.test(\"Tokens look like JWTs (header.payload.signature)\", function () {",
											"    const looksJwt = (t) => typeof t === \"string\" && t.split(\".\").length === 3;",
											"    pm.expect(looksJwt(json.data.access_token), \"access_token is not a JWT-like token\").to.be.true;",
											"    pm.expect(looksJwt(json.data.refresh_token), \"refresh_token is not a JWT-like token\").to.be.true;",
											"  });",
											"",
											"  pm.test(\"Store auth tokens as variables\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"charlieAccessToken\", d.access_token);",
											"    pm.collectionVariables.set(\"charlieRefreshToken\", d.refresh_token);",
											"",
											"    pm.expect(pm.collectionVariables.get(\"charlieAccessToken\")).to.be.a(\"string\").and.not.empty;",
											"    pm.expect(pm.collectionVariables.get(\"charlieRefreshToken\")).to.be.a(\"string\").and.not.empty;",
											"  });",
											"",
											"  pm.test(\"expires_in is reasonable (<= 24h)\", function () {",
											"    const MAX = 24 * 60 * 60; // 24 hours in seconds",
											"    pm.expect(json.data.expires_in).to.be.at.most(MAX);",
											"  });",
											"}",
											"",
											"if (![200,201].includes(pm.response.code)) {",
											"  pm.test(\"Non-success response has error details\", function () {",
											"    if (bodyIsJson && json) {",
											"      pm.expect(json).to.have.any.keys(\"error\", \"message\", \"status\");",
											"    } else {",
											"      pm.expect(pm.response.text().length).to.be.greaterThan(0);",
											"    }",
											"  });",
											"}",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n    \"login\": \"charlie\",\r\n    \"password\": \"SecurePass123!\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/auth/login",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"auth",
										"login"
									]
								},
								"description": "TEMP login request before delete account"
							},
							"response": []
						},
						{
							"name": "Get users - Invalid param page",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Top-level status is success\", function () {",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Response has data with pagination and users\", function () {",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");",
											"});",
											"",
											"pm.test(\"Validate pagination fields and types\", function () {",
											"  const p = json.data.pagination;",
											"  pm.expect(p).to.have.property(\"has_next\");",
											"  pm.expect(p).to.have.property(\"has_prev\");",
											"  pm.expect(p).to.have.property(\"limit\");",
											"  pm.expect(p).to.have.property(\"page\");",
											"  pm.expect(p).to.have.property(\"total_count\");",
											"  pm.expect(p).to.have.property(\"total_pages\");",
											"",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");",
											"});",
											"",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"pm.test(\"Users array and each user object shape\", function () {",
											"  const users = json.data.users;",
											"  pm.expect(users).to.be.an(\"array\");",
											"",
											"  users.forEach((u, idx) => {",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"    pm.expect(u).to.have.property(\"login\");",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");",
											"    pm.expect(u).to.have.property(\"user_id\");",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);",
											"  });",
											"});",
											"",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {",
											"  const reqUrl = pm.request.url.toString();",
											"  pm.expect(reqUrl).to.include(\"page=aaa\");",
											"",
											"  pm.response.to.have.status(200);",
											"  const p = json.data && json.data.pagination;",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=aaa&limit=50&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "aaa"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Empty param page",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {\r",
											"  pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"let json;\r",
											"pm.test(\"Response is valid JSON\", function () {\r",
											"  json = pm.response.json();\r",
											"  pm.expect(json).to.be.an(\"object\");\r",
											"});\r",
											"\r",
											"pm.test(\"Top-level status is success\", function () {\r",
											"  pm.expect(json).to.have.property(\"status\");\r",
											"  pm.expect(json.status).to.eql(\"success\");\r",
											"});\r",
											"\r",
											"pm.test(\"Response has data with pagination and users\", function () {\r",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate pagination fields and types\", function () {\r",
											"  const p = json.data.pagination;\r",
											"  pm.expect(p).to.have.property(\"has_next\");\r",
											"  pm.expect(p).to.have.property(\"has_prev\");\r",
											"  pm.expect(p).to.have.property(\"limit\");\r",
											"  pm.expect(p).to.have.property(\"page\");\r",
											"  pm.expect(p).to.have.property(\"total_count\");\r",
											"  pm.expect(p).to.have.property(\"total_pages\");\r",
											"\r",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");\r",
											"});\r",
											"\r",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r",
											"\r",
											"pm.test(\"Users array and each user object shape\", function () {\r",
											"  const users = json.data.users;\r",
											"  pm.expect(users).to.be.an(\"array\");\r",
											"\r",
											"  users.forEach((u, idx) => {\r",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");\r",
											"    pm.expect(u).to.have.property(\"login\");\r",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");\r",
											"    pm.expect(u).to.have.property(\"user_id\");\r",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);\r",
											"  });\r",
											"});\r",
											"\r",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {\r",
											"  const reqUrl = pm.request.url.toString();\r",
											"  pm.expect(reqUrl).to.include(\"page=\");\r",
											"\r",
											"  pm.response.to.have.status(200);\r",
											"  const p = json.data && json.data.pagination;\r",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");\r",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=&limit=50&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": ""
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - No param page",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {\r",
											"  pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"let json;\r",
											"pm.test(\"Response is valid JSON\", function () {\r",
											"  json = pm.response.json();\r",
											"  pm.expect(json).to.be.an(\"object\");\r",
											"});\r",
											"\r",
											"pm.test(\"Top-level status is success\", function () {\r",
											"  pm.expect(json).to.have.property(\"status\");\r",
											"  pm.expect(json.status).to.eql(\"success\");\r",
											"});\r",
											"\r",
											"pm.test(\"Response has data with pagination and users\", function () {\r",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate pagination fields and types\", function () {\r",
											"  const p = json.data.pagination;\r",
											"  pm.expect(p).to.have.property(\"has_next\");\r",
											"  pm.expect(p).to.have.property(\"has_prev\");\r",
											"  pm.expect(p).to.have.property(\"limit\");\r",
											"  pm.expect(p).to.have.property(\"page\");\r",
											"  pm.expect(p).to.have.property(\"total_count\");\r",
											"  pm.expect(p).to.have.property(\"total_pages\");\r",
											"\r",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");\r",
											"});\r",
											"\r",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r",
											"\r",
											"pm.test(\"Users array and each user object shape\", function () {\r",
											"  const users = json.data.users;\r",
											"  pm.expect(users).to.be.an(\"array\");\r",
											"\r",
											"  users.forEach((u, idx) => {\r",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");\r",
											"    pm.expect(u).to.have.property(\"login\");\r",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");\r",
											"    pm.expect(u).to.have.property(\"user_id\");\r",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);\r",
											"  });\r",
											"});\r",
											"\r",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {\r",
											"  const reqUrl = pm.request.url.toString();\r",
											"  pm.expect(reqUrl).to.not.include(\"page=\");\r",
											"\r",
											"  pm.response.to.have.status(200);\r",
											"  const p = json.data && json.data.pagination;\r",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");\r",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?limit=50&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "",
											"disabled": true
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Invalid param limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Top-level status is success\", function () {",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Response has data with pagination and users\", function () {",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");",
											"});",
											"",
											"pm.test(\"Validate pagination fields and types\", function () {",
											"  const p = json.data.pagination;",
											"  pm.expect(p).to.have.property(\"has_next\");",
											"  pm.expect(p).to.have.property(\"has_prev\");",
											"  pm.expect(p).to.have.property(\"limit\");",
											"  pm.expect(p).to.have.property(\"page\");",
											"  pm.expect(p).to.have.property(\"total_count\");",
											"  pm.expect(p).to.have.property(\"total_pages\");",
											"",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");",
											"});",
											"",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"pm.test(\"Users array and each user object shape\", function () {",
											"  const users = json.data.users;",
											"  pm.expect(users).to.be.an(\"array\");",
											"",
											"  users.forEach((u, idx) => {",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"    pm.expect(u).to.have.property(\"login\");",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");",
											"    pm.expect(u).to.have.property(\"user_id\");",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);",
											"  });",
											"});",
											"",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {",
											"  const reqUrl = pm.request.url.toString();",
											"  pm.expect(reqUrl).to.include(\"limit=aa\");",
											"",
											"  pm.response.to.have.status(200);",
											"  const p = json.data && json.data.pagination;",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=aa&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "aa"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Empty param limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {\r",
											"  pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"let json;\r",
											"pm.test(\"Response is valid JSON\", function () {\r",
											"  json = pm.response.json();\r",
											"  pm.expect(json).to.be.an(\"object\");\r",
											"});\r",
											"\r",
											"pm.test(\"Top-level status is success\", function () {\r",
											"  pm.expect(json).to.have.property(\"status\");\r",
											"  pm.expect(json.status).to.eql(\"success\");\r",
											"});\r",
											"\r",
											"pm.test(\"Response has data with pagination and users\", function () {\r",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate pagination fields and types\", function () {\r",
											"  const p = json.data.pagination;\r",
											"  pm.expect(p).to.have.property(\"has_next\");\r",
											"  pm.expect(p).to.have.property(\"has_prev\");\r",
											"  pm.expect(p).to.have.property(\"limit\");\r",
											"  pm.expect(p).to.have.property(\"page\");\r",
											"  pm.expect(p).to.have.property(\"total_count\");\r",
											"  pm.expect(p).to.have.property(\"total_pages\");\r",
											"\r",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");\r",
											"});\r",
											"\r",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r",
											"\r",
											"pm.test(\"Users array and each user object shape\", function () {\r",
											"  const users = json.data.users;\r",
											"  pm.expect(users).to.be.an(\"array\");\r",
											"\r",
											"  users.forEach((u, idx) => {\r",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");\r",
											"    pm.expect(u).to.have.property(\"login\");\r",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");\r",
											"    pm.expect(u).to.have.property(\"user_id\");\r",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);\r",
											"  });\r",
											"});\r",
											"\r",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {\r",
											"  const reqUrl = pm.request.url.toString();\r",
											"  pm.expect(reqUrl).to.include(\"page=\");\r",
											"\r",
											"  pm.response.to.have.status(200);\r",
											"  const p = json.data && json.data.pagination;\r",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");\r",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": ""
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - No param limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {\r",
											"  pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"let json;\r",
											"pm.test(\"Response is valid JSON\", function () {\r",
											"  json = pm.response.json();\r",
											"  pm.expect(json).to.be.an(\"object\");\r",
											"});\r",
											"\r",
											"pm.test(\"Top-level status is success\", function () {\r",
											"  pm.expect(json).to.have.property(\"status\");\r",
											"  pm.expect(json.status).to.eql(\"success\");\r",
											"});\r",
											"\r",
											"pm.test(\"Response has data with pagination and users\", function () {\r",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");\r",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");\r",
											"});\r",
											"\r",
											"pm.test(\"Validate pagination fields and types\", function () {\r",
											"  const p = json.data.pagination;\r",
											"  pm.expect(p).to.have.property(\"has_next\");\r",
											"  pm.expect(p).to.have.property(\"has_prev\");\r",
											"  pm.expect(p).to.have.property(\"limit\");\r",
											"  pm.expect(p).to.have.property(\"page\");\r",
											"  pm.expect(p).to.have.property(\"total_count\");\r",
											"  pm.expect(p).to.have.property(\"total_pages\");\r",
											"\r",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");\r",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");\r",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");\r",
											"});\r",
											"\r",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;\r",
											"\r",
											"pm.test(\"Users array and each user object shape\", function () {\r",
											"  const users = json.data.users;\r",
											"  pm.expect(users).to.be.an(\"array\");\r",
											"\r",
											"  users.forEach((u, idx) => {\r",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");\r",
											"    pm.expect(u).to.have.property(\"login\");\r",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");\r",
											"    pm.expect(u).to.have.property(\"user_id\");\r",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);\r",
											"  });\r",
											"});\r",
											"\r",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {\r",
											"  const reqUrl = pm.request.url.toString();\r",
											"  pm.expect(reqUrl).to.not.include(\"limit=\");\r",
											"\r",
											"  pm.response.to.have.status(200);\r",
											"  const p = json.data && json.data.pagination;\r",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");\r",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50",
											"disabled": true
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Empty param search",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Top-level status is success\", function () {",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Response has data with pagination and users\", function () {",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");",
											"});",
											"",
											"pm.test(\"Validate pagination fields and types\", function () {",
											"  const p = json.data.pagination;",
											"  pm.expect(p).to.have.property(\"has_next\");",
											"  pm.expect(p).to.have.property(\"has_prev\");",
											"  pm.expect(p).to.have.property(\"limit\");",
											"  pm.expect(p).to.have.property(\"page\");",
											"  pm.expect(p).to.have.property(\"total_count\");",
											"  pm.expect(p).to.have.property(\"total_pages\");",
											"",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");",
											"});",
											"",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"pm.test(\"Users array and each user object shape\", function () {",
											"  const users = json.data.users;",
											"  pm.expect(users).to.be.an(\"array\");",
											"",
											"  users.forEach((u, idx) => {",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"    pm.expect(u).to.have.property(\"login\");",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");",
											"    pm.expect(u).to.have.property(\"user_id\");",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);",
											"  });",
											"});",
											"",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {",
											"  const reqUrl = pm.request.url.toString();",
											"  pm.expect(reqUrl).to.include(\"page=\");",
											"",
											"  pm.response.to.have.status(200);",
											"  const p = json.data && json.data.pagination;",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=50&search=",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": ""
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Empty params",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Top-level status is success\", function () {",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Response has data with pagination and users\", function () {",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");",
											"});",
											"",
											"pm.test(\"Validate pagination fields and types\", function () {",
											"  const p = json.data.pagination;",
											"  pm.expect(p).to.have.property(\"has_next\");",
											"  pm.expect(p).to.have.property(\"has_prev\");",
											"  pm.expect(p).to.have.property(\"limit\");",
											"  pm.expect(p).to.have.property(\"page\");",
											"  pm.expect(p).to.have.property(\"total_count\");",
											"  pm.expect(p).to.have.property(\"total_pages\");",
											"",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");",
											"});",
											"",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"pm.test(\"Users array and each user object shape\", function () {",
											"  const users = json.data.users;",
											"  pm.expect(users).to.be.an(\"array\");",
											"",
											"  users.forEach((u, idx) => {",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"    pm.expect(u).to.have.property(\"login\");",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");",
											"    pm.expect(u).to.have.property(\"user_id\");",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);",
											"  });",
											"});",
											"",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {",
											"  const reqUrl = pm.request.url.toString();",
											"  pm.expect(reqUrl).to.include(\"page=\");",
											"",
											"  pm.response.to.have.status(200);",
											"  const p = json.data && json.data.pagination;",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=&limit=&search=",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": ""
										},
										{
											"key": "limit",
											"value": ""
										},
										{
											"key": "search",
											"value": ""
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - No params",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Top-level status is success\", function () {",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"Response has data with pagination and users\", function () {",
											"  pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"pagination\").that.is.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"users\").that.is.an(\"array\");",
											"});",
											"",
											"pm.test(\"Validate pagination fields and types\", function () {",
											"  const p = json.data.pagination;",
											"  pm.expect(p).to.have.property(\"has_next\");",
											"  pm.expect(p).to.have.property(\"has_prev\");",
											"  pm.expect(p).to.have.property(\"limit\");",
											"  pm.expect(p).to.have.property(\"page\");",
											"  pm.expect(p).to.have.property(\"total_count\");",
											"  pm.expect(p).to.have.property(\"total_pages\");",
											"",
											"  pm.expect(p.has_next, \"has_next should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.has_prev, \"has_prev should be boolean\").to.be.a(\"boolean\");",
											"  pm.expect(p.limit, \"limit should be number\").to.be.a(\"number\");",
											"  pm.expect(p.page, \"page should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_count, \"total_count should be number\").to.be.a(\"number\");",
											"  pm.expect(p.total_pages, \"total_pages should be number\").to.be.a(\"number\");",
											"});",
											"",
											"const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"pm.test(\"Users array and each user object shape\", function () {",
											"  const users = json.data.users;",
											"  pm.expect(users).to.be.an(\"array\");",
											"",
											"  users.forEach((u, idx) => {",
											"    pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"    pm.expect(u).to.have.property(\"login\");",
											"    pm.expect(u.login, `login at index ${idx} should be string`).to.be.a(\"string\");",
											"    pm.expect(u).to.have.property(\"user_id\");",
											"    pm.expect(u.user_id, `user_id at index ${idx} should match UUID format`).to.match(uuidRegex);",
											"  });",
											"});",
											"",
											"pm.test(\"Invalid 'page' query defaults to page 1 and does not error\", function () {",
											"  const reqUrl = pm.request.url.toString();",
											"  pm.expect(reqUrl).to.not.include(\"limit=\");",
											"",
											"  pm.response.to.have.status(200);",
											"  const p = json.data && json.data.pagination;",
											"  pm.expect(p, \"pagination should exist in response\").to.be.an(\"object\");",
											"  pm.expect(p.page, \"page in response should default to 1\").to.eql(1);",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "",
											"disabled": true
										},
										{
											"key": "limit",
											"value": "",
											"disabled": true
										},
										{
											"key": "search",
											"value": "",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Invalid access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjQyMzIyODcsImlhdCI6MTc2NDIzMTM4NywiaVPzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJzdWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiYTJiOWJkNTMtNzhkMS00M2E5LWIzOTgtMjk3NzE5MzA0NDFkIn0.zetyB9gr3w5i1nwbfWV-tFXcfcIb7RtZ9TVv9NqhuvI",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=50&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Empty access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=50&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - No access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=50&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"    const meta = {",
											"        requestName: pm.info.requestName,",
											"        requestId: pm.info.requestId,",
											"        method: pm.request.method,",
											"        url: pm.request.url.toString(),",
											"        status: pm.response.code,",
											"        timestamp: new Date().toISOString()",
											"    };",
											"    console.log(\"[TEST META]\", JSON.stringify(meta, null, 2));",
											"",
											"    pm.test(\"Status code is 404 (Not Found)\", function () {",
											"        pm.expect(pm.response.code, `Expected 404 but got ${pm.response.code}`).to.eql(404);",
											"    });",
											"",
											"    let json;",
											"    pm.test(\"Response body is valid JSON\", function () {",
											"        try {",
											"            json = pm.response.json();",
											"            pm.expect(json, \"Parsed JSON should be an object\").to.be.an(\"object\");",
											"        } catch (err) {",
											"            console.error(\"[PARSE ERROR]\", err?.message || err);",
											"            throw new Error(\"Response body is not valid JSON: \" + (err?.message || err));",
											"        }",
											"    });",
											"",
											"    pm.test(\"Response has required string properties: code, message, status\", function () {",
											"        pm.expect(json, \"Response must be an object\").to.be.an(\"object\");",
											"        pm.expect(json, \"Missing 'code' property\").to.have.property(\"code\");",
											"        pm.expect(json.code, \"'code' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'message' property\").to.have.property(\"message\");",
											"        pm.expect(json.message, \"'message' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'status' property\").to.have.property(\"status\");",
											"        pm.expect(json.status, \"'status' must be a string\").to.be.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"status equals 'error'\", function () {",
											"        pm.expect(json.status, \"Expected status to be 'error'\").to.eql(\"error\");",
											"    });",
											"",
											"    pm.test(\"code equals 'ENDPOINT_NOT_FOUND'\", function () {",
											"        pm.expect(json.code, \"Expected code to be 'ENDPOINT_NOT_FOUND'\").to.eql(\"ENDPOINT_NOT_FOUND\");",
											"    });",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1",
											"disabled": true
										},
										{
											"key": "limit",
											"value": "50",
											"disabled": true
										},
										{
											"key": "search",
											"value": "bob",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - user not found",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"console.log('[Get Users] URL:', pm.request.url.toString());",
											"console.log('[Get Users] Method:', pm.request.method);",
											"console.log('[Get Users] Auth bearer present:', !!pm.request.headers.get('Authorization'));",
											"",
											"pm.test('Status code is 200', function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test('Response is valid JSON', function () {",
											"  json = pm.response.json();",
											"  pm.expect(json).to.be.an('object');",
											"});",
											"",
											"pm.test(\"Response status field equals 'success'\", function () {",
											"  pm.expect(json).to.have.property('status');",
											"  pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test('Response has data object', function () {",
											"  pm.expect(json).to.have.property('data');",
											"  pm.expect(json.data).to.be.an('object');",
											"});",
											"",
											"pm.test('Data.pagination exists with expected keys and types', function () {",
											"  pm.expect(json.data).to.have.property('pagination');",
											"  const p = json.data.pagination;",
											"  pm.expect(p).to.be.an('object');",
											"",
											"  const numberKeys = ['page', 'limit', 'total_count', 'total_pages'];",
											"  const booleanKeys = ['has_next', 'has_prev'];",
											"",
											"  numberKeys.forEach(function (k) {",
											"    pm.expect(p, 'missing key: ' + k).to.have.property(k);",
											"    pm.expect(p[k], 'key type for ' + k).to.be.a('number');",
											"  });",
											"  booleanKeys.forEach(function (k) {",
											"    pm.expect(p, 'missing key: ' + k).to.have.property(k);",
											"    pm.expect(p[k], 'key type for ' + k).to.be.a('boolean');",
											"  });",
											"});",
											"",
											"pm.test('Data.users is an array', function () {",
											"  pm.expect(json.data).to.have.property('users');",
											"  pm.expect(json.data.users).to.be.an('array');",
											"});",
											"",
											"pm.test('When users is empty, total_count is 0', function () {",
											"  const users = json.data && Array.isArray(json.data.users) ? json.data.users : [];",
											"  const totalCount = json.data && json.data.pagination ? json.data.pagination.total_count : undefined;",
											"  if (users.length === 0) {",
											"    pm.expect(totalCount, 'total_count should be 0 when no users found').to.eql(0);",
											"  } else {",
											"    pm.expect(users.length).to.be.greaterThan(0);",
											"  }",
											"});",
											"",
											"pm.test('When users are present, each has id, username, email', function () {",
											"  const users = json.data && Array.isArray(json.data.users) ? json.data.users : [];",
											"  if (users.length > 0) {",
											"    users.forEach(function (u, idx) {",
											"      pm.expect(u, 'user object at index ' + idx).to.be.an('object');",
											"      ['id', 'username', 'email'].forEach(function (key) {",
											"        pm.expect(u, 'user at index ' + idx + ' missing ' + key).to.have.property(key);",
											"      });",
											"    });",
											"  } else {",
											"    pm.expect(users.length).to.eql(0); // informational assertion to keep test green when empty",
											"  }",
											"});",
											"",
											"try {",
											"  const dbg = {",
											"    status: pm.response.code,",
											"    time: pm.response.responseTime,",
											"    size: pm.response.responseSize,",
											"    query: pm.request.url.query.toObject(),",
											"    pagination: json && json.data ? json.data.pagination : undefined,",
											"    usersCount: json && json.data && Array.isArray(json.data.users) ? json.data.users.length : undefined",
											"  };",
											"  console.log('[Get Users] Debug:', dbg);",
											"} catch (e) {",
											"  console.log('[Get Users] Debug log error:', e && e.message);",
											"}"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=50&search=nonexist",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "nonexist"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Successfully get all users",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function safeJsonParse(text) {",
											"    try { return text ? JSON.parse(text) : null; } catch (e) { return null; }",
											"}",
											"",
											"function withBodyOnFailure(name, fn) {",
											"    pm.test(name, function () {",
											"        try {",
											"            fn();",
											"        } catch (err) {",
											"            pm.test(\"Response body (for debugging)\", function () {",
											"                pm.expect(pm.response.text() || \"\").to.be.a(\"string\");",
											"            });",
											"            throw err; // rethrow so original test is marked failed",
											"        }",
											"    });",
											"}",
											"",
											"const bodyText = pm.response.text();",
											"const json = safeJsonParse(bodyText);",
											"",
											"withBodyOnFailure(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"withBodyOnFailure(\"Top-level properties exist and status is 'success'\", function () {",
											"    pm.expect(json, \"Response should be valid JSON\").to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"withBodyOnFailure(\"data.pagination has required fields with correct types\", function () {",
											"    pm.expect(json.data, \"data should be an object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"pagination\");",
											"    const p = json.data.pagination;",
											"    pm.expect(p, \"pagination should be an object\").to.be.an(\"object\");",
											"",
											"    [\"page\", \"limit\", \"total_count\", \"total_pages\", \"has_next\", \"has_prev\"].forEach(prop => {",
											"        pm.expect(p, `pagination should have ${prop}`).to.have.property(prop);",
											"    });",
											"",
											"    [\"page\", \"limit\", \"total_count\", \"total_pages\"].forEach(prop => {",
											"        pm.expect(p[prop], `${prop} should be a number`).to.be.a(\"number\");",
											"    });",
											"    [\"has_next\", \"has_prev\"].forEach(prop => {",
											"        pm.expect(p[prop], `${prop} should be a boolean`).to.be.a(\"boolean\");",
											"    });",
											"});",
											"",
											"withBodyOnFailure(\"data.users length matches pagination.total_count\", function () {",
											"    pm.expect(json.data).to.have.property(\"users\");",
											"    pm.expect(json.data.users, \"users should be an array\").to.be.an(\"array\");",
											"    const users = json.data.users;",
											"    const total = json.data.pagination && typeof json.data.pagination.total_count === 'number' ? json.data.pagination.total_count : undefined;",
											"    pm.expect(total, \"pagination.total_count should be a number\").to.be.a(\"number\");",
											"    pm.expect(users.length, \"users length should equal pagination.total_count\").to.eql(total);",
											"});",
											"",
											"withBodyOnFailure(\"Each user has login (string) and user_id (string, UUID v4)\", function () {",
											"    const users = (json && json.data && Array.isArray(json.data.users)) ? json.data.users : [];",
											"    const uuidV4 = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    users.forEach((u, idx) => {",
											"        pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"        pm.expect(u).to.have.property(\"login\");",
											"        pm.expect(u.login, `login at index ${idx} should be a string`).to.be.a(\"string\");",
											"        pm.expect(u).to.have.property(\"user_id\");",
											"        pm.expect(u.user_id, `user_id at index ${idx} should be a string`).to.be.a(\"string\");",
											"        pm.expect(uuidV4.test(u.user_id), `user_id at index ${idx} should be a valid UUID v4`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=50",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "username",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Get users - Successfully get user bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function safeJsonParse(text) {",
											"    try { return text ? JSON.parse(text) : null; } catch (e) { return null; }",
											"}",
											"",
											"function withBodyOnFailure(name, fn) {",
											"    pm.test(name, function () {",
											"        try {",
											"            fn();",
											"        } catch (err) {",
											"            pm.test(\"Response body (for debugging)\", function () {",
											"                pm.expect(pm.response.text() || \"\").to.be.a(\"string\");",
											"            });",
											"            throw err; // rethrow so original test is marked failed",
											"        }",
											"    });",
											"}",
											"",
											"const bodyText = pm.response.text();",
											"const json = safeJsonParse(bodyText);",
											"",
											"withBodyOnFailure(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"withBodyOnFailure(\"Top-level properties exist and status is 'success'\", function () {",
											"    pm.expect(json, \"Response should be valid JSON\").to.be.an(\"object\");",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"withBodyOnFailure(\"data.pagination has required fields with correct types\", function () {",
											"    pm.expect(json.data, \"data should be an object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"pagination\");",
											"    const p = json.data.pagination;",
											"    pm.expect(p, \"pagination should be an object\").to.be.an(\"object\");",
											"",
											"    [\"page\", \"limit\", \"total_count\", \"total_pages\", \"has_next\", \"has_prev\"].forEach(prop => {",
											"        pm.expect(p, `pagination should have ${prop}`).to.have.property(prop);",
											"    });",
											"",
											"    [\"page\", \"limit\", \"total_count\", \"total_pages\"].forEach(prop => {",
											"        pm.expect(p[prop], `${prop} should be a number`).to.be.a(\"number\");",
											"    });",
											"    [\"has_next\", \"has_prev\"].forEach(prop => {",
											"        pm.expect(p[prop], `${prop} should be a boolean`).to.be.a(\"boolean\");",
											"    });",
											"});",
											"",
											"withBodyOnFailure(\"data.users length matches pagination.total_count\", function () {",
											"    pm.expect(json.data).to.have.property(\"users\");",
											"    pm.expect(json.data.users, \"users should be an array\").to.be.an(\"array\");",
											"    const users = json.data.users;",
											"    const total = json.data.pagination && typeof json.data.pagination.total_count === 'number' ? json.data.pagination.total_count : undefined;",
											"    pm.expect(total, \"pagination.total_count should be a number\").to.be.a(\"number\");",
											"    pm.expect(users.length, \"users length should equal pagination.total_count\").to.eql(total);",
											"});",
											"",
											"withBodyOnFailure(\"Each user has login (string) and user_id (string, UUID v4)\", function () {",
											"    const users = (json && json.data && Array.isArray(json.data.users)) ? json.data.users : [];",
											"    const uuidV4 = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"    users.forEach((u, idx) => {",
											"        pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"        pm.expect(u).to.have.property(\"login\");",
											"        pm.expect(u.login, `login at index ${idx} should be a string`).to.be.a(\"string\");",
											"        pm.expect(u).to.have.property(\"user_id\");",
											"        pm.expect(u.user_id, `user_id at index ${idx} should be a string`).to.be.a(\"string\");",
											"        pm.expect(uuidV4.test(u.user_id), `user_id at index ${idx} should be a valid UUID v4`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "GET",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users?page=1&limit=50&search=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users"
									],
									"query": [
										{
											"key": "page",
											"value": "1"
										},
										{
											"key": "limit",
											"value": "50"
										},
										{
											"key": "search",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Search users",
					"item": [
						{
							"name": "Search users - Invalid param limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response has JSON body\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const contentType = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(/application\\/json/i.test(contentType)).to.be.true;",
											"    pm.expect(function(){ pm.response.json(); }).to.not.throw();",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(bodyIsJson).to.be.true;",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"function isNonNegativeInteger(n){ return Number.isInteger(n) && n >= 0; }",
											"function isPositiveInteger(n){ return Number.isInteger(n) && n > 0; }",
											"const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"const data = json && typeof json === 'object' ? json.data : undefined;",
											"const meta = data && typeof data === 'object' ? data.meta : undefined;",
											"const users = data && Array.isArray(data.users) ? data.users : [];",
											"",
											"pm.test(\"meta.count is non-negative integer and equals number of users\", function () {",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta.count, \"meta.count should be a number\").to.satisfy(Number.isInteger);",
											"    pm.expect(meta.count, \"meta.count should be >= 0\").to.be.at.least(0);",
											"    pm.expect(users, \"data.users should be an array\").to.be.an(\"array\");",
											"    pm.expect(meta.count, \"meta.count should equal users length\").to.eql(users.length);",
											"});",
											"",
											"const requestUrl = pm.request.url.toString();",
											"const urlQuery = pm.request.url.query || [];",
											"let providedLimitParam = urlQuery.find(q => q.key === 'limit' && q.disabled !== true);",
											"let providedLimit = providedLimitParam ? providedLimitParam.value : undefined;",
											"let providedLimitNum = providedLimit !== undefined ? Number(providedLimit) : undefined;",
											"const limitIsNumeric = providedLimit !== undefined && providedLimit !== '' && !Number.isNaN(providedLimitNum) && /^\\d+$/.test(String(providedLimit));",
											"",
											"pm.test(\"meta.limit is a positive integer\", function () {",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta.limit, \"meta.limit should be integer\").to.satisfy(Number.isInteger);",
											"    pm.expect(meta.limit, \"meta.limit should be > 0\").to.be.above(0);",
											"});",
											"",
											"pm.test(\"Server uses default limit=20 when provided limit is invalid\", function () {",
											"    if (!limitIsNumeric) {",
											"        pm.expect(meta.limit, \"Expected server to fallback to default limit 20\").to.eql(20);",
											"    } else {",
											"        pm.expect(isPositiveInteger(meta.limit), \"meta.limit should be positive integer when valid limit provided\").to.be.true;",
											"    }",
											"});",
											"",
											"pm.test(\"Each user has non-empty login and valid UUID v4 user_id\", function () {",
											"    pm.expect(users).to.be.an('array');",
											"    users.forEach((u, idx) => {",
											"        pm.expect(u, `user at index ${idx} should be an object`).to.be.an('object');",
											"        pm.expect(u.login, `user[${idx}].login should be a non-empty string`).to.be.a('string');",
											"        pm.expect(u.login.trim().length > 0, `user[${idx}].login should not be empty`).to.be.true;",
											"        pm.expect(u.user_id, `user[${idx}].user_id should be a string`).to.be.a('string');",
											"        pm.expect(uuidV4Regex.test(u.user_id), `user[${idx}].user_id should be valid UUID v4`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=bob&limit=aa",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "bob"
										},
										{
											"key": "limit",
											"value": "aa"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - Empty param limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response has JSON body\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const contentType = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(/application\\/json/i.test(contentType)).to.be.true;",
											"    // Also ensure parsing does not throw",
											"    pm.expect(function(){ pm.response.json(); }).to.not.throw();",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(bodyIsJson).to.be.true;",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"function isNonNegativeInteger(n){ return Number.isInteger(n) && n >= 0; }",
											"function isPositiveInteger(n){ return Number.isInteger(n) && n > 0; }",
											"const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"const data = json && typeof json === 'object' ? json.data : undefined;",
											"const meta = data && typeof data === 'object' ? data.meta : undefined;",
											"const users = data && Array.isArray(data.users) ? data.users : [];",
											"",
											"pm.test(\"meta.count is non-negative integer and equals number of users\", function () {",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta.count, \"meta.count should be a number\").to.satisfy(Number.isInteger);",
											"    pm.expect(meta.count, \"meta.count should be >= 0\").to.be.at.least(0);",
											"    pm.expect(users, \"data.users should be an array\").to.be.an(\"array\");",
											"    pm.expect(meta.count, \"meta.count should equal users length\").to.eql(users.length);",
											"});",
											"",
											"const requestUrl = pm.request.url.toString();",
											"const urlQuery = pm.request.url.query || [];",
											"let providedLimitParam = urlQuery.find(q => q.key === 'limit' && q.disabled !== true);",
											"let providedLimit = providedLimitParam ? providedLimitParam.value : undefined;",
											"let providedLimitNum = providedLimit !== undefined ? Number(providedLimit) : undefined;",
											"const limitIsNumeric = providedLimit !== undefined && providedLimit !== '' && !Number.isNaN(providedLimitNum) && /^\\d+$/.test(String(providedLimit));",
											"",
											"pm.test(\"meta.limit is a positive integer\", function () {",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta.limit, \"meta.limit should be integer\").to.satisfy(Number.isInteger);",
											"    pm.expect(meta.limit, \"meta.limit should be > 0\").to.be.above(0);",
											"});",
											"",
											"pm.test(\"Server uses default limit=20 when provided limit is invalid\", function () {",
											"    if (!limitIsNumeric) {",
											"        pm.expect(meta.limit, \"Expected server to fallback to default limit 20\").to.eql(20);",
											"    } else {",
											"        pm.expect(isPositiveInteger(meta.limit), \"meta.limit should be positive integer when valid limit provided\").to.be.true;",
											"    }",
											"});",
											"",
											"pm.test(\"Each user has non-empty login and valid UUID v4 user_id\", function () {",
											"    pm.expect(users).to.be.an('array');",
											"    users.forEach((u, idx) => {",
											"        pm.expect(u, `user at index ${idx} should be an object`).to.be.an('object');",
											"        pm.expect(u.login, `user[${idx}].login should be a non-empty string`).to.be.a('string');",
											"        pm.expect(u.login.trim().length > 0, `user[${idx}].login should not be empty`).to.be.true;",
											"        pm.expect(u.user_id, `user[${idx}].user_id should be a string`).to.be.a('string');",
											"        pm.expect(uuidV4Regex.test(u.user_id), `user[${idx}].user_id should be valid UUID v4`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=bob&limit=",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "bob"
										},
										{
											"key": "limit",
											"value": ""
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - No param limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response has JSON body\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const contentType = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(/application\\/json/i.test(contentType)).to.be.true;",
											"    pm.expect(function(){ pm.response.json(); }).to.not.throw();",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = {};",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(bodyIsJson).to.be.true;",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"function isNonNegativeInteger(n){ return Number.isInteger(n) && n >= 0; }",
											"function isPositiveInteger(n){ return Number.isInteger(n) && n > 0; }",
											"const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"",
											"const data = json && typeof json === 'object' ? json.data : undefined;",
											"const meta = data && typeof data === 'object' ? data.meta : undefined;",
											"const users = data && Array.isArray(data.users) ? data.users : [];",
											"",
											"pm.test(\"meta.count is non-negative integer and equals number of users\", function () {",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta.count, \"meta.count should be a number\").to.satisfy(Number.isInteger);",
											"    pm.expect(meta.count, \"meta.count should be >= 0\").to.be.at.least(0);",
											"    pm.expect(users, \"data.users should be an array\").to.be.an(\"array\");",
											"    pm.expect(meta.count, \"meta.count should equal users length\").to.eql(users.length);",
											"});",
											"",
											"const requestUrl = pm.request.url.toString();",
											"const urlQuery = pm.request.url.query || [];",
											"let providedLimitParam = urlQuery.find(q => q.key === 'limit' && q.disabled !== true);",
											"let providedLimit = providedLimitParam ? providedLimitParam.value : undefined;",
											"let providedLimitNum = providedLimit !== undefined ? Number(providedLimit) : undefined;",
											"const limitIsNumeric = providedLimit !== undefined && providedLimit !== '' && !Number.isNaN(providedLimitNum) && /^\\d+$/.test(String(providedLimit));",
											"",
											"pm.test(\"meta.limit is a positive integer\", function () {",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta.limit, \"meta.limit should be integer\").to.satisfy(Number.isInteger);",
											"    pm.expect(meta.limit, \"meta.limit should be > 0\").to.be.above(0);",
											"});",
											"",
											"pm.test(\"Server uses default limit=20 when provided limit is invalid\", function () {",
											"    if (!limitIsNumeric) {",
											"        pm.expect(meta.limit, \"Expected server to fallback to default limit 20\").to.eql(20);",
											"    } else {",
											"        pm.expect(isPositiveInteger(meta.limit), \"meta.limit should be positive integer when valid limit provided\").to.be.true;",
											"    }",
											"});",
											"",
											"pm.test(\"Each user has non-empty login and valid UUID v4 user_id\", function () {",
											"    pm.expect(users).to.be.an('array');",
											"    users.forEach((u, idx) => {",
											"        pm.expect(u, `user at index ${idx} should be an object`).to.be.an('object');",
											"        pm.expect(u.login, `user[${idx}].login should be a non-empty string`).to.be.a('string');",
											"        pm.expect(u.login.trim().length > 0, `user[${idx}].login should not be empty`).to.be.true;",
											"        pm.expect(u.user_id, `user[${idx}].user_id should be a string`).to.be.a('string');",
											"        pm.expect(uuidV4Regex.test(u.user_id), `user[${idx}].user_id should be valid UUID v4`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "bob"
										},
										{
											"key": "limit",
											"value": "",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - Empty param query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function getQueryParam(name) {",
											"  try {",
											"    const url = new URL(pm.request.url.toString());",
											"    return url.searchParams.get(name);",
											"  } catch (e) {",
											"    const raw = pm.request.url.toString();",
											"    const match = raw.match(new RegExp('[?&]'+name+'=([^&#]*)'));",
											"    return match ? decodeURIComponent(match[1]) : null;",
											"  }",
											"}",
											"",
											"let isJson = false;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"  isJson = true;",
											"} catch (e) {",
											"  isJson = false;",
											"}",
											"",
											"pm.test(\"When code=MISSING_QUERY, status code is 400\", function () {",
											"  if (isJson && json && json.code === \"MISSING_QUERY\") {",
											"    pm.expect(pm.response.code, \"Expected 400 when query is missing\").to.eql(400);",
											"  } else {",
											"    pm.expect(true, \"Not an error for missing query; skipping\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Error response contains keys: code, message, status (when applicable)\", function () {",
											"  if (isJson && json && (json.code || json.message || json.status)) {",
											"    pm.expect(json, \"Response should include 'code' field\").to.have.property('code');",
											"    pm.expect(json, \"Response should include 'message' field\").to.have.property('message');",
											"    pm.expect(json, \"Response should include 'status' field\").to.have.property('status');",
											"  } else {",
											"    pm.expect(true, \"No error keys present; likely a success response; skipping\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"200 OK: users array exists and respects 'limit' query param (default 20)\", function () {",
											"  if (pm.response.code === 200 && isJson) {",
											"    pm.expect(json, \"Response JSON should be an object\").to.be.an('object');",
											"",
											"    let users = Array.isArray(json) ? json : json.users;",
											"    pm.expect(users, \"A 'users' array must be present on success\").to.be.an('array');",
											"",
											"    let limitParam = getQueryParam('limit');",
											"    let limit = 20;",
											"    if (limitParam !== null && limitParam !== '') {",
											"      const asNum = Number(limitParam);",
											"      if (!Number.isNaN(asNum) && asNum > 0) {",
											"        limit = asNum;",
											"      }",
											"    }",
											"",
											"    pm.expect(users.length, `Users length (${users.length}) should be <= limit (${limit})`).to.be.at.most(limit);",
											"  } else {",
											"    pm.expect(true, \"Not a 200 response; skipping success validations\").to.be.true;",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=&limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": ""
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - No param query",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function getQueryParam(name) {",
											"  try {",
											"    const url = new URL(pm.request.url.toString());",
											"    return url.searchParams.get(name);",
											"  } catch (e) {",
											"    const raw = pm.request.url.toString();",
											"    const match = raw.match(new RegExp('[?&]'+name+'=([^&#]*)'));",
											"    return match ? decodeURIComponent(match[1]) : null;",
											"  }",
											"}",
											"",
											"let isJson = false;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"  isJson = true;",
											"} catch (e) {",
											"  isJson = false;",
											"}",
											"",
											"pm.test(\"When code=MISSING_QUERY, status code is 400\", function () {",
											"  if (isJson && json && json.code === \"MISSING_QUERY\") {",
											"    pm.expect(pm.response.code, \"Expected 400 when query is missing\").to.eql(400);",
											"  } else {",
											"    pm.expect(true, \"Not an error for missing query; skipping\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Error response contains keys: code, message, status (when applicable)\", function () {",
											"  if (isJson && json && (json.code || json.message || json.status)) {",
											"    pm.expect(json, \"Response should include 'code' field\").to.have.property('code');",
											"    pm.expect(json, \"Response should include 'message' field\").to.have.property('message');",
											"    pm.expect(json, \"Response should include 'status' field\").to.have.property('status');",
											"  } else {",
											"    pm.expect(true, \"No error keys present; likely a success response; skipping\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"200 OK: users array exists and respects 'limit' query param (default 20)\", function () {",
											"  if (pm.response.code === 200 && isJson) {",
											"    pm.expect(json, \"Response JSON should be an object\").to.be.an('object');",
											"",
											"    let users = Array.isArray(json) ? json : json.users;",
											"    pm.expect(users, \"A 'users' array must be present on success\").to.be.an('array');",
											"",
											"    let limitParam = getQueryParam('limit');",
											"    let limit = 20;",
											"    if (limitParam !== null && limitParam !== '') {",
											"      const asNum = Number(limitParam);",
											"      if (!Number.isNaN(asNum) && asNum > 0) {",
											"        limit = asNum;",
											"      }",
											"    }",
											"",
											"    pm.expect(users.length, `Users length (${users.length}) should be <= limit (${limit})`).to.be.at.most(limit);",
											"  } else {",
											"    pm.expect(true, \"Not a 200 response; skipping success validations\").to.be.true;",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "",
											"disabled": true
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - No params",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function getQueryParam(name) {",
											"  try {",
											"    const url = new URL(pm.request.url.toString());",
											"    return url.searchParams.get(name);",
											"  } catch (e) {",
											"    const raw = pm.request.url.toString();",
											"    const match = raw.match(new RegExp('[?&]'+name+'=([^&#]*)'));",
											"    return match ? decodeURIComponent(match[1]) : null;",
											"  }",
											"}",
											"",
											"let isJson = false;",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"  isJson = true;",
											"} catch (e) {",
											"  isJson = false;",
											"}",
											"",
											"pm.test(\"When code=MISSING_QUERY, status code is 400\", function () {",
											"  if (isJson && json && json.code === \"MISSING_QUERY\") {",
											"    pm.expect(pm.response.code, \"Expected 400 when query is missing\").to.eql(400);",
											"  } else {",
											"    pm.expect(true, \"Not an error for missing query; skipping\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Error response contains keys: code, message, status (when applicable)\", function () {",
											"  if (isJson && json && (json.code || json.message || json.status)) {",
											"    pm.expect(json, \"Response should include 'code' field\").to.have.property('code');",
											"    pm.expect(json, \"Response should include 'message' field\").to.have.property('message');",
											"    pm.expect(json, \"Response should include 'status' field\").to.have.property('status');",
											"  } else {",
											"    pm.expect(true, \"No error keys present; likely a success response; skipping\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"200 OK: users array exists and respects 'limit' query param (default 20)\", function () {",
											"  if (pm.response.code === 200 && isJson) {",
											"    pm.expect(json, \"Response JSON should be an object\").to.be.an('object');",
											"",
											"    let users = Array.isArray(json) ? json : json.users;",
											"    pm.expect(users, \"A 'users' array must be present on success\").to.be.an('array');",
											"",
											"    let limitParam = getQueryParam('limit');",
											"    let limit = 20;",
											"    if (limitParam !== null && limitParam !== '') {",
											"      const asNum = Number(limitParam);",
											"      if (!Number.isNaN(asNum) && asNum > 0) {",
											"        limit = asNum;",
											"      }",
											"    }",
											"",
											"    pm.expect(users.length, `Users length (${users.length}) should be <= limit (${limit})`).to.be.at.most(limit);",
											"  } else {",
											"    pm.expect(true, \"Not a 200 response; skipping success validations\").to.be.true;",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "",
											"disabled": true
										},
										{
											"key": "limit",
											"value": "20",
											"disabled": true
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - Invalid access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjQyMzUxOTUsImlhdCI6MTc2NDIzNDI5NSwiaXNzIjoibm75YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJzdWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiYTJiOWJkNTMtNzhkMS00M2E5LWIzOTgtMjk3NzE5MzA0NDFkIn0.8IojQagJhcVK6cgBkg1sjKV_fCtg10xtzbbHz0KY4VI",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=bob&limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "bob"
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - Empty access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=bob&limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "bob"
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - No access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=bob&limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "bob"
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"    const meta = {",
											"        requestName: pm.info.requestName,",
											"        requestId: pm.info.requestId,",
											"        method: pm.request.method,",
											"        url: pm.request.url.toString(),",
											"        status: pm.response.code,",
											"        timestamp: new Date().toISOString()",
											"    };",
											"    console.log(\"[TEST META]\", JSON.stringify(meta, null, 2));",
											"",
											"    pm.test(\"Status code is 404 (Not Found)\", function () {",
											"        pm.expect(pm.response.code, `Expected 404 but got ${pm.response.code}`).to.eql(404);",
											"    });",
											"",
											"    let json;",
											"    pm.test(\"Response body is valid JSON\", function () {",
											"        try {",
											"            json = pm.response.json();",
											"            pm.expect(json, \"Parsed JSON should be an object\").to.be.an(\"object\");",
											"        } catch (err) {",
											"            console.error(\"[PARSE ERROR]\", err?.message || err);",
											"            throw new Error(\"Response body is not valid JSON: \" + (err?.message || err));",
											"        }",
											"    });",
											"",
											"    pm.test(\"Response has required string properties: code, message, status\", function () {",
											"        pm.expect(json, \"Response must be an object\").to.be.an(\"object\");",
											"        pm.expect(json, \"Missing 'code' property\").to.have.property(\"code\");",
											"        pm.expect(json.code, \"'code' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'message' property\").to.have.property(\"message\");",
											"        pm.expect(json.message, \"'message' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'status' property\").to.have.property(\"status\");",
											"        pm.expect(json.status, \"'status' must be a string\").to.be.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"status equals 'error'\", function () {",
											"        pm.expect(json.status, \"Expected status to be 'error'\").to.eql(\"error\");",
											"    });",
											"",
											"    pm.test(\"code equals 'ENDPOINT_NOT_FOUND'\", function () {",
											"        pm.expect(json.code, \"Expected code to be 'ENDPOINT_NOT_FOUND'\").to.eql(\"ENDPOINT_NOT_FOUND\");",
											"    });",
											"",
											"    try {",
											"        console.log(\"[RESPONSE BODY]\", JSON.stringify(json, null, 2));",
											"    } catch (e) {",
											"        console.log(\"[RESPONSE BODY RAW]\", pm.response.text());",
											"    }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=nonexist&limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "nonexist"
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - user not found",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  pm.test(\"Response body is valid JSON\", function () {",
											"    pm.expect.fail(\"Response is not valid JSON: \" + e.message);",
											"  });",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response status property is 'success'\", function () {",
											"  pm.expect(json).to.be.an(\"object\");",
											"  pm.expect(json.status, \"status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"function getQueryParam(name) {",
											"  try {",
											"    const url = new URL(pm.request.url.toString());",
											"    return url.searchParams.get(name);",
											"  } catch (e) {",
											"    const raw = pm.request.url.toString();",
											"    const qIndex = raw.indexOf(\"?\");",
											"    if (qIndex === -1) return null;",
											"    const qs = raw.substring(qIndex + 1);",
											"    const parts = qs.split(\"&\");",
											"    for (const p of parts) {",
											"      const [k, v] = p.split(\"=\");",
											"      if (decodeURIComponent(k) === name) return decodeURIComponent(v || \"\");",
											"    }",
											"    return null;",
											"  }",
											"}",
											"",
											"pm.test(\"meta.query matches request query parameter\", function () {",
											"  pm.expect(json).to.have.property(\"data\");",
											"  pm.expect(json.data).to.have.property(\"meta\");",
											"  const meta = json.data.meta || {};",
											"  const requestQuery = getQueryParam(\"query\");",
											"  pm.expect(meta.query, \"meta.query should equal request query param\").to.eql(requestQuery);",
											"});",
											"",
											"pm.test(\"Search results shape matches meta.count and meta.limit\", function () {",
											"  const data = json.data || {};",
											"  const meta = data.meta || {};",
											"  const users = Array.isArray(data.users) ? data.users : [];",
											"",
											"  pm.expect(meta).to.have.property(\"count\");",
											"  pm.expect(meta).to.have.property(\"limit\");",
											"  pm.expect(users, \"data.users should be an array\").to.be.an(\"array\");",
											"",
											"  if (meta.count === 0) {",
											"    // When no results",
											"    try {",
											"      pm.expect(users.length, \"users must be empty when count is 0\").to.eql(0);",
											"      pm.expect(users, \"users must be an empty array\").to.eql([]);",
											"      pm.expect(data).to.have.property(\"users\");",
											"      pm.expect(meta.limit, \"meta.limit should match limit query param\").to.eql(Number(getQueryParam(\"limit\")));",
											"    } catch (err) {",
											"      console.error(\"Empty-branch validation failed:\", { meta, users, error: err && err.message });",
											"      throw err;",
											"    }",
											"  } else if (meta.count > 0) {",
											"    // When there are results",
											"    try {",
											"      pm.expect(users.length, \"users array should have length > 0 when count > 0\").to.be.greaterThan(0);",
											"      users.forEach((u, idx) => {",
											"        pm.expect(u, `user at index ${idx} should be an object`).to.be.an(\"object\");",
											"        pm.expect(u, `user at index ${idx} should have id`).to.have.property(\"id\");",
											"        pm.expect(u.name, `user.name at index ${idx} should be a string`).to.be.a(\"string\");",
											"      });",
											"    } catch (err) {",
											"      console.error(\"Non-empty-branch validation failed:\", { meta, usersPreview: users.slice(0, 3), error: err && err.message });",
											"      throw err;",
											"    }",
											"  } else {",
											"    console.error(\"Unexpected meta.count value\", meta.count);",
											"    pm.expect.fail(\"meta.count must be a non-negative integer, received: \" + meta.count);",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=nonexist&limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "nonexist"
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Search users - Successfully find user bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.expect(pm.response.code, 'Expected HTTP 200').to.eql(200);",
											"});",
											"",
											"let bodyIsJson = true;",
											"let json = {};",
											"",
											"try {",
											"    json = pm.response.json();",
											"} catch (e) {",
											"    bodyIsJson = false;",
											"}",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    pm.expect(bodyIsJson, 'Response must be valid JSON').to.be.true;",
											"});",
											"",
											"if (bodyIsJson) {",
											"    pm.test(\"Response status is success\", function () {",
											"        pm.expect(json.status, \"Expected status==='success'\").to.eql('success');",
											"    });",
											"",
											"    pm.test(\"Meta object present with required fields\", function () {",
											"        pm.expect(json).to.have.property('data');",
											"        pm.expect(json.data).to.have.property('meta');",
											"        pm.expect(json.data.meta, 'meta.query must be a string').to.have.property('query');",
											"        pm.expect(json.data.meta.query, 'meta.query must equal \\\"bob\\\"').to.eql('bob');",
											"        pm.expect(json.data.meta, 'meta.count must be a number > 0').to.have.property('count');",
											"        pm.expect(json.data.meta.count, 'meta.count must be > 0').to.be.a('number').and.to.be.greaterThan(0);",
											"    });",
											"",
											"    pm.test(\"Users array contains at least one user\", function () {",
											"        pm.expect(json.data).to.have.property('users');",
											"        pm.expect(Array.isArray(json.data.users), 'data.users must be an array').to.be.true;",
											"        pm.expect(json.data.users.length, 'data.users must have at least one entry').to.be.greaterThan(0);",
											"    });",
											"",
											"    const firstUser = (json.data && Array.isArray(json.data.users) && json.data.users[0]) || null;",
											"",
											"    pm.test(\"First user has expected login and valid UUID user_id\", function () {",
											"        pm.expect(firstUser, 'First user must exist').to.be.an('object');",
											"        pm.expect(firstUser.login, \"first user login must equal 'bob'\").to.eql('bob');",
											"        const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"        pm.expect(firstUser.user_id, 'user_id must be a valid UUID').to.match(uuidRegex);",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/users/search?query=bob&limit=20",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"users",
										"search"
									],
									"query": [
										{
											"key": "query",
											"value": "bob"
										},
										{
											"key": "limit",
											"value": "20"
										}
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Messages",
			"item": [
				{
					"name": "Send",
					"item": [
						{
							"name": "Messages Send - Empty recipient",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Response has valid status code (200 or expected errors)', function () {",
											"    pm.expect(pm.response.code).to.be.oneOf([200, 400, 401, 403, 404, 500]);",
											"});",
											"",
											"pm.test('Response has application/json content-type', function () {",
											"    pm.response.to.have.header('Content-Type');",
											"    pm.expect(pm.response.headers.get('Content-Type')).to.include('application/json');",
											"});",
											"",
											"var jsonData;",
											"try {",
											"    jsonData = pm.response.json();",
											"} catch (e) {",
											"    jsonData = null;",
											"}",
											"",
											"pm.test('Response body is valid JSON', function () {",
											"    pm.expect(jsonData, 'Response JSON').to.be.an('object');",
											"});",
											"",
											"if (pm.response.code === 200) {",
											"    pm.test('Successful send response structure', function () {",
											"        pm.expect(jsonData).to.have.property('code');",
											"        pm.expect(jsonData.code).to.be.oneOf(['SUCCESS', 'OK']);",
											"        pm.expect(jsonData).to.have.property('message');",
											"        pm.expect(jsonData.message).to.be.a('string').and.to.not.be.empty;",
											"        pm.expect(jsonData).to.have.property('recipient');",
											"        pm.expect(jsonData.recipient).to.have.property('login');",
											"    });",
											"} else if (pm.response.code === 404) {",
											"    pm.test('Recipient not found error', function () {",
											"        pm.expect(jsonData).to.have.property('code', 'USER_NOT_FOUND');",
											"        pm.expect(jsonData).to.have.property('message');",
											"        pm.expect(jsonData.message.toLowerCase()).to.include('not found');",
											"    });",
											"} else if (pm.response.code === 400) {",
											"    pm.test('Bad request structure', function () {",
											"        pm.expect(jsonData).to.have.property('code');",
											"        pm.expect(jsonData.code).to.include('INVALID');",
											"    });",
											"} else {",
											"    pm.test('Error response contains code and message', function () {",
											"        pm.expect(jsonData).to.have.property('code');",
											"        pm.expect(jsonData).to.have.property('message');",
											"    });",
											"}"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"\",\r\n  \"message\": \"alice to bob 1\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - No recipient",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Response has application/json content-type', function () {",
											"  pm.response.to.have.header('Content-Type');",
											"  var ct = pm.response.headers.get('Content-Type') || '';",
											"  pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});",
											"",
											"pm.test('Response body is valid JSON and contains expected error for INVALID_JSON', function () {",
											"  var json;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    pm.expect.fail('Response is not valid JSON');",
											"  }",
											"  pm.expect(json).to.have.property('code');",
											"  if (json.code === 'INVALID_JSON') {",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.equal('error');",
											"    pm.expect(json).to.have.property('message');",
											"  }",
											"});",
											"",
											"pm.test('400 responses should return INVALID_JSON code', function () {",
											"  if (pm.response.code === 400) {",
											"    var json = {};",
											"    try { json = pm.response.json(); } catch (e) { pm.expect.fail('Response is not valid JSON'); }",
											"    pm.expect(json.code).to.equal('MISSING_FIELDS');",
											"  } else {",
											"    pm.test.skip('Response status is not 400; skipping this check');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message\": \"alice to bob 1\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Empty message",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  function safeJsonParse(str) {",
											"    try { return JSON.parse(str); } catch (e) { return null; }",
											"  }",
											"",
											"  const reqMode = pm.request.body ? pm.request.body.mode : undefined;",
											"  let reqBodyRaw = '';",
											"  if (reqMode === 'raw') {",
											"    reqBodyRaw = pm.request.body.raw || '';",
											"  }",
											"  const parsedReqBody = safeJsonParse(reqBodyRaw) || {};",
											"",
											"  console.log('Request body (raw):', reqBodyRaw);",
											"  console.log('Request body (parsed):', parsedReqBody);",
											"  console.log('Response status:', pm.response.code);",
											"  console.log('Response body (text):', pm.response.text());",
											"",
											"  pm.test(\"Request body 'message' must not be empty\", function () {",
											"    pm.expect(parsedReqBody).to.be.an('object');",
											"    pm.expect(parsedReqBody).to.have.property('message');",
											"  });",
											"",
											"  let resJson = null;",
											"  try {",
											"    resJson = pm.response.json();",
											"  } catch (e) {",
											"    resJson = null;",
											"  }",
											"",
											"  pm.test('Status code and contract validation', function () {",
											"    pm.expect([200, 400]).to.include(pm.response.code);",
											"  });",
											"",
											"  if (pm.response.code === 200) {",
											"    pm.test('Success: response is JSON', function () {",
											"      pm.expect(resJson).to.be.an('object');",
											"    });",
											"",
											"    pm.test('Success: base fields present with correct types', function () {",
											"      pm.expect(resJson).to.have.property('code');",
											"      pm.expect(resJson.code).to.be.a('string');",
											"      pm.expect(resJson).to.have.property('message');",
											"      pm.expect(resJson.message).to.be.a('string');",
											"      pm.expect(resJson).to.have.property('status');",
											"      pm.expect(resJson.status).to.be.a('string');",
											"    });",
											"",
											"    pm.test('Success: data contains messageId and to_login with correct types', function () {",
											"      pm.expect(resJson).to.have.property('data');",
											"      pm.expect(resJson.data).to.be.an('object');",
											"      pm.expect(resJson.data).to.have.property('messageId');",
											"      pm.expect(['string', 'number']).to.include(typeof resJson.data.messageId);",
											"      pm.expect(resJson.data).to.have.property('to_login');",
											"      pm.expect(resJson.data.to_login).to.be.a('string');",
											"    });",
											"",
											"  }",
											"",
											"  if (pm.response.code === 400) {",
											"    pm.test('Error: response is JSON', function () {",
											"      pm.expect(resJson).to.be.an('object');",
											"    });",
											"",
											"    pm.test('Error: fields present with correct types', function () {",
											"      pm.expect(resJson).to.have.property('code');",
											"      pm.expect(resJson.code).to.be.a('string');",
											"      pm.expect(resJson).to.have.property('message');",
											"      pm.expect(resJson.message).to.be.a('string');",
											"      pm.expect(resJson).to.have.property('status');",
											"      pm.expect(resJson.status).to.be.a('string');",
											"    });",
											"",
											"    pm.test('Error: EMPTY_MESSAGE error has expected message', function () {",
											"      pm.expect(resJson.code).to.eql('EMPTY_MESSAGE');",
											"      pm.expect(resJson.message).to.eql('Message cannot be empty');",
											"      pm.expect(resJson.status).to.eql('error');",
											"    });",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - No message",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Response has application/json content-type', function () {\r",
											"  pm.response.to.have.header('Content-Type');\r",
											"  var ct = pm.response.headers.get('Content-Type') || '';\r",
											"  pm.expect(ct.toLowerCase()).to.include('application/json');\r",
											"});\r",
											"\r",
											"pm.test('Response body is valid JSON and contains expected error for INVALID_JSON', function () {\r",
											"  var json;\r",
											"  try {\r",
											"    json = pm.response.json();\r",
											"  } catch (e) {\r",
											"    pm.expect.fail('Response is not valid JSON');\r",
											"  }\r",
											"  pm.expect(json).to.have.property('code');\r",
											"  if (json.code === 'INVALID_JSON') {\r",
											"    pm.expect(json).to.have.property('status');\r",
											"    pm.expect(json.status).to.equal('error');\r",
											"    pm.expect(json).to.have.property('message');\r",
											"  }\r",
											"});\r",
											"\r",
											"pm.test('400 responses should return INVALID_JSON code', function () {\r",
											"  if (pm.response.code === 400) {\r",
											"    var json = {};\r",
											"    try { json = pm.response.json(); } catch (e) { pm.expect.fail('Response is not valid JSON'); }\r",
											"    pm.expect(json.code).to.equal('MISSING_FIELDS');\r",
											"  } else {\r",
											"    pm.test.skip('Response status is not 400; skipping this check');\r",
											"  }\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Empty json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Response has application/json content-type', function () {",
											"  pm.response.to.have.header('Content-Type');",
											"  var ct = pm.response.headers.get('Content-Type') || '';",
											"  pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});",
											"",
											"pm.test('Response body is valid JSON and contains expected error for INVALID_JSON', function () {",
											"  var json;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    pm.expect.fail('Response is not valid JSON');",
											"  }",
											"  pm.expect(json).to.have.property('code');",
											"  if (json.code === 'INVALID_JSON') {",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.equal('error');",
											"    pm.expect(json).to.have.property('message');",
											"  }",
											"});",
											"",
											"pm.test('400 responses should return INVALID_JSON code', function () {",
											"  if (pm.response.code === 400) {",
											"    var json = {};",
											"    try { json = pm.response.json(); } catch (e) { pm.expect.fail('Response is not valid JSON'); }",
											"    pm.expect(json.code).to.equal('MISSING_FIELDS');",
											"  } else {",
											"    pm.test.skip('Response status is not 400; skipping this check');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - No json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Response has application/json content-type', function () {",
											"  pm.response.to.have.header('Content-Type');",
											"  var ct = pm.response.headers.get('Content-Type') || '';",
											"  pm.expect(ct.toLowerCase()).to.include('application/json');",
											"});",
											"",
											"pm.test('Response body is valid JSON and contains expected error for INVALID_JSON', function () {",
											"  var json;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    pm.expect.fail('Response is not valid JSON');",
											"  }",
											"  pm.expect(json).to.have.property('code');",
											"  if (json.code === 'INVALID_JSON') {",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.equal('error');",
											"    pm.expect(json).to.have.property('message');",
											"  }",
											"});",
											"",
											"pm.test('400 responses should return INVALID_JSON code', function () {",
											"  if (pm.response.code === 400) {",
											"    var json = {};",
											"    try { json = pm.response.json(); } catch (e) { pm.expect.fail('Response is not valid JSON'); }",
											"    pm.expect(json.code).to.equal('INVALID_JSON');",
											"  } else {",
											"    pm.test.skip('Response status is not 400; skipping this check');",
											"  }",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Invalid access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjQyMzUxOTUsImlhdCI6MTc2NDIzNDI5NSwiaXNzIjoibm75YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJzdWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiYTJiOWJkNTMtNzhkMS00M2E5LWIzOTgtMjk3NzE5MzA0NDFkIn0.8IojQagJhcVK6cgBkg1sjKV_fCtg10xtzbbHz0KY4VI",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"alice to bob 1\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Empty access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"alice to bob 1\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - No access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"alice to bob 1\"\r\n}",
									"options": {
										"raw": {
											"language": "json"
										}
									}
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"    const meta = {",
											"        requestName: pm.info.requestName,",
											"        requestId: pm.info.requestId,",
											"        method: pm.request.method,",
											"        url: pm.request.url.toString(),",
											"        status: pm.response.code,",
											"        timestamp: new Date().toISOString()",
											"    };",
											"    console.log(\"[TEST META]\", JSON.stringify(meta, null, 2));",
											"",
											"    pm.test(\"Status code is 404 (Not Found)\", function () {",
											"        pm.expect(pm.response.code, `Expected 404 but got ${pm.response.code}`).to.eql(404);",
											"    });",
											"",
											"    let json;",
											"    pm.test(\"Response body is valid JSON\", function () {",
											"        try {",
											"            json = pm.response.json();",
											"            pm.expect(json, \"Parsed JSON should be an object\").to.be.an(\"object\");",
											"        } catch (err) {",
											"            console.error(\"[PARSE ERROR]\", err?.message || err);",
											"            throw new Error(\"Response body is not valid JSON: \" + (err?.message || err));",
											"        }",
											"    });",
											"",
											"    pm.test(\"Response has required string properties: code, message, status\", function () {",
											"        pm.expect(json, \"Response must be an object\").to.be.an(\"object\");",
											"        pm.expect(json, \"Missing 'code' property\").to.have.property(\"code\");",
											"        pm.expect(json.code, \"'code' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'message' property\").to.have.property(\"message\");",
											"        pm.expect(json.message, \"'message' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'status' property\").to.have.property(\"status\");",
											"        pm.expect(json.status, \"'status' must be a string\").to.be.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"status equals 'error'\", function () {",
											"        pm.expect(json.status, \"Expected status to be 'error'\").to.eql(\"error\");",
											"    });",
											"",
											"    pm.test(\"code equals 'ENDPOINT_NOT_FOUND'\", function () {",
											"        pm.expect(json.code, \"Expected code to be 'ENDPOINT_NOT_FOUND'\").to.eql(\"ENDPOINT_NOT_FOUND\");",
											"    });",
											"",
											"    try {",
											"        console.log(\"[RESPONSE BODY]\", JSON.stringify(json, null, 2));",
											"    } catch (e) {",
											"        console.log(\"[RESPONSE BODY RAW]\", pm.response.text());",
											"    }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"alice to bob 1\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - User not found",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 404\", function () {",
											"  pm.response.to.have.status(404);",
											"});",
											"",
											"let isJson = pm.response.headers.has(\"Content-Type\") &&",
											"  pm.response.headers.get(\"Content-Type\").toLowerCase().includes(\"application/json\");",
											"let bodyText = pm.response.text();",
											"let json = null;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  // leave json as null; tests below will reflect failure if not JSON",
											"}",
											"",
											"pm.test(\"Response JSON has status === 'error'\", function () {",
											"  pm.expect(isJson, \"Response is JSON\").to.be.true;",
											"  pm.expect(json).to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status).to.eql(\"error\");",
											"});",
											"",
											"pm.test(\"Response JSON code === 'USER_NOT_FOUND'\", function () {",
											"  pm.expect(isJson, \"Response is JSON\").to.be.true;",
											"  pm.expect(json).to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"code\");",
											"  pm.expect(json.code).to.eql(\"USER_NOT_FOUND\");",
											"});",
											"",
											"pm.test(\"Response message contains expected text\", function () {",
											"  const expected = \"Recipient user not found\";",
											"  if (json && typeof json === \"object\" && json.message != null) {",
											"    pm.expect(String(json.message)).to.include(expected);",
											"  } else {",
											"    pm.expect(bodyText).to.include(expected);",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"nonexist\",\r\n  \"message\": \"msg\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Self send",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function tryParseJson(text) {",
											"  try { return JSON.parse(text); } catch (e) { return null; }",
											"}",
											"",
											"const statusCode = pm.response.code;",
											"const contentType = pm.response.headers.get('Content-Type') || pm.response.headers.get('content-type') || '';",
											"const bodyText = pm.response.text();",
											"const json = tryParseJson(bodyText);",
											"",
											"pm.test('Status code is 400', function () {",
											"  pm.expect(statusCode).to.eql(400);",
											"});",
											"",
											"pm.test(\"Content-Type contains 'application/json'\", function () {",
											"  pm.response.to.have.header('Content-Type');",
											"  pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"});",
											"",
											"pm.test(\"Response body has expected error shape and values\", function () {",
											"  pm.expect(json, 'Response should be JSON').to.not.be.null;",
											"  if (json) {",
											"    pm.expect(json).to.have.property('code');",
											"    pm.expect(json).to.have.property('message');",
											"    pm.expect(json).to.have.property('status');",
											"",
											"    pm.expect(json.code).to.eql('SELF_MESSAGE');",
											"    pm.expect(json.message).to.eql('Cannot send message to yourself');",
											"    pm.expect(json.status).to.eql('error');",
											"  }",
											"});",
											"",
											"pm.test(\"If status is 'error', error code present\", function () {",
											"  if (json && json.status === 'error') {",
											"    pm.expect(json).to.have.property('code');",
											"    console.log('Error code:', json.code);",
											"  } else {",
											"    // If not error, still pass the test but no-op",
											"    pm.expect(true).to.be.true;",
											"  }",
											"});",
											"",
											"pm.test('Response is valid JSON (informational)', function () {",
											"  pm.expect(json !== null, 'Response was not valid JSON').to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"alice\",\r\n  \"message\": \"alice to alice\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Message to long",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json = null;",
											"let parseError = null;",
											"",
											"pm.test(\"Response body is valid JSON\", function () {",
											"  try {",
											"    json = pm.response.json();",
											"    pm.expect(typeof json).to.be.oneOf([\"object\", \"array\"]);",
											"  } catch (e) {",
											"    parseError = e;",
											"  }",
											"  pm.expect(parseError, parseError ? String(parseError) : \"\").to.be.null;",
											"});",
											"",
											"let expectedToLogin = null;",
											"let originalMessage = null;",
											"let originalLen = null;",
											"try {",
											"  if (pm.request && pm.request.body && pm.request.body.mode === 'raw') {",
											"    const bodyStr = pm.request.body.raw || '';",
											"    try {",
											"      const reqBody = JSON.parse(bodyStr);",
											"      expectedToLogin = reqBody.to_login || null;",
											"      originalMessage = typeof reqBody.message === 'string' ? reqBody.message : null;",
											"      originalLen = originalMessage !== null ? originalMessage.length : null;",
											"    } catch (e) {",
											"      // raw body not JSON or contains variables/truncation; ignore",
											"    }",
											"  }",
											"} catch (err) {}",
											"",
											"console.log(\"Expected to_login from request:\", expectedToLogin);",
											"console.log(\"Original message length:\", originalLen);",
											"",
											"pm.test(\"Status code is success (200/201) or known error (400)\", function () {",
											"  pm.expect(pm.response.code, `Unexpected status ${pm.response.code}`).to.be.oneOf([200, 201, 400]);",
											"});",
											"",
											"pm.test(\"API error code present when error response\", function () {",
											"  if (!json || typeof json !== 'object') {",
											"    return; // already failed parse",
											"  }",
											"  if (pm.response.code >= 400) {",
											"    pm.expect(json.code, \"Expected 'code' in error response\").to.be.oneOf([\"MESSAGE_TOO_LONG\", undefined]);",
											"    if (json.code) {",
											"      console.log(\"API error code:\", json.code);",
											"    }",
											"  } else {",
											"    pm.expect(json.code, \"Success response should not include error code\").to.be.oneOf([undefined, null]);",
											"  }",
											"});",
											"",
											"pm.test(\"Success payload contains expected fields\", function () {",
											"  if (pm.response.code === 200 || pm.response.code === 201) {",
											"    pm.expect(json, \"Response must be an object\").to.be.an(\"object\");",
											"",
											"    pm.expect([\"string\", \"number\"]).to.include(typeof json.id, \"id should be string or number\");",
											"",
											"    if (expectedToLogin !== null) {",
											"      pm.expect(json.to_login, \"to_login should match request\").to.eql(expectedToLogin);",
											"    } else {",
											"      pm.expect(json).to.have.property(\"to_login\");",
											"    }",
											"",
											"    pm.expect(json).to.have.property(\"message\");",
											"    const msg = json.message;",
											"    pm.expect(msg, \"message must be a string\").to.be.a(\"string\");",
											"    pm.expect(msg.length, \"message length must be <= 5000\").to.be.most(5000);",
											"",
											"    if (originalLen !== null && originalLen > 5000) {",
											"      pm.expect(msg.length, \"Response message should be truncated when original exceeds limit\").to.be.at.most(5000);",
											"    }",
											"  } else {",
											"    pm.expect(true).to.be.true; // skip",
											"  }",
											"});",
											"",
											"pm.test(\"Error MESSAGE_TOO_LONG has expected shape\", function () {",
											"  if (pm.response.code === 400 && json && json.code === \"MESSAGE_TOO_LONG\") {",
											"    pm.expect(json.status, \"status must be 'error'\").to.eql(\"error\");",
											"    pm.expect(json.message, \"message should describe length issue\").to.be.a(\"string\");",
											"    pm.expect(json.message.toLowerCase(), \"message should mention exceeds maximum length\").to.include(\"exceeds maximum length\");",
											"  } else {",
											"    pm.expect(true).to.be.true; // skip",
											"  }",
											"});",
											"",
											"console.log(\"[Messages Send] status:\", pm.response.code, \"errorCode:\", json && json.code, \"id:\", json && json.id);",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Successfully alice to bob 1",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  json = null;",
											"}",
											"",
											"pm.test(\"Status code is 201 Created\", function () {",
											"  pm.expect(pm.response.code, \"Expected 201 but got \" + pm.response.code).to.equal(201);",
											"});",
											"",
											"pm.test(\"Response body has top-level status = 'success'\", function () {",
											"  pm.expect(json, \"Response should be JSON\").to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.message_id is present and is a UUID\", function () {",
											"  pm.expect(json).to.have.property(\"data\");",
											"  pm.expect(json.data).to.be.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"message_id\");",
											"  const uuid = String(json.data.message_id);",
											"  const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;",
											"  pm.expect(uuidRegex.test(uuid), \"message_id should match UUID format\").to.be.true;",
											"});",
											"",
											"pm.test(\"data.sent_at exists and is a valid timestamp\", function () {",
											"  pm.expect(json).to.have.property(\"data\");",
											"  pm.expect(json.data).to.be.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"sent_at\");",
											"  const ts = String(json.data.sent_at);",
											"  ",
											"  const isoLike = /^\\d{4}-\\d{2}-\\d{2}[ T]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})?$/;",
											"  pm.expect(isoLike.test(ts), \"sent_at should look like an ISO timestamp\").to.be.true;",
											"  const d = new Date(ts.replace(\" \", \"T\")); // normalize space to 'T' for Date parsing",
											"  pm.expect(!isNaN(d.getTime()), \"sent_at should parse to a valid Date\").to.be.true;",
											"});",
											"",
											"  pm.test(\"Store sended message as variable messageIDAliceBob1\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"messageIDAliceBob1\", d.message_id);",
											"    pm.expect(pm.collectionVariables.get(\"messageIDAliceBob1\")).to.be.a(\"string\").and.not.empty;",
											"  });"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"alice to bob 1\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Successfully alice to bob 2",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  json = null;",
											"}",
											"",
											"pm.test(\"Status code is 201 Created\", function () {",
											"  pm.expect(pm.response.code, \"Expected 201 but got \" + pm.response.code).to.equal(201);",
											"});",
											"",
											"pm.test(\"Response body has top-level status = 'success'\", function () {",
											"  pm.expect(json, \"Response should be JSON\").to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.message_id is present and is a UUID\", function () {",
											"  pm.expect(json).to.have.property(\"data\");",
											"  pm.expect(json.data).to.be.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"message_id\");",
											"  const uuid = String(json.data.message_id);",
											"  const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;",
											"  pm.expect(uuidRegex.test(uuid), \"message_id should match UUID format\").to.be.true;",
											"});",
											"",
											"pm.test(\"data.sent_at exists and is a valid timestamp\", function () {",
											"  pm.expect(json).to.have.property(\"data\");",
											"  pm.expect(json.data).to.be.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"sent_at\");",
											"  const ts = String(json.data.sent_at);",
											"  ",
											"  const isoLike = /^\\d{4}-\\d{2}-\\d{2}[ T]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})?$/;",
											"  pm.expect(isoLike.test(ts), \"sent_at should look like an ISO timestamp\").to.be.true;",
											"  const d = new Date(ts.replace(\" \", \"T\")); // normalize space to 'T' for Date parsing",
											"  pm.expect(!isNaN(d.getTime()), \"sent_at should parse to a valid Date\").to.be.true;",
											"});",
											"",
											"  pm.test(\"Store sended message as variable messageIDAliceBob2\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"messageIDAliceBob2\", d.message_id);",
											"    pm.expect(pm.collectionVariables.get(\"messageIDAliceBob2\")).to.be.a(\"string\").and.not.empty;",
											"  });"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"alice to bob 2\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Send - Successfully alice to bob 3",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"let json;",
											"try {",
											"  json = pm.response.json();",
											"} catch (e) {",
											"  json = null;",
											"}",
											"",
											"pm.test(\"Status code is 201 Created\", function () {",
											"  pm.expect(pm.response.code, \"Expected 201 but got \" + pm.response.code).to.equal(201);",
											"});",
											"",
											"pm.test(\"Response body has top-level status = 'success'\", function () {",
											"  pm.expect(json, \"Response should be JSON\").to.be.an(\"object\");",
											"  pm.expect(json).to.have.property(\"status\");",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.message_id is present and is a UUID\", function () {",
											"  pm.expect(json).to.have.property(\"data\");",
											"  pm.expect(json.data).to.be.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"message_id\");",
											"  const uuid = String(json.data.message_id);",
											"  const uuidRegex = /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[1-5][0-9a-fA-F]{3}-[89abAB][0-9a-fA-F]{3}-[0-9a-fA-F]{12}$/;",
											"  pm.expect(uuidRegex.test(uuid), \"message_id should match UUID format\").to.be.true;",
											"});",
											"",
											"pm.test(\"data.sent_at exists and is a valid timestamp\", function () {",
											"  pm.expect(json).to.have.property(\"data\");",
											"  pm.expect(json.data).to.be.an(\"object\");",
											"  pm.expect(json.data).to.have.property(\"sent_at\");",
											"  const ts = String(json.data.sent_at);",
											"  ",
											"  const isoLike = /^\\d{4}-\\d{2}-\\d{2}[ T]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})?$/;",
											"  pm.expect(isoLike.test(ts), \"sent_at should look like an ISO timestamp\").to.be.true;",
											"  const d = new Date(ts.replace(\" \", \"T\")); // normalize space to 'T' for Date parsing",
											"  pm.expect(!isNaN(d.getTime()), \"sent_at should parse to a valid Date\").to.be.true;",
											"});",
											"",
											"  pm.test(\"Store sended message as variable messageIDAliceBob3\", function () {",
											"    const d = json.data;",
											"    pm.collectionVariables.set(\"messageIDAliceBob3\", d.message_id);",
											"    pm.expect(pm.collectionVariables.get(\"messageIDAliceBob3\")).to.be.a(\"string\").and.not.empty;",
											"  });"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"auth": {
									"type": "jwt",
									"jwt": [
										{
											"key": "algorithm",
											"value": "HS256",
											"type": "string"
										},
										{
											"key": "isSecretBase64Encoded",
											"value": false,
											"type": "boolean"
										},
										{
											"key": "payload",
											"value": "{}",
											"type": "string"
										},
										{
											"key": "addTokenTo",
											"value": "header",
											"type": "string"
										},
										{
											"key": "headerPrefix",
											"value": "Bearer",
											"type": "string"
										},
										{
											"key": "queryParamKey",
											"value": "token",
											"type": "string"
										},
										{
											"key": "header",
											"value": "{}",
											"type": "string"
										}
									]
								},
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"to_login\": \"bob\",\r\n  \"message\": \"alice to bob 3\"\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/send",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"send"
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Get",
					"item": [
						{
							"name": "Messages Get - Invalid unread only",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=aa",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "aa"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Empty unread only",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": ""
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Empty after message id",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?after_message_id",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "after_message_id",
											"value": null
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Empty before message id",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?before_message_id",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "before_message_id",
											"value": null
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Empty conversation with",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?conversation_with",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "conversation_with",
											"value": null
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - User not found",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?conversation_with=nonexist",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "conversation_with",
											"value": "nonexist"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Invalid limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?limit=aa",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "limit",
											"value": "aa"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Empty limit",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?limit=",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "limit",
											"value": ""
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Invalid access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjQzNTQ5MjUsImlhdCI6MTc2NDM1NDAyNSwiaXNzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJzdWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiOGNhZjUzYzQtMDUwNy00YzljLWI1ZTktMDk1YjMxODgzMDRhIn0.q1LL6i6n2OySBmPiCuzCyl3NISlJ-KU6wS_PTM4_fVi",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Empty access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - No access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Empty all params",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=&after_message_id=&before_message_id=&limit=&conversation_with=",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": ""
										},
										{
											"key": "after_message_id",
											"value": ""
										},
										{
											"key": "before_message_id",
											"value": ""
										},
										{
											"key": "limit",
											"value": ""
										},
										{
											"key": "conversation_with",
											"value": ""
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"    const meta = {",
											"        requestName: pm.info.requestName,",
											"        requestId: pm.info.requestId,",
											"        method: pm.request.method,",
											"        url: pm.request.url.toString(),",
											"        status: pm.response.code,",
											"        timestamp: new Date().toISOString()",
											"    };",
											"    console.log(\"[TEST META]\", JSON.stringify(meta, null, 2));",
											"",
											"    pm.test(\"Status code is 404 (Not Found)\", function () {",
											"        pm.expect(pm.response.code, `Expected 404 but got ${pm.response.code}`).to.eql(404);",
											"    });",
											"",
											"    let json;",
											"    pm.test(\"Response body is valid JSON\", function () {",
											"        try {",
											"            json = pm.response.json();",
											"            pm.expect(json, \"Parsed JSON should be an object\").to.be.an(\"object\");",
											"        } catch (err) {",
											"            console.error(\"[PARSE ERROR]\", err?.message || err);",
											"            throw new Error(\"Response body is not valid JSON: \" + (err?.message || err));",
											"        }",
											"    });",
											"",
											"    pm.test(\"Response has required string properties: code, message, status\", function () {",
											"        pm.expect(json, \"Response must be an object\").to.be.an(\"object\");",
											"        pm.expect(json, \"Missing 'code' property\").to.have.property(\"code\");",
											"        pm.expect(json.code, \"'code' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'message' property\").to.have.property(\"message\");",
											"        pm.expect(json.message, \"'message' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'status' property\").to.have.property(\"status\");",
											"        pm.expect(json.status, \"'status' must be a string\").to.be.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"status equals 'error'\", function () {",
											"        pm.expect(json.status, \"Expected status to be 'error'\").to.eql(\"error\");",
											"    });",
											"",
											"    pm.test(\"code equals 'ENDPOINT_NOT_FOUND'\", function () {",
											"        pm.expect(json.code, \"Expected code to be 'ENDPOINT_NOT_FOUND'\").to.eql(\"ENDPOINT_NOT_FOUND\");",
											"    });",
											"    ",
											"    try {",
											"        console.log(\"[RESPONSE BODY]\", JSON.stringify(json, null, 2));",
											"    } catch (e) {",
											"        console.log(\"[RESPONSE BODY RAW]\", pm.response.text());",
											"    }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{charlieAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Read charlie",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function isIso8601(value) {",
											"    if (typeof value !== 'string') return false;",
											"    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;",
											"    if (!isoRegex.test(value)) return false;",
											"    const d = new Date(value);",
											"    return !isNaN(d.getTime());",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response is JSON with top-level keys 'data' and 'status'\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    let json;",
											"    try {",
											"        json = pm.response.json();",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON\");",
											"    }",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json, \"missing 'data' key\").to.have.property(\"data\");",
											"    pm.expect(json, \"missing 'status' key\").to.have.property(\"status\");",
											"    pm.expect(json.status, \"status should be a string\").to.be.a(\"string\");",
											"});",
											"",
											"let body;",
											"try {",
											"    body = pm.response.json();",
											"} catch (e) {",
											"    body = {};",
											"}",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"    pm.expect(body).to.have.property(\"data\");",
											"    pm.expect(body.data).to.be.an(\"object\");",
											"    pm.expect(body.data, \"missing 'messages'\").to.have.property(\"messages\");",
											"    pm.expect(body.data.messages, \"messages should be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"data.meta has has_more(boolean), total_count(number), unread_count(number)\", function () {",
											"    pm.expect(body.data, \"missing 'meta'\").to.have.property(\"meta\");",
											"    const meta = body.data.meta;",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta, \"missing 'has_more'\").to.have.property(\"has_more\");",
											"    pm.expect(meta.has_more, \"has_more should be boolean\").to.be.a(\"boolean\");",
											"    pm.expect(meta, \"missing 'total_count'\").to.have.property(\"total_count\");",
											"    pm.expect(meta.total_count, \"total_count should be a number\").to.be.a(\"number\");",
											"    pm.expect(meta, \"missing 'unread_count'\").to.have.property(\"unread_count\");",
											"    pm.expect(meta.unread_count, \"unread_count should be a number\").to.be.a(\"number\");",
											"});",
											"",
											"pm.test(\"messages items have id(string), text(string), read(boolean), created_at(ISO 8601)\", function () {",
											"    const arr = (body && body.data && Array.isArray(body.data.messages)) ? body.data.messages : [];",
											"    if (arr.length === 0) {",
											"        console.info(\"messages array is empty; skipping per-item schema checks\");",
											"        pm.expect(arr.length, \"No messages to validate\").to.be.a(\"number\");",
											"        return;",
											"    }",
											"    arr.forEach((msg, idx) => {",
											"        pm.expect(msg, `message[${idx}] should be an object`).to.be.an(\"object\");",
											"        pm.expect(msg, `message[${idx}] missing id`).to.have.property(\"id\");",
											"        pm.expect(msg.id, `message[${idx}].id should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing text`).to.have.property(\"text\");",
											"        pm.expect(msg.text, `message[${idx}].text should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing read`).to.have.property(\"read\");",
											"        pm.expect(msg.read, `message[${idx}].read should be boolean`).to.be.a(\"boolean\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing created_at`).to.have.property(\"created_at\");",
											"        pm.expect(isIso8601(msg.created_at), `message[${idx}].created_at should be ISO 8601 timestamp`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{charlieAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Successfully read alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Successfully read bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Unread only true alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function isIso8601(value) {",
											"    if (typeof value !== 'string') return false;",
											"    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;",
											"    if (!isoRegex.test(value)) return false;",
											"    const d = new Date(value);",
											"    return !isNaN(d.getTime());",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response is JSON with top-level keys 'data' and 'status'\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    let json;",
											"    try {",
											"        json = pm.response.json();",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON\");",
											"    }",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json, \"missing 'data' key\").to.have.property(\"data\");",
											"    pm.expect(json, \"missing 'status' key\").to.have.property(\"status\");",
											"    pm.expect(json.status, \"status should be a string\").to.be.a(\"string\");",
											"});",
											"",
											"let body;",
											"try {",
											"    body = pm.response.json();",
											"} catch (e) {",
											"    body = {};",
											"}",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"    pm.expect(body).to.have.property(\"data\");",
											"    pm.expect(body.data).to.be.an(\"object\");",
											"    pm.expect(body.data, \"missing 'messages'\").to.have.property(\"messages\");",
											"    pm.expect(body.data.messages, \"messages should be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"data.meta has has_more(boolean), total_count(number), unread_count(number)\", function () {",
											"    pm.expect(body.data, \"missing 'meta'\").to.have.property(\"meta\");",
											"    const meta = body.data.meta;",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta, \"missing 'has_more'\").to.have.property(\"has_more\");",
											"    pm.expect(meta.has_more, \"has_more should be boolean\").to.be.a(\"boolean\");",
											"    pm.expect(meta, \"missing 'total_count'\").to.have.property(\"total_count\");",
											"    pm.expect(meta.total_count, \"total_count should be a number\").to.be.a(\"number\");",
											"    pm.expect(meta, \"missing 'unread_count'\").to.have.property(\"unread_count\");",
											"    pm.expect(meta.unread_count, \"unread_count should be a number\").to.be.a(\"number\");",
											"});",
											"",
											"pm.test(\"messages items have id(string), text(string), read(boolean), created_at(ISO 8601)\", function () {",
											"    const arr = (body && body.data && Array.isArray(body.data.messages)) ? body.data.messages : [];",
											"    if (arr.length === 0) {",
											"        console.info(\"messages array is empty; skipping per-item schema checks\");",
											"        pm.expect(arr.length, \"No messages to validate\").to.be.a(\"number\");",
											"        return;",
											"    }",
											"    arr.forEach((msg, idx) => {",
											"        pm.expect(msg, `message[${idx}] should be an object`).to.be.an(\"object\");",
											"        pm.expect(msg, `message[${idx}] missing id`).to.have.property(\"id\");",
											"        pm.expect(msg.id, `message[${idx}].id should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing text`).to.have.property(\"text\");",
											"        pm.expect(msg.text, `message[${idx}].text should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing read`).to.have.property(\"read\");",
											"        pm.expect(msg.read, `message[${idx}].read should be boolean`).to.be.a(\"boolean\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing created_at`).to.have.property(\"created_at\");",
											"        pm.expect(isIso8601(msg.created_at), `message[${idx}].created_at should be ISO 8601 timestamp`).to.be.true;",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Unread only true bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Unread only false alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=false",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "false"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Unread only false bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=false",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "false"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - After message id 1 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function isIso8601(value) {\r",
											"    if (typeof value !== 'string') return false;\r",
											"    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;\r",
											"    if (!isoRegex.test(value)) return false;\r",
											"    const d = new Date(value);\r",
											"    return !isNaN(d.getTime());\r",
											"}\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response is JSON with top-level keys 'data' and 'status'\", function () {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"    let json;\r",
											"    try {\r",
											"        json = pm.response.json();\r",
											"    } catch (e) {\r",
											"        pm.expect.fail(\"Response body is not valid JSON\");\r",
											"    }\r",
											"    pm.expect(json).to.be.an(\"object\");\r",
											"    pm.expect(json, \"missing 'data' key\").to.have.property(\"data\");\r",
											"    pm.expect(json, \"missing 'status' key\").to.have.property(\"status\");\r",
											"    pm.expect(json.status, \"status should be a string\").to.be.a(\"string\");\r",
											"});\r",
											"\r",
											"let body;\r",
											"try {\r",
											"    body = pm.response.json();\r",
											"} catch (e) {\r",
											"    body = {};\r",
											"}\r",
											"\r",
											"pm.test(\"data.messages is an array\", function () {\r",
											"    pm.expect(body).to.have.property(\"data\");\r",
											"    pm.expect(body.data).to.be.an(\"object\");\r",
											"    pm.expect(body.data, \"missing 'messages'\").to.have.property(\"messages\");\r",
											"    pm.expect(body.data.messages, \"messages should be an array\").to.be.an(\"array\");\r",
											"});\r",
											"\r",
											"pm.test(\"data.meta has has_more(boolean), total_count(number), unread_count(number)\", function () {\r",
											"    pm.expect(body.data, \"missing 'meta'\").to.have.property(\"meta\");\r",
											"    const meta = body.data.meta;\r",
											"    pm.expect(meta).to.be.an(\"object\");\r",
											"    pm.expect(meta, \"missing 'has_more'\").to.have.property(\"has_more\");\r",
											"    pm.expect(meta.has_more, \"has_more should be boolean\").to.be.a(\"boolean\");\r",
											"    pm.expect(meta, \"missing 'total_count'\").to.have.property(\"total_count\");\r",
											"    pm.expect(meta.total_count, \"total_count should be a number\").to.be.a(\"number\");\r",
											"    pm.expect(meta, \"missing 'unread_count'\").to.have.property(\"unread_count\");\r",
											"    pm.expect(meta.unread_count, \"unread_count should be a number\").to.be.a(\"number\");\r",
											"});\r",
											"\r",
											"pm.test(\"messages items have id(string), text(string), read(boolean), created_at(ISO 8601)\", function () {\r",
											"    const arr = (body && body.data && Array.isArray(body.data.messages)) ? body.data.messages : [];\r",
											"    if (arr.length === 0) {\r",
											"        console.info(\"messages array is empty; skipping per-item schema checks\");\r",
											"        pm.expect(arr.length, \"No messages to validate\").to.be.a(\"number\");\r",
											"        return;\r",
											"    }\r",
											"    arr.forEach((msg, idx) => {\r",
											"        pm.expect(msg, `message[${idx}] should be an object`).to.be.an(\"object\");\r",
											"        pm.expect(msg, `message[${idx}] missing message_id`).to.have.property(\"message_id\");\r",
											"        pm.expect(msg.message_id, `message[${idx}].id should be string`).to.be.a(\"string\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing message_text`).to.have.property(\"message_text\");\r",
											"        pm.expect(msg.message_text, `message[${idx}].text should be string`).to.be.a(\"string\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing is_read`).to.have.property(\"is_read\");\r",
											"        pm.expect(msg.is_read, `message[${idx}].read should be boolean`).to.be.a(\"boolean\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing timestamp`).to.have.property(\"timestamp\");\r",
											"        pm.expect(msg.timestamp, `message[${idx}].text should be string`).to.be.a(\"string\");\r",
											"    });\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								},
								{
									"listen": "prerequest",
									"script": {
										"exec": [
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&after_message_id={{messageIDAliceBob2}}",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "after_message_id",
											"value": "{{messageIDAliceBob2}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - After message id 2 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function isIso8601(value) {",
											"    if (typeof value !== 'string') return false;",
											"    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;",
											"    if (!isoRegex.test(value)) return false;",
											"    const d = new Date(value);",
											"    return !isNaN(d.getTime());",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response is JSON with top-level keys 'data' and 'status'\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    let json;",
											"    try {",
											"        json = pm.response.json();",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON\");",
											"    }",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json, \"missing 'data' key\").to.have.property(\"data\");",
											"    pm.expect(json, \"missing 'status' key\").to.have.property(\"status\");",
											"    pm.expect(json.status, \"status should be a string\").to.be.a(\"string\");",
											"});",
											"",
											"let body;",
											"try {",
											"    body = pm.response.json();",
											"} catch (e) {",
											"    body = {};",
											"}",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"    pm.expect(body).to.have.property(\"data\");",
											"    pm.expect(body.data).to.be.an(\"object\");",
											"    pm.expect(body.data, \"missing 'messages'\").to.have.property(\"messages\");",
											"    pm.expect(body.data.messages, \"messages should be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"data.meta has has_more(boolean), total_count(number), unread_count(number)\", function () {",
											"    pm.expect(body.data, \"missing 'meta'\").to.have.property(\"meta\");",
											"    const meta = body.data.meta;",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta, \"missing 'has_more'\").to.have.property(\"has_more\");",
											"    pm.expect(meta.has_more, \"has_more should be boolean\").to.be.a(\"boolean\");",
											"    pm.expect(meta, \"missing 'total_count'\").to.have.property(\"total_count\");",
											"    pm.expect(meta.total_count, \"total_count should be a number\").to.be.a(\"number\");",
											"    pm.expect(meta, \"missing 'unread_count'\").to.have.property(\"unread_count\");",
											"    pm.expect(meta.unread_count, \"unread_count should be a number\").to.be.a(\"number\");",
											"});",
											"",
											"pm.test(\"messages items have id(string), text(string), read(boolean), created_at(ISO 8601)\", function () {",
											"    const arr = (body && body.data && Array.isArray(body.data.messages)) ? body.data.messages : [];",
											"    if (arr.length === 0) {",
											"        console.info(\"messages array is empty; skipping per-item schema checks\");",
											"        pm.expect(arr.length, \"No messages to validate\").to.be.a(\"number\");",
											"        return;",
											"    }",
											"    arr.forEach((msg, idx) => {",
											"        pm.expect(msg, `message[${idx}] should be an object`).to.be.an(\"object\");",
											"        pm.expect(msg, `message[${idx}] missing message_id`).to.have.property(\"message_id\");",
											"        pm.expect(msg.message_id, `message[${idx}].id should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing message_text`).to.have.property(\"message_text\");",
											"        pm.expect(msg.message_text, `message[${idx}].text should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing is_read`).to.have.property(\"is_read\");",
											"        pm.expect(msg.is_read, `message[${idx}].read should be boolean`).to.be.a(\"boolean\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing timestamp`).to.have.property(\"timestamp\");",
											"        pm.expect(msg.timestamp, `message[${idx}].text should be string`).to.be.a(\"string\");",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&after_message_id={{messageIDAliceBob2}}",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "after_message_id",
											"value": "{{messageIDAliceBob2}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - After message id 3 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an(\"object\", \"Top-level response should be an object\");",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"Top-level status should equal 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"    pm.expect(json).to.have.property(\"data\").that.is.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\").that.is.an(\"array\");",
											"});",
											"",
											"function isUUID(v) {",
											"    return /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i.test(v);",
											"}",
											"",
											"function isIsoOrPgTimestamp(v) {",
											"    if (typeof v !== 'string') return false;",
											"    const iso = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;",
											"    const pg = /^\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:[+-]\\d{2})?$/;",
											"    return iso.test(v) || pg.test(v);",
											"}",
											"",
											"pm.test(\"Each message has required fields and valid types\", function () {",
											"    const msgs = json.data.messages;",
											"    msgs.forEach((m, idx) => {",
											"        pm.expect(m, `message[${idx}] should be an object`).to.be.an(\"object\");",
											"        [\"from_login\",\"from_user_id\",\"is_read\",\"message_id\",\"message_text\",\"timestamp\",\"to_login\",\"to_user_id\"].forEach(k => {",
											"            pm.expect(m, `message[${idx}] missing key '${k}'`).to.have.property(k);",
											"        });",
											"        pm.expect(m.is_read, `message[${idx}].is_read should be boolean`).to.be.a(\"boolean\");",
											"        pm.expect(m.message_id && isUUID(m.message_id), `message[${idx}].message_id must be a UUID`).to.be.true;",
											"        pm.expect(isIsoOrPgTimestamp(m.timestamp), `message[${idx}].timestamp must be ISO8601 or Postgres format`).to.be.true;",
											"        [\"from_login\",\"to_login\",\"message_text\"].forEach(k => {",
											"            pm.expect(m[k], `message[${idx}].${k} should be a non-empty string`).to.be.a(\"string\").and.not.empty;",
											"        });",
											"        [\"from_user_id\",\"to_user_id\"].forEach(k => {",
											"            pm.expect(m[k] && isUUID(m[k]), `message[${idx}].${k} must be a UUID`).to.be.true;",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta object exists with required fields and types\", function () {",
											"    pm.expect(json.data).to.have.property(\"meta\").that.is.an(\"object\");",
											"    const meta = json.data.meta;",
											"    [\"has_more\",\"total_count\",\"unread_count\"].forEach(k => {",
											"        pm.expect(meta, `meta missing key '${k}'`).to.have.property(k);",
											"    });",
											"    pm.expect(meta.has_more, \"meta.has_more must be boolean\").to.be.a(\"boolean\");",
											"    pm.expect(meta.total_count, \"meta.total_count must be a number\").to.be.a(\"number\");",
											"    pm.expect(meta.unread_count, \"meta.unread_count must be a number\").to.be.a(\"number\");",
											"});",
											"",
											"pm.test(\"If unread_only=true then all messages must be unread\", function () {",
											"    const url = pm.request.url.toString();",
											"    const isUnreadOnly = /[?&]unread_only=true(?:&|$)/.test(url);",
											"    if (isUnreadOnly) {",
											"        const msgs = json.data.messages;",
											"        const allUnread = msgs.every(m => m.is_read === false);",
											"        pm.expect(allUnread, \"All messages must have is_read=false when unread_only=true\").to.be.true;",
											"    } else {",
											"        pm.expect(true, \"unread_only not set to true; skipping assertion\").to.be.true;",
											"    }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&after_message_id={{messageIDAliceBob3}}",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "after_message_id",
											"value": "{{messageIDAliceBob3}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Before message id 1 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON\", function () {",
											"    json = pm.response.json();",
											"    pm.expect(json).to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status).to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data).to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages).to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"Each message has required fields\", function () {",
											"    const required = [\"message_id\", \"message_text\", \"from_login\", \"to_login\", \"timestamp\", \"is_read\"];",
											"    pm.expect(json.data.messages).to.be.an(\"array\");",
											"    json.data.messages.forEach((msg, idx) => {",
											"        pm.expect(msg, `message at index ${idx} is an object`).to.be.an(\"object\");",
											"        required.forEach((k) => {",
											"            pm.expect(msg, `missing field ${k} at index ${idx}`).to.have.property(k);",
											"        });",
											"",
											"        if (msg.message_id !== undefined) pm.expect(msg.message_id).to.be.a(\"string\");",
											"        if (msg.message_text !== undefined) pm.expect(msg.message_text).to.be.a(\"string\");",
											"        if (msg.from_login !== undefined) pm.expect(msg.from_login).to.be.a(\"string\");",
											"        if (msg.to_login !== undefined) pm.expect(msg.to_login).to.be.a(\"string\");",
											"        if (msg.timestamp !== undefined) pm.expect(msg.timestamp).to.be.a(\"string\");",
											"        if (msg.is_read !== undefined) pm.expect(msg.is_read).to.be.a(\"boolean\");",
											"    });",
											"});",
											"",
											"pm.test(\"meta totals are consistent\", function () {",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    const meta = json.data.meta;",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta).to.have.property(\"unread_count\");",
											"    pm.expect(meta.unread_count).to.be.a(\"number\");",
											"    pm.expect(meta.unread_count).to.be.at.least(0);",
											"",
											"    pm.expect(meta).to.have.property(\"total_count\");",
											"    pm.expect(meta.total_count).to.be.a(\"number\");",
											"",
											"    const msgsLen = Array.isArray(json.data.messages) ? json.data.messages.length : NaN;",
											"    if (Number.isFinite(msgsLen)) {",
											"        pm.expect(meta.total_count, `Mismatch: total_count=${meta.total_count}, messages.length=${msgsLen}`).to.eql(msgsLen);",
											"    }",
											"});",
											"",
											"pm.test(\"When unread_only=true, all messages are unread\", function () {",
											"    const url = new URL(pm.request.url.toString());",
											"    const unreadOnly = url.searchParams.get(\"unread_only\");",
											"    if (unreadOnly && unreadOnly.toString().toLowerCase() === \"true\") {",
											"        json.data.messages.forEach((msg, idx) => {",
											"            pm.expect(msg.is_read, `Message at index ${idx} is_read should be false when unread_only=true`).to.eql(false);",
											"        });",
											"    } else {",
											"        pm.expect(true, \"unread_only not true - condition not applicable\").to.be.true;",
											"    }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&before_message_id={{messageIDAliceBob1}}",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "before_message_id",
											"value": "{{messageIDAliceBob1}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Before message id 2 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function(){",
											"  const requestUrl = pm.request.url.toString();",
											"  const hasUnreadOnly = /[?&]unread_only=true(?![^&])/i.test(requestUrl);",
											"",
											"  let json;",
											"  pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"  });",
											"",
											"  pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"      json = pm.response.json();",
											"      pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"      console.log(\"Failed to parse JSON. Raw body:\", pm.response.text());",
											"      throw e;",
											"    }",
											"  });",
											"",
											"  if (typeof json !== 'object' || json === null) {",
											"    console.log(\"Response body (non-JSON):\", pm.response.text());",
											"    return;",
											"  }",
											"",
											"  pm.test(\"Top-level status is 'success'\", function(){",
											"    pm.expect(json).to.have.property('status');",
											"    pm.expect(json.status).to.eql('success');",
											"  });",
											"",
											"  pm.test(\"data.messages is an array\", function(){",
											"    pm.expect(json).to.have.property('data');",
											"    pm.expect(json.data).to.be.an('object');",
											"    pm.expect(json.data).to.have.property('messages');",
											"    pm.expect(json.data.messages).to.be.an('array');",
											"  });",
											"",
											"  const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"  const uuidV4Regex = /^[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$/i;",
											"  const isoOrSqlTsRegex = /^(?:\\d{4}-\\d{2}-\\d{2}[ T]\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})?|\\d{4}-\\d{2}-\\d{2} \\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})?(?:\\+\\d{2})?)$/;",
											"",
											"  pm.test(\"Each message has required fields and valid types\", function(){",
											"    messages.forEach((m, i) => {",
											"      pm.expect(m, `message[${i}]`).to.be.an('object');",
											"      ['from_login','from_user_id','is_read','message_id','message_text','timestamp','to_login','to_user_id']",
											"        .forEach(k => pm.expect(m, `message[${i}] missing ${k}`).to.have.property(k));",
											"",
											"      pm.expect(m.from_login, `message[${i}].from_login`).to.be.a('string');",
											"      pm.expect(m.to_login, `message[${i}].to_login`).to.be.a('string');",
											"",
											"      pm.expect(m.from_user_id, `message[${i}].from_user_id`).to.be.a('string');",
											"      pm.expect(m.to_user_id, `message[${i}].to_user_id`).to.be.a('string');",
											"",
											"      pm.expect(m.is_read, `message[${i}].is_read`).to.be.a('boolean');",
											"",
											"      pm.expect(m.message_id, `message[${i}].message_id`).to.be.a('string');",
											"      pm.expect(uuidV4Regex.test(m.message_id), `message[${i}].message_id is UUID`).to.be.true;",
											"",
											"      pm.expect(m.message_text, `message[${i}].message_text`).to.be.a('string');",
											"      pm.expect(m.message_text.trim().length > 0, `message[${i}].message_text non-empty`).to.be.true;",
											"",
											"      pm.expect(m.timestamp, `message[${i}].timestamp`).to.be.a('string');",
											"      pm.expect(isoOrSqlTsRegex.test(m.timestamp), `message[${i}].timestamp ISO8601/SQL`).to.be.true;",
											"",
											"      const lowerKeys = Object.keys(m).map(k => k.toLowerCase());",
											"      pm.expect(lowerKeys.includes('password'), `message[${i}] must not include password`).to.be.false;",
											"      pm.expect(lowerKeys.includes('token'), `message[${i}] must not include token`).to.be.false;",
											"    });",
											"  });",
											"",
											"  pm.test(\"data.meta has required pagination fields\", function(){",
											"    pm.expect(json.data).to.have.property('meta');",
											"    pm.expect(json.data.meta).to.be.an('object');",
											"",
											"    const meta = json.data.meta;",
											"    pm.expect(meta).to.have.property('has_more');",
											"    pm.expect(meta.has_more).to.be.a('boolean');",
											"",
											"    pm.expect(meta).to.have.property('total_count');",
											"    pm.expect(meta.total_count).to.satisfy(v => typeof v === 'number');",
											"",
											"    pm.expect(meta).to.have.property('unread_count');",
											"    pm.expect(meta.unread_count).to.satisfy(v => typeof v === 'number');",
											"  });",
											"",
											"  pm.test(\"Unread filter honored when unread_only=true\", function(){",
											"    if (hasUnreadOnly) {",
											"      messages.forEach((m, i) => {",
											"        pm.expect(m.is_read, `message[${i}] should be unread due to filter`).to.eql(false);",
											"      });",
											"    } else {",
											"      pm.expect(true).to.be.true; // Not applicable",
											"    }",
											"  });",
											"",
											"  pm.test(\"Debug: Log response when any previous test failed\", function(){",
											"    const failed = _.some(pm.tests, (v) => v === false);",
											"    if (failed) {",
											"      console.log(\"One or more tests failed. Response body:\", pm.response.text());",
											"      console.log(\"Request URL:\", requestUrl);",
											"    }",
											"    pm.expect(true).to.be.true; // keep this test green so runner continues",
											"  });",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&before_message_id={{messageIDAliceBob2}}",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "before_message_id",
											"value": "{{messageIDAliceBob2}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Before message id 3 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function isIso8601(value) {",
											"    if (typeof value !== 'string') return false;",
											"    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;",
											"    if (!isoRegex.test(value)) return false;",
											"    const d = new Date(value);",
											"    return !isNaN(d.getTime());",
											"}",
											"",
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response is JSON with top-level keys 'data' and 'status'\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    let json;",
											"    try {",
											"        json = pm.response.json();",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON\");",
											"    }",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json, \"missing 'data' key\").to.have.property(\"data\");",
											"    pm.expect(json, \"missing 'status' key\").to.have.property(\"status\");",
											"    pm.expect(json.status, \"status should be a string\").to.be.a(\"string\");",
											"});",
											"",
											"let body;",
											"try {",
											"    body = pm.response.json();",
											"} catch (e) {",
											"    body = {};",
											"}",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"    pm.expect(body).to.have.property(\"data\");",
											"    pm.expect(body.data).to.be.an(\"object\");",
											"    pm.expect(body.data, \"missing 'messages'\").to.have.property(\"messages\");",
											"    pm.expect(body.data.messages, \"messages should be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"data.meta has has_more(boolean), total_count(number), unread_count(number)\", function () {",
											"    pm.expect(body.data, \"missing 'meta'\").to.have.property(\"meta\");",
											"    const meta = body.data.meta;",
											"    pm.expect(meta).to.be.an(\"object\");",
											"    pm.expect(meta, \"missing 'has_more'\").to.have.property(\"has_more\");",
											"    pm.expect(meta.has_more, \"has_more should be boolean\").to.be.a(\"boolean\");",
											"    pm.expect(meta, \"missing 'total_count'\").to.have.property(\"total_count\");",
											"    pm.expect(meta.total_count, \"total_count should be a number\").to.be.a(\"number\");",
											"    pm.expect(meta, \"missing 'unread_count'\").to.have.property(\"unread_count\");",
											"    pm.expect(meta.unread_count, \"unread_count should be a number\").to.be.a(\"number\");",
											"});",
											"",
											"pm.test(\"messages items have id(string), text(string), read(boolean), created_at(ISO 8601)\", function () {",
											"    const arr = (body && body.data && Array.isArray(body.data.messages)) ? body.data.messages : [];",
											"    if (arr.length === 0) {",
											"        console.info(\"messages array is empty; skipping per-item schema checks\");",
											"        pm.expect(arr.length, \"No messages to validate\").to.be.a(\"number\");",
											"        return;",
											"    }",
											"    arr.forEach((msg, idx) => {",
											"        pm.expect(msg, `message[${idx}] should be an object`).to.be.an(\"object\");",
											"        pm.expect(msg, `message[${idx}] missing message_id`).to.have.property(\"message_id\");",
											"        pm.expect(msg.message_id, `message[${idx}].id should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing message_text`).to.have.property(\"message_text\");",
											"        pm.expect(msg.message_text, `message[${idx}].text should be string`).to.be.a(\"string\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing is_read`).to.have.property(\"is_read\");",
											"        pm.expect(msg.is_read, `message[${idx}].read should be boolean`).to.be.a(\"boolean\");",
											"",
											"        pm.expect(msg, `message[${idx}] missing timestamp`).to.have.property(\"timestamp\");",
											"        pm.expect(msg.timestamp, `message[${idx}].text should be string`).to.be.a(\"string\");",
											"    });",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&before_message_id={{messageIDAliceBob3}}",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "before_message_id",
											"value": "{{messageIDAliceBob3}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Before After messages bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('Response is valid JSON and status is success', function () {",
											"  pm.response.to.be.json;",
											"  var json = pm.response.json();",
											"  pm.expect(json).to.have.property('status');",
											"  pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test('Data.messages is an array', function () {",
											"  var json = pm.response.json();",
											"  pm.expect(json).to.have.property('data');",
											"  pm.expect(json.data).to.have.property('messages');",
											"  pm.expect(Array.isArray(json.data.messages)).to.be.true;",
											"});",
											"",
											"pm.test('Each message has required fields with expected types', function () {",
											"  var json = pm.response.json();",
											"  var messages = json.data.messages || [];",
											"  messages.forEach(function (msg, idx) {",
											"    pm.expect(msg, 'message at index ' + idx + ' should be an object').to.be.an('object');",
											"    pm.expect(msg).to.have.property('message_id');",
											"    pm.expect(msg.message_id, 'message_id should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('from_login');",
											"    pm.expect(msg.from_login, 'from_login should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('to_login');",
											"    pm.expect(msg.to_login, 'to_login should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('message_text');",
											"    pm.expect(msg.message_text, 'message_text should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('timestamp');",
											"    pm.expect(msg.timestamp, 'timestamp should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('is_read');",
											"    pm.expect(msg.is_read, 'is_read must be boolean for message index ' + idx).to.be.a('boolean');",
											"  });",
											"});",
											"",
											"pm.test('Meta object exists and has required fields', function () {",
											"  var json = pm.response.json();",
											"  pm.expect(json).to.have.property('data');",
											"  pm.expect(json.data).to.have.property('meta');",
											"  var meta = json.data.meta;",
											"  pm.expect(meta, 'meta should be an object').to.be.an('object');",
											"  pm.expect(meta).to.have.property('has_more');",
											"  pm.expect(meta.has_more, 'has_more should be boolean').to.be.a('boolean');",
											"  pm.expect(meta).to.have.property('total_count');",
											"  pm.expect(meta.total_count, 'total_count should be a number').to.be.a('number');",
											"  pm.expect(meta).to.have.property('unread_count');",
											"  pm.expect(meta.unread_count, 'unread_count should be a number').to.be.a('number');",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&before_message_id={{messageIDAliceBob2}}&after_message_id={{messageIDAliceBob3}}",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "before_message_id",
											"value": "{{messageIDAliceBob2}}"
										},
										{
											"key": "after_message_id",
											"value": "{{messageIDAliceBob3}}"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Conversation with alice",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"let json;\r",
											"pm.test(\"Response is valid JSON\", function () {\r",
											"    try {\r",
											"        json = pm.response.json();\r",
											"        pm.expect(json).to.be.an(\"object\");\r",
											"    } catch (e) {\r",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);\r",
											"    }\r",
											"});\r",
											"\r",
											"pm.test(\"Top-level status is 'success'\", function () {\r",
											"    pm.expect(json).to.have.property(\"status\");\r",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");\r",
											"});\r",
											"\r",
											"pm.test(\"data.messages is an array and meta present\", function () {\r",
											"    pm.expect(json).to.have.property(\"data\");\r",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");\r",
											"    pm.expect(json.data).to.have.property(\"messages\");\r",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");\r",
											"    pm.expect(json.data).to.have.property(\"meta\");\r",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");\r",
											"});\r",
											"\r",
											"pm.test(\"messages length equals meta.total_count\", function () {\r",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];\r",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;\r",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;\r",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);\r",
											"});\r",
											"\r",
											"pm.test(\"Each message has required fields with correct types\", function () {\r",
											"    const requiredFields = [\r",
											"        { key: \"message_id\", type: \"string\" },\r",
											"        { key: \"from_user_id\", type: \"string\" },\r",
											"        { key: \"to_user_id\", type: \"string\" },\r",
											"        { key: \"message_text\", type: \"string\" },\r",
											"        { key: \"timestamp\", type: \"string\" },\r",
											"        { key: \"is_read\", type: \"boolean\" }\r",
											"    ];\r",
											"\r",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];\r",
											"\r",
											"    messages.forEach((msg, index) => {\r",
											"        requiredFields.forEach(field => {\r",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);\r",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);\r",
											"            if (field.type === \"string\") {\r",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);\r",
											"            }\r",
											"        });\r",
											"    });\r",
											"});\r",
											"\r",
											"pm.test(\"meta.has_more is boolean\", function () {\r",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;\r",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;\r",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?conversation_with=alice",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "conversation_with",
											"value": "alice"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Conversation with bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function isIso8601(value) {\r",
											"    if (typeof value !== 'string') return false;\r",
											"    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;\r",
											"    if (!isoRegex.test(value)) return false;\r",
											"    const d = new Date(value);\r",
											"    return !isNaN(d.getTime());\r",
											"}\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response is JSON with top-level keys 'data' and 'status'\", function () {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"    let json;\r",
											"    try {\r",
											"        json = pm.response.json();\r",
											"    } catch (e) {\r",
											"        pm.expect.fail(\"Response body is not valid JSON\");\r",
											"    }\r",
											"    pm.expect(json).to.be.an(\"object\");\r",
											"    pm.expect(json, \"missing 'data' key\").to.have.property(\"data\");\r",
											"    pm.expect(json, \"missing 'status' key\").to.have.property(\"status\");\r",
											"    pm.expect(json.status, \"status should be a string\").to.be.a(\"string\");\r",
											"});\r",
											"\r",
											"let body;\r",
											"try {\r",
											"    body = pm.response.json();\r",
											"} catch (e) {\r",
											"    body = {};\r",
											"}\r",
											"\r",
											"pm.test(\"data.messages is an array\", function () {\r",
											"    pm.expect(body).to.have.property(\"data\");\r",
											"    pm.expect(body.data).to.be.an(\"object\");\r",
											"    pm.expect(body.data, \"missing 'messages'\").to.have.property(\"messages\");\r",
											"    pm.expect(body.data.messages, \"messages should be an array\").to.be.an(\"array\");\r",
											"});\r",
											"\r",
											"pm.test(\"data.meta has has_more(boolean), total_count(number), unread_count(number)\", function () {\r",
											"    pm.expect(body.data, \"missing 'meta'\").to.have.property(\"meta\");\r",
											"    const meta = body.data.meta;\r",
											"    pm.expect(meta).to.be.an(\"object\");\r",
											"    pm.expect(meta, \"missing 'has_more'\").to.have.property(\"has_more\");\r",
											"    pm.expect(meta.has_more, \"has_more should be boolean\").to.be.a(\"boolean\");\r",
											"    pm.expect(meta, \"missing 'total_count'\").to.have.property(\"total_count\");\r",
											"    pm.expect(meta.total_count, \"total_count should be a number\").to.be.a(\"number\");\r",
											"    pm.expect(meta, \"missing 'unread_count'\").to.have.property(\"unread_count\");\r",
											"    pm.expect(meta.unread_count, \"unread_count should be a number\").to.be.a(\"number\");\r",
											"});\r",
											"\r",
											"pm.test(\"messages items have id(string), text(string), read(boolean), created_at(ISO 8601)\", function () {\r",
											"    const arr = (body && body.data && Array.isArray(body.data.messages)) ? body.data.messages : [];\r",
											"    if (arr.length === 0) {\r",
											"        console.info(\"messages array is empty; skipping per-item schema checks\");\r",
											"        pm.expect(arr.length, \"No messages to validate\").to.be.a(\"number\");\r",
											"        return;\r",
											"    }\r",
											"    arr.forEach((msg, idx) => {\r",
											"        pm.expect(msg, `message[${idx}] should be an object`).to.be.an(\"object\");\r",
											"        pm.expect(msg, `message[${idx}] missing id`).to.have.property(\"id\");\r",
											"        pm.expect(msg.id, `message[${idx}].id should be string`).to.be.a(\"string\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing text`).to.have.property(\"text\");\r",
											"        pm.expect(msg.text, `message[${idx}].text should be string`).to.be.a(\"string\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing read`).to.have.property(\"read\");\r",
											"        pm.expect(msg.read, `message[${idx}].read should be boolean`).to.be.a(\"boolean\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing created_at`).to.have.property(\"created_at\");\r",
											"        pm.expect(isIso8601(msg.created_at), `message[${idx}].created_at should be ISO 8601 timestamp`).to.be.true;\r",
											"    });\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?conversation_with=bob",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "conversation_with",
											"value": "bob"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Conversation with charlie",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"function isIso8601(value) {\r",
											"    if (typeof value !== 'string') return false;\r",
											"    const isoRegex = /^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(?:\\.\\d+)?(?:Z|[+-]\\d{2}:?\\d{2})$/;\r",
											"    if (!isoRegex.test(value)) return false;\r",
											"    const d = new Date(value);\r",
											"    return !isNaN(d.getTime());\r",
											"}\r",
											"\r",
											"pm.test(\"Status code is 200\", function () {\r",
											"    pm.response.to.have.status(200);\r",
											"});\r",
											"\r",
											"pm.test(\"Response is JSON with top-level keys 'data' and 'status'\", function () {\r",
											"    pm.response.to.have.header(\"Content-Type\");\r",
											"    let json;\r",
											"    try {\r",
											"        json = pm.response.json();\r",
											"    } catch (e) {\r",
											"        pm.expect.fail(\"Response body is not valid JSON\");\r",
											"    }\r",
											"    pm.expect(json).to.be.an(\"object\");\r",
											"    pm.expect(json, \"missing 'data' key\").to.have.property(\"data\");\r",
											"    pm.expect(json, \"missing 'status' key\").to.have.property(\"status\");\r",
											"    pm.expect(json.status, \"status should be a string\").to.be.a(\"string\");\r",
											"});\r",
											"\r",
											"let body;\r",
											"try {\r",
											"    body = pm.response.json();\r",
											"} catch (e) {\r",
											"    body = {};\r",
											"}\r",
											"\r",
											"pm.test(\"data.messages is an array\", function () {\r",
											"    pm.expect(body).to.have.property(\"data\");\r",
											"    pm.expect(body.data).to.be.an(\"object\");\r",
											"    pm.expect(body.data, \"missing 'messages'\").to.have.property(\"messages\");\r",
											"    pm.expect(body.data.messages, \"messages should be an array\").to.be.an(\"array\");\r",
											"});\r",
											"\r",
											"pm.test(\"data.meta has has_more(boolean), total_count(number), unread_count(number)\", function () {\r",
											"    pm.expect(body.data, \"missing 'meta'\").to.have.property(\"meta\");\r",
											"    const meta = body.data.meta;\r",
											"    pm.expect(meta).to.be.an(\"object\");\r",
											"    pm.expect(meta, \"missing 'has_more'\").to.have.property(\"has_more\");\r",
											"    pm.expect(meta.has_more, \"has_more should be boolean\").to.be.a(\"boolean\");\r",
											"    pm.expect(meta, \"missing 'total_count'\").to.have.property(\"total_count\");\r",
											"    pm.expect(meta.total_count, \"total_count should be a number\").to.be.a(\"number\");\r",
											"    pm.expect(meta, \"missing 'unread_count'\").to.have.property(\"unread_count\");\r",
											"    pm.expect(meta.unread_count, \"unread_count should be a number\").to.be.a(\"number\");\r",
											"});\r",
											"\r",
											"pm.test(\"messages items have id(string), text(string), read(boolean), created_at(ISO 8601)\", function () {\r",
											"    const arr = (body && body.data && Array.isArray(body.data.messages)) ? body.data.messages : [];\r",
											"    if (arr.length === 0) {\r",
											"        console.info(\"messages array is empty; skipping per-item schema checks\");\r",
											"        pm.expect(arr.length, \"No messages to validate\").to.be.a(\"number\");\r",
											"        return;\r",
											"    }\r",
											"    arr.forEach((msg, idx) => {\r",
											"        pm.expect(msg, `message[${idx}] should be an object`).to.be.an(\"object\");\r",
											"        pm.expect(msg, `message[${idx}] missing id`).to.have.property(\"id\");\r",
											"        pm.expect(msg.id, `message[${idx}].id should be string`).to.be.a(\"string\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing text`).to.have.property(\"text\");\r",
											"        pm.expect(msg.text, `message[${idx}].text should be string`).to.be.a(\"string\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing read`).to.have.property(\"read\");\r",
											"        pm.expect(msg.read, `message[${idx}].read should be boolean`).to.be.a(\"boolean\");\r",
											"\r",
											"        pm.expect(msg, `message[${idx}] missing created_at`).to.have.property(\"created_at\");\r",
											"        pm.expect(isIso8601(msg.created_at), `message[${idx}].created_at should be ISO 8601 timestamp`).to.be.true;\r",
											"    });\r",
											"});\r",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?conversation_with=charlie",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "conversation_with",
											"value": "charlie"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Limit 1 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON with expected top-level keys\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json, \"Top-level object missing\").to.be.an(\"object\");",
											"  pm.expect(json, \"Missing top-level 'status'\").to.have.property(\"status\");",
											"  pm.expect(json, \"Missing top-level 'data'\").to.have.property(\"data\");",
											"});",
											"",
											"pm.test(\"Top-level status equals 'success'\", function () {",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"  pm.expect(json.data, \"'data' must be an object\").to.be.an(\"object\");",
											"  pm.expect(json.data, \"'data.messages' missing\").to.have.property(\"messages\");",
											"  pm.expect(json.data.messages, \"'data.messages' must be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"When limit=1, messages length is <= 1\", function () {",
											"  const limitQP = pm.request.url.query.get(\"limit\");",
											"  const limit = limitQP ? Number(limitQP) : undefined;",
											"  if (!Number.isNaN(limit) && limit !== undefined) {",
											"    if (limit === 1) {",
											"      pm.expect(json.data.messages.length, \"Returned more than 1 message for limit=1\").to.be.at.most(1);",
											"    } else {",
											"      pm.expect(json.data.messages.length, `Messages length should not exceed limit=${limit}`).to.be.at.most(limit);",
											"    }",
											"  } else {",
											"    pm.expect(true, \"No 'limit' query param present; skipping limit-based length check\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"  const msgs = json.data.messages;",
											"  const requiredKeys = [",
											"    { key: \"message_id\", type: \"string\" },",
											"    { key: \"message_text\", type: \"string\" },",
											"    { key: \"from_login\", type: \"string\" },",
											"    { key: \"to_login\", type: \"string\" },",
											"    { key: \"timestamp\", type: \"string\" },",
											"    { key: \"is_read\", type: \"boolean\" }",
											"  ];",
											"",
											"  msgs.forEach((m, idx) => {",
											"    pm.expect(m, `Message at index ${idx} must be an object`).to.be.an(\"object\");",
											"    requiredKeys.forEach(({ key, type }) => {",
											"      pm.expect(m, `Message[${idx}] missing required key: ${key}`).to.have.property(key);",
											"      pm.expect(typeof m[key], `Message[${idx}].${key} must be ${type}`).to.eql(type);",
											"      if (type === \"string\") {",
											"        pm.expect(String(m[key]).length, `Message[${idx}].${key} should be non-empty`).to.be.greaterThan(0);",
											"      }",
											"    });",
											"  });",
											"});",
											"",
											"pm.test(\"meta object exists with required keys and types\", function () {",
											"  pm.expect(json.data, \"'data.meta' missing\").to.have.property(\"meta\");",
											"  const meta = json.data.meta;",
											"  pm.expect(meta, \"meta must be an object\").to.be.an(\"object\");",
											"  pm.expect(meta, \"meta.has_more missing\").to.have.property(\"has_more\");",
											"  pm.expect(typeof meta.has_more, \"meta.has_more must be boolean\").to.eql(\"boolean\");",
											"  pm.expect(meta, \"meta.last_message_id missing\").to.have.property(\"last_message_id\");",
											"  pm.expect(typeof meta.last_message_id, \"meta.last_message_id must be string\").to.eql(\"string\");",
											"  pm.expect(meta, \"meta.total_count missing\").to.have.property(\"total_count\");",
											"  pm.expect(typeof meta.total_count, \"meta.total_count must be number\").to.eql(\"number\");",
											"  pm.expect(meta, \"meta.unread_count missing\").to.have.property(\"unread_count\");",
											"  pm.expect(typeof meta.unread_count, \"meta.unread_count must be number\").to.eql(\"number\");",
											"});",
											"",
											"pm.test(\"Authorization header is present and non-empty\", function () {",
											"  const authHeader = pm.request.headers.get(\"Authorization\") || pm.request.headers.get(\"authorization\");",
											"  pm.expect(authHeader, \"Authorization header missing\").to.be.a(\"string\");",
											"  pm.expect(authHeader.trim().length, \"Authorization header must not be empty\").to.be.greaterThan(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?limit=1",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "limit",
											"value": "1"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Limit 2 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON with expected top-level keys\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json, \"Top-level object missing\").to.be.an(\"object\");",
											"  pm.expect(json, \"Missing top-level 'status'\").to.have.property(\"status\");",
											"  pm.expect(json, \"Missing top-level 'data'\").to.have.property(\"data\");",
											"});",
											"",
											"pm.test(\"Top-level status equals 'success'\", function () {",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"  pm.expect(json.data, \"'data' must be an object\").to.be.an(\"object\");",
											"  pm.expect(json.data, \"'data.messages' missing\").to.have.property(\"messages\");",
											"  pm.expect(json.data.messages, \"'data.messages' must be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"When limit=1, messages length is <= 1\", function () {",
											"  const limitQP = pm.request.url.query.get(\"limit\");",
											"  const limit = limitQP ? Number(limitQP) : undefined;",
											"  if (!Number.isNaN(limit) && limit !== undefined) {",
											"    if (limit === 1) {",
											"      pm.expect(json.data.messages.length, \"Returned more than 1 message for limit=1\").to.be.at.most(1);",
											"    } else {",
											"      pm.expect(json.data.messages.length, `Messages length should not exceed limit=${limit}`).to.be.at.most(limit);",
											"    }",
											"  } else {",
											"    pm.expect(true, \"No 'limit' query param present; skipping limit-based length check\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"  const msgs = json.data.messages;",
											"  const requiredKeys = [",
											"    { key: \"message_id\", type: \"string\" },",
											"    { key: \"message_text\", type: \"string\" },",
											"    { key: \"from_login\", type: \"string\" },",
											"    { key: \"to_login\", type: \"string\" },",
											"    { key: \"timestamp\", type: \"string\" },",
											"    { key: \"is_read\", type: \"boolean\" }",
											"  ];",
											"",
											"  msgs.forEach((m, idx) => {",
											"    pm.expect(m, `Message at index ${idx} must be an object`).to.be.an(\"object\");",
											"    requiredKeys.forEach(({ key, type }) => {",
											"      pm.expect(m, `Message[${idx}] missing required key: ${key}`).to.have.property(key);",
											"      pm.expect(typeof m[key], `Message[${idx}].${key} must be ${type}`).to.eql(type);",
											"      if (type === \"string\") {",
											"        pm.expect(String(m[key]).length, `Message[${idx}].${key} should be non-empty`).to.be.greaterThan(0);",
											"      }",
											"    });",
											"  });",
											"});",
											"",
											"pm.test(\"meta object exists with required keys and types\", function () {",
											"  pm.expect(json.data, \"'data.meta' missing\").to.have.property(\"meta\");",
											"  const meta = json.data.meta;",
											"  pm.expect(meta, \"meta must be an object\").to.be.an(\"object\");",
											"  pm.expect(meta, \"meta.has_more missing\").to.have.property(\"has_more\");",
											"  pm.expect(typeof meta.has_more, \"meta.has_more must be boolean\").to.eql(\"boolean\");",
											"  pm.expect(meta, \"meta.last_message_id missing\").to.have.property(\"last_message_id\");",
											"  pm.expect(typeof meta.last_message_id, \"meta.last_message_id must be string\").to.eql(\"string\");",
											"  pm.expect(meta, \"meta.total_count missing\").to.have.property(\"total_count\");",
											"  pm.expect(typeof meta.total_count, \"meta.total_count must be number\").to.eql(\"number\");",
											"  pm.expect(meta, \"meta.unread_count missing\").to.have.property(\"unread_count\");",
											"  pm.expect(typeof meta.unread_count, \"meta.unread_count must be number\").to.eql(\"number\");",
											"});",
											"",
											"pm.test(\"Authorization header is present and non-empty\", function () {",
											"  const authHeader = pm.request.headers.get(\"Authorization\") || pm.request.headers.get(\"authorization\");",
											"  pm.expect(authHeader, \"Authorization header missing\").to.be.a(\"string\");",
											"  pm.expect(authHeader.trim().length, \"Authorization header must not be empty\").to.be.greaterThan(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?limit=2",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "limit",
											"value": "2"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Limit 3 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON with expected top-level keys\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json, \"Top-level object missing\").to.be.an(\"object\");",
											"  pm.expect(json, \"Missing top-level 'status'\").to.have.property(\"status\");",
											"  pm.expect(json, \"Missing top-level 'data'\").to.have.property(\"data\");",
											"});",
											"",
											"pm.test(\"Top-level status equals 'success'\", function () {",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"  pm.expect(json.data, \"'data' must be an object\").to.be.an(\"object\");",
											"  pm.expect(json.data, \"'data.messages' missing\").to.have.property(\"messages\");",
											"  pm.expect(json.data.messages, \"'data.messages' must be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"When limit=1, messages length is <= 1\", function () {",
											"  const limitQP = pm.request.url.query.get(\"limit\");",
											"  const limit = limitQP ? Number(limitQP) : undefined;",
											"  if (!Number.isNaN(limit) && limit !== undefined) {",
											"    if (limit === 1) {",
											"      pm.expect(json.data.messages.length, \"Returned more than 1 message for limit=1\").to.be.at.most(1);",
											"    } else {",
											"      pm.expect(json.data.messages.length, `Messages length should not exceed limit=${limit}`).to.be.at.most(limit);",
											"    }",
											"  } else {",
											"    pm.expect(true, \"No 'limit' query param present; skipping limit-based length check\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"  const msgs = json.data.messages;",
											"  const requiredKeys = [",
											"    { key: \"message_id\", type: \"string\" },",
											"    { key: \"message_text\", type: \"string\" },",
											"    { key: \"from_login\", type: \"string\" },",
											"    { key: \"to_login\", type: \"string\" },",
											"    { key: \"timestamp\", type: \"string\" },",
											"    { key: \"is_read\", type: \"boolean\" }",
											"  ];",
											"",
											"  msgs.forEach((m, idx) => {",
											"    pm.expect(m, `Message at index ${idx} must be an object`).to.be.an(\"object\");",
											"    requiredKeys.forEach(({ key, type }) => {",
											"      pm.expect(m, `Message[${idx}] missing required key: ${key}`).to.have.property(key);",
											"      pm.expect(typeof m[key], `Message[${idx}].${key} must be ${type}`).to.eql(type);",
											"      if (type === \"string\") {",
											"        pm.expect(String(m[key]).length, `Message[${idx}].${key} should be non-empty`).to.be.greaterThan(0);",
											"      }",
											"    });",
											"  });",
											"});",
											"",
											"pm.test(\"meta object exists with required keys and types\", function () {",
											"  pm.expect(json.data, \"'data.meta' missing\").to.have.property(\"meta\");",
											"  const meta = json.data.meta;",
											"  pm.expect(meta, \"meta must be an object\").to.be.an(\"object\");",
											"  pm.expect(meta, \"meta.has_more missing\").to.have.property(\"has_more\");",
											"  pm.expect(typeof meta.has_more, \"meta.has_more must be boolean\").to.eql(\"boolean\");",
											"  pm.expect(meta, \"meta.last_message_id missing\").to.have.property(\"last_message_id\");",
											"  pm.expect(typeof meta.last_message_id, \"meta.last_message_id must be string\").to.eql(\"string\");",
											"  pm.expect(meta, \"meta.total_count missing\").to.have.property(\"total_count\");",
											"  pm.expect(typeof meta.total_count, \"meta.total_count must be number\").to.eql(\"number\");",
											"  pm.expect(meta, \"meta.unread_count missing\").to.have.property(\"unread_count\");",
											"  pm.expect(typeof meta.unread_count, \"meta.unread_count must be number\").to.eql(\"number\");",
											"});",
											"",
											"pm.test(\"Authorization header is present and non-empty\", function () {",
											"  const authHeader = pm.request.headers.get(\"Authorization\") || pm.request.headers.get(\"authorization\");",
											"  pm.expect(authHeader, \"Authorization header missing\").to.be.a(\"string\");",
											"  pm.expect(authHeader.trim().length, \"Authorization header must not be empty\").to.be.greaterThan(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?limit=3",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "limit",
											"value": "3"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Limit 4 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON with expected top-level keys\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json, \"Top-level object missing\").to.be.an(\"object\");",
											"  pm.expect(json, \"Missing top-level 'status'\").to.have.property(\"status\");",
											"  pm.expect(json, \"Missing top-level 'data'\").to.have.property(\"data\");",
											"});",
											"",
											"pm.test(\"Top-level status equals 'success'\", function () {",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"  pm.expect(json.data, \"'data' must be an object\").to.be.an(\"object\");",
											"  pm.expect(json.data, \"'data.messages' missing\").to.have.property(\"messages\");",
											"  pm.expect(json.data.messages, \"'data.messages' must be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"When limit=1, messages length is <= 1\", function () {",
											"  const limitQP = pm.request.url.query.get(\"limit\");",
											"  const limit = limitQP ? Number(limitQP) : undefined;",
											"  if (!Number.isNaN(limit) && limit !== undefined) {",
											"    if (limit === 1) {",
											"      pm.expect(json.data.messages.length, \"Returned more than 1 message for limit=1\").to.be.at.most(1);",
											"    } else {",
											"      pm.expect(json.data.messages.length, `Messages length should not exceed limit=${limit}`).to.be.at.most(limit);",
											"    }",
											"  } else {",
											"    pm.expect(true, \"No 'limit' query param present; skipping limit-based length check\").to.be.true;",
											"  }",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"  const msgs = json.data.messages;",
											"  const requiredKeys = [",
											"    { key: \"message_id\", type: \"string\" },",
											"    { key: \"message_text\", type: \"string\" },",
											"    { key: \"from_login\", type: \"string\" },",
											"    { key: \"to_login\", type: \"string\" },",
											"    { key: \"timestamp\", type: \"string\" },",
											"    { key: \"is_read\", type: \"boolean\" }",
											"  ];",
											"",
											"  msgs.forEach((m, idx) => {",
											"    pm.expect(m, `Message at index ${idx} must be an object`).to.be.an(\"object\");",
											"    requiredKeys.forEach(({ key, type }) => {",
											"      pm.expect(m, `Message[${idx}] missing required key: ${key}`).to.have.property(key);",
											"      pm.expect(typeof m[key], `Message[${idx}].${key} must be ${type}`).to.eql(type);",
											"      if (type === \"string\") {",
											"        pm.expect(String(m[key]).length, `Message[${idx}].${key} should be non-empty`).to.be.greaterThan(0);",
											"      }",
											"    });",
											"  });",
											"});",
											"",
											"pm.test(\"meta object exists with required keys and types\", function () {",
											"  pm.expect(json.data, \"'data.meta' missing\").to.have.property(\"meta\");",
											"  const meta = json.data.meta;",
											"  pm.expect(meta, \"meta must be an object\").to.be.an(\"object\");",
											"  pm.expect(meta, \"meta.has_more missing\").to.have.property(\"has_more\");",
											"  pm.expect(typeof meta.has_more, \"meta.has_more must be boolean\").to.eql(\"boolean\");",
											"  pm.expect(meta, \"meta.last_message_id missing\").to.have.property(\"last_message_id\");",
											"  pm.expect(typeof meta.last_message_id, \"meta.last_message_id must be string\").to.eql(\"string\");",
											"  pm.expect(meta, \"meta.total_count missing\").to.have.property(\"total_count\");",
											"  pm.expect(typeof meta.total_count, \"meta.total_count must be number\").to.eql(\"number\");",
											"  pm.expect(meta, \"meta.unread_count missing\").to.have.property(\"unread_count\");",
											"  pm.expect(typeof meta.unread_count, \"meta.unread_count must be number\").to.eql(\"number\");",
											"});",
											"",
											"pm.test(\"Authorization header is present and non-empty\", function () {",
											"  const authHeader = pm.request.headers.get(\"Authorization\") || pm.request.headers.get(\"authorization\");",
											"  pm.expect(authHeader, \"Authorization header missing\").to.be.a(\"string\");",
											"  pm.expect(authHeader.trim().length, \"Authorization header must not be empty\").to.be.greaterThan(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?limit=4",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "limit",
											"value": "4"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - Limit 0 bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response body is valid JSON with expected top-level keys\", function () {",
											"  json = pm.response.json();",
											"  pm.expect(json, \"Top-level object missing\").to.be.an(\"object\");",
											"  pm.expect(json, \"Missing top-level 'status'\").to.have.property(\"status\");",
											"  pm.expect(json, \"Missing top-level 'data'\").to.have.property(\"data\");",
											"});",
											"",
											"pm.test(\"Top-level status equals 'success'\", function () {",
											"  pm.expect(json.status, \"Top-level status should be 'success'\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array\", function () {",
											"  pm.expect(json.data, \"'data' must be an object\").to.be.an(\"object\");",
											"  pm.expect(json.data, \"'data.messages' missing\").to.have.property(\"messages\");",
											"  pm.expect(json.data.messages, \"'data.messages' must be an array\").to.be.an(\"array\");",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"  const msgs = json.data.messages;",
											"  const requiredKeys = [",
											"    { key: \"message_id\", type: \"string\" },",
											"    { key: \"message_text\", type: \"string\" },",
											"    { key: \"from_login\", type: \"string\" },",
											"    { key: \"to_login\", type: \"string\" },",
											"    { key: \"timestamp\", type: \"string\" },",
											"    { key: \"is_read\", type: \"boolean\" }",
											"  ];",
											"",
											"  msgs.forEach((m, idx) => {",
											"    pm.expect(m, `Message at index ${idx} must be an object`).to.be.an(\"object\");",
											"    requiredKeys.forEach(({ key, type }) => {",
											"      pm.expect(m, `Message[${idx}] missing required key: ${key}`).to.have.property(key);",
											"      pm.expect(typeof m[key], `Message[${idx}].${key} must be ${type}`).to.eql(type);",
											"      if (type === \"string\") {",
											"        pm.expect(String(m[key]).length, `Message[${idx}].${key} should be non-empty`).to.be.greaterThan(0);",
											"      }",
											"    });",
											"  });",
											"});",
											"",
											"pm.test(\"meta object exists with required keys and types\", function () {",
											"  pm.expect(json.data, \"'data.meta' missing\").to.have.property(\"meta\");",
											"  const meta = json.data.meta;",
											"  pm.expect(meta, \"meta must be an object\").to.be.an(\"object\");",
											"  pm.expect(meta, \"meta.has_more missing\").to.have.property(\"has_more\");",
											"  pm.expect(typeof meta.has_more, \"meta.has_more must be boolean\").to.eql(\"boolean\");",
											"  pm.expect(meta, \"meta.last_message_id missing\").to.have.property(\"last_message_id\");",
											"  pm.expect(typeof meta.last_message_id, \"meta.last_message_id must be string\").to.eql(\"string\");",
											"  pm.expect(meta, \"meta.total_count missing\").to.have.property(\"total_count\");",
											"  pm.expect(typeof meta.total_count, \"meta.total_count must be number\").to.eql(\"number\");",
											"  pm.expect(meta, \"meta.unread_count missing\").to.have.property(\"unread_count\");",
											"  pm.expect(typeof meta.unread_count, \"meta.unread_count must be number\").to.eql(\"number\");",
											"});",
											"",
											"pm.test(\"Authorization header is present and non-empty\", function () {",
											"  const authHeader = pm.request.headers.get(\"Authorization\") || pm.request.headers.get(\"authorization\");",
											"  pm.expect(authHeader, \"Authorization header missing\").to.be.a(\"string\");",
											"  pm.expect(authHeader.trim().length, \"Authorization header must not be empty\").to.be.greaterThan(0);",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?limit=0",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "limit",
											"value": "0"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Get - All params",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test('Response is valid JSON and status is success', function () {",
											"  pm.response.to.be.json;",
											"  var json = pm.response.json();",
											"  pm.expect(json).to.have.property('status');",
											"  pm.expect(json.status).to.eql('success');",
											"});",
											"",
											"pm.test('Data.messages is an array', function () {",
											"  var json = pm.response.json();",
											"  pm.expect(json).to.have.property('data');",
											"  pm.expect(json.data).to.have.property('messages');",
											"  pm.expect(Array.isArray(json.data.messages)).to.be.true;",
											"});",
											"",
											"pm.test('Each message has required fields with expected types', function () {",
											"  var json = pm.response.json();",
											"  var messages = json.data.messages || [];",
											"  messages.forEach(function (msg, idx) {",
											"    pm.expect(msg, 'message at index ' + idx + ' should be an object').to.be.an('object');",
											"    pm.expect(msg).to.have.property('message_id');",
											"    pm.expect(msg.message_id, 'message_id should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('from_login');",
											"    pm.expect(msg.from_login, 'from_login should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('to_login');",
											"    pm.expect(msg.to_login, 'to_login should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('message_text');",
											"    pm.expect(msg.message_text, 'message_text should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('timestamp');",
											"    pm.expect(msg.timestamp, 'timestamp should be a string at index ' + idx).to.be.a('string');",
											"    pm.expect(msg).to.have.property('is_read');",
											"    pm.expect(msg.is_read, 'is_read must be boolean for message index ' + idx).to.be.a('boolean');",
											"  });",
											"});",
											"",
											"pm.test('Meta object exists and has required fields', function () {",
											"  var json = pm.response.json();",
											"  pm.expect(json).to.have.property('data');",
											"  pm.expect(json.data).to.have.property('meta');",
											"  var meta = json.data.meta;",
											"  pm.expect(meta, 'meta should be an object').to.be.an('object');",
											"  pm.expect(meta).to.have.property('has_more');",
											"  pm.expect(meta.has_more, 'has_more should be boolean').to.be.a('boolean');",
											"  pm.expect(meta).to.have.property('total_count');",
											"  pm.expect(meta.total_count, 'total_count should be a number').to.be.a('number');",
											"  pm.expect(meta).to.have.property('unread_count');",
											"  pm.expect(meta.unread_count, 'unread_count should be a number').to.be.a('number');",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true&after_message_id={{messageIDAliceBob3}}&before_message_id={{messageIDAliceBob2}}&limit=1&conversation_with=alice",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										},
										{
											"key": "after_message_id",
											"value": "{{messageIDAliceBob3}}"
										},
										{
											"key": "before_message_id",
											"value": "{{messageIDAliceBob2}}"
										},
										{
											"key": "limit",
											"value": "1"
										},
										{
											"key": "conversation_with",
											"value": "alice"
										}
									]
								}
							},
							"response": []
						}
					]
				},
				{
					"name": "Read",
					"item": [
						{
							"name": "Messages Read - Invalid message ids",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  pm.test(\"Request uses baseURL and Authorization token variables\", function () {",
											"    const reqUrl = pm.request.url.toString();",
											"    pm.expect(reqUrl).to.include(pm.variables.get(\"baseURL\"));",
											"    const authHeader = pm.request.headers.get(\"Authorization\");",
											"    pm.expect(authHeader, \"Authorization header should be present\").to.exist;",
											"    pm.expect(authHeader, \"Authorization header should use bobAccessToken variable\").to.include(\"Bearer \");",
											"  });",
											"",
											"  pm.test(\"Request Content-Type is application/json\", function () {",
											"    const ct = pm.request.headers.get(\"Content-Type\");",
											"    pm.expect(ct).to.match(/application\\/json/i);",
											"  });",
											"",
											"  let json;",
											"  try {",
											"    json = pm.response.json();",
											"  } catch (e) {",
											"    json = null;",
											"  }",
											"",
											"  pm.test(\"Response has a valid HTTP status code\", function () {",
											"    pm.expect(pm.response.code).to.be.a(\"number\");",
											"  });",
											"",
											"  pm.test(\"Response Content-Type header is present\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"  });",
											"",
											"  const code = pm.response.code;",
											"",
											"  if (code >= 200 && code < 300) {",
											"    pm.test(\"Success: response body is JSON\", function () {",
											"      pm.expect(json, \"Response should be JSON on success\").to.be.an(\"object\");",
											"    });",
											"",
											"    pm.test(\"Success: response indicates success status\", function () {",
											"      const statusStr = json && (json.status || json.result || json.code);",
											"      const successFlag = json && (json.success === true || /success/i.test(String(statusStr || \"\")));",
											"      pm.expect(successFlag, \"Success indicator should be present\").to.be.true;",
											"    });",
											"",
											"    pm.test(\"Success: echoes/read results schema looks reasonable\", function () {",
											"      if (json && json.data) {",
											"        const d = json.data;",
											"        if (Array.isArray(d.processed_ids)) {",
											"          d.processed_ids.forEach(id => pm.expect(id).to.be.a(\"string\"));",
											"        }",
											"        if (Array.isArray(d.failed_ids)) {",
											"          d.failed_ids.forEach(id => pm.expect(id).to.be.a(\"string\"));",
											"        }",
											"      }",
											"    });",
											"  }",
											"",
											"  if (code >= 400 && code < 500) {",
											"    pm.test(\"Client error: response body is JSON with error details\", function () {",
											"      pm.expect(json, \"Error body should be JSON\").to.be.an(\"object\");",
											"      if (json) {",
											"        if (json.error) {",
											"          pm.expect(json.error).to.be.an(\"object\");",
											"          if (json.error.code !== undefined) pm.expect(json.error.code).to.be.a(\"string\");",
											"          if (json.error.message !== undefined) pm.expect(json.error.message).to.be.a(\"string\");",
											"        } else {",
											"          if (json.code !== undefined) pm.expect(json.code).to.be.a(\"string\");",
											"          if (json.message !== undefined) pm.expect(json.message).to.be.a(\"string\");",
											"          if (json.status !== undefined) pm.expect(json.status).to.be.a(\"string\");",
											"        }",
											"      }",
											"    });",
											"",
											"    pm.test(\"Client error: appropriate status code returned\", function () {",
											"      pm.expect(code).to.be.oneOf([400, 401, 403, 404, 409, 422, 429]);",
											"    });",
											"  }",
											"",
											"  if (code >= 500 && code < 600) {",
											"    pm.test(\"Server error: response body matches expected error shape\", function () {",
											"      pm.expect(json, \"Server error body should be JSON\").to.be.an(\"object\");",
											"      if (json) {",
											"        if (json.code !== undefined) pm.expect(json.code).to.be.a(\"string\");",
											"        if (json.message !== undefined) pm.expect(json.message).to.be.a(\"string\");",
											"        if (json.status !== undefined) pm.expect(json.status).to.be.a(\"string\");",
											"      }",
											"    });",
											"",
											"    pm.test(\"Handles observed 500 error MARK_READ_FAILED\", function () {",
											"      if (json && typeof json === 'object') {",
											"        pm.expect(json.code, \"Expected error code to be MARK_READ_FAILED on 500\").to.be.oneOf([\"MARK_READ_FAILED\", undefined]);",
											"        pm.expect(json.status, \"Expected error status to be 'error'\").to.be.oneOf([\"error\", undefined]);",
											"      }",
											"    });",
											"  }",
											"",
											"  pm.test(\"Request method and path are correct\", function () {",
											"    pm.expect(pm.request.method).to.eql(\"POST\");",
											"    pm.expect(pm.request.url.getPath()).to.match(/\\/api\\/v1\\/messages\\/read$/);",
											"  });",
											"",
											"  pm.test(\"Request body contains message_ids array of strings\", function () {",
											"    try {",
											"      const body = pm.request.body?.raw ? JSON.parse(pm.request.body.raw) : null;",
											"      pm.expect(body).to.be.an(\"object\");",
											"      pm.expect(body.message_ids, \"message_ids should be an array\").to.be.an(\"array\");",
											"      (body.message_ids || []).forEach(id => pm.expect(id).to.be.a(\"string\"));",
											"    } catch (e) {",
											"      pm.expect.fail(\"Request body is not valid JSON\");",
											"    }",
											"  });",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": [\r\n    \"invalidid1\",\r\n    \"invalidid2\",\r\n    \"invalidid3\"\r\n  ]\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - Empty message ids",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 400 (Bad Request) when message IDs are missing\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"pm.test(\"Error payload has code EMPTY_MESSAGE_IDS and message mentions 'Message IDs'\", function () {",
											"    let json;",
											"    try {",
											"        json = pm.response.json();",
											"    } catch (e) {",
											"        json = {};",
											"    }",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json.code, \"error code should be present\").to.eql(\"EMPTY_MESSAGE_IDS\");",
											"    pm.expect(String(json.message || \"\"), \"error message should mention Message IDs\").to.include(\"Message IDs\");",
											"});",
											"",
											"pm.test(\"Content-Type is application/json\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": []\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - Invalid json format",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"  const statusCode = pm.response.code;",
											"  const bodyText = pm.response.text();",
											"",
											"  let json;",
											"",
											"  pm.test('Response has valid JSON body', function () {",
											"    let isJson = false;",
											"    try {",
											"      json = bodyText ? JSON.parse(bodyText) : {};",
											"      isJson = true;",
											"    } catch (e) {",
											"      isJson = false;",
											"      console.log('Failed to parse JSON body:', e);",
											"    }",
											"    pm.expect(isJson, 'Body should be valid JSON').to.be.true;",
											"  });",
											"",
											"  if (typeof json === 'undefined') {",
											"    try { json = JSON.parse(bodyText || '{}'); } catch (e) { json = {}; }",
											"  }",
											"",
											"  console.log('[Logout] Status:', statusCode);",
											"  console.log('[Logout] Headers Content-Type:', contentType);",
											"  console.log('[Logout] Body (parsed):', json);",
											"",
											"  pm.test('Content-Type includes application/json', function () {",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  pm.test('Status is OK (200) or a handled client/server error (4xx/5xx)', function () {",
											"    pm.expect([",
											"      200, 201, 202, 204,",
											"      400, 401, 403, 404, 409, 422,",
											"      429,",
											"      500, 502, 503, 504",
											"    ]).to.include(statusCode);",
											"  });",
											"",
											"  if (statusCode === 200) {",
											"    pm.test(\"200 response should indicate success or include token fields\", function () {",
											"      const hasExplicitSuccess = json && (json.status === 'success' || json.success === true);",
											"      const hasTokenLikeFields = json && (",
											"        typeof json.token === 'string' ||",
											"        typeof json.accessToken === 'string' ||",
											"        (json.data && (typeof json.data.token === 'string' || typeof json.data.accessToken === 'string'))",
											"      );",
											"      pm.expect(hasExplicitSuccess || hasTokenLikeFields, 'Expected success status or token fields').to.be.true;",
											"    });",
											"  }",
											"",
											"  if (statusCode === 400) {",
											"    pm.test(\"400 INVALID_JSON should include an error message\", function () {",
											"      pm.expect(json).to.be.an('object');",
											"      if (json && json.code === 'INVALID_JSON') {",
											"        pm.expect(json.message, 'Error message should be present').to.be.a('string').and.not.be.empty;",
											"      } else {",
											"        pm.expect(json.message, 'Error message should be present for 400').to.be.a('string');",
											"      }",
											"    });",
											"  }",
											"",
											"  if (statusCode >= 500 && statusCode <= 599) {",
											"    pm.test('Server error should expose an error message', function () {",
											"      pm.expect(json).to.be.an('object');",
											"      pm.expect(json.message || json.error || json.detail, 'Some error detail should be provided').to.exist;",
											"    });",
											"  }",
											"",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": [\r\n    \"{{messageIDAliceBob1}}\",\r\n    \"{{messageIDAliceBob2}}\",\r\n    \"{{messageIDAliceBob3}}\"\r\n  ]\r\n}\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - Empty json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 400 (Bad Request) when message IDs are missing\", function () {",
											"    pm.response.to.have.status(400);",
											"});",
											"",
											"pm.test(\"Error payload has code EMPTY_MESSAGE_IDS and message mentions 'Message IDs'\", function () {",
											"    let json;",
											"    try {",
											"        json = pm.response.json();",
											"    } catch (e) {",
											"        json = {};",
											"    }",
											"    pm.expect(json).to.be.an(\"object\");",
											"    pm.expect(json.code, \"error code should be present\").to.eql(\"EMPTY_MESSAGE_IDS\");",
											"    pm.expect(String(json.message || \"\"), \"error message should mention Message IDs\").to.include(\"Message IDs\");",
											"});",
											"",
											"pm.test(\"Content-Type is application/json\", function () {",
											"    pm.response.to.have.header(\"Content-Type\");",
											"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
											"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - No json",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"  const contentType = pm.response.headers.get('Content-Type') || '';",
											"  const statusCode = pm.response.code;",
											"  const bodyText = pm.response.text();",
											"",
											"  let json;",
											"",
											"  pm.test('Response has valid JSON body', function () {",
											"    let isJson = false;",
											"    try {",
											"      json = bodyText ? JSON.parse(bodyText) : {};",
											"      isJson = true;",
											"    } catch (e) {",
											"      isJson = false;",
											"      console.log('Failed to parse JSON body:', e);",
											"    }",
											"    pm.expect(isJson, 'Body should be valid JSON').to.be.true;",
											"  });",
											"",
											"  if (typeof json === 'undefined') {",
											"    try { json = JSON.parse(bodyText || '{}'); } catch (e) { json = {}; }",
											"  }",
											"",
											"  console.log('[Logout] Status:', statusCode);",
											"  console.log('[Logout] Headers Content-Type:', contentType);",
											"  console.log('[Logout] Body (parsed):', json);",
											"",
											"  pm.test('Content-Type includes application/json', function () {",
											"    pm.expect(contentType.toLowerCase()).to.include('application/json');",
											"  });",
											"",
											"  pm.test('Status is OK (200) or a handled client/server error (4xx/5xx)', function () {",
											"    pm.expect([",
											"      200, 201, 202, 204,",
											"      400, 401, 403, 404, 409, 422,",
											"      429,",
											"      500, 502, 503, 504",
											"    ]).to.include(statusCode);",
											"  });",
											"",
											"  if (statusCode === 200) {",
											"    pm.test(\"200 response should indicate success or include token fields\", function () {",
											"      const hasExplicitSuccess = json && (json.status === 'success' || json.success === true);",
											"      const hasTokenLikeFields = json && (",
											"        typeof json.token === 'string' ||",
											"        typeof json.accessToken === 'string' ||",
											"        (json.data && (typeof json.data.token === 'string' || typeof json.data.accessToken === 'string'))",
											"      );",
											"      pm.expect(hasExplicitSuccess || hasTokenLikeFields, 'Expected success status or token fields').to.be.true;",
											"    });",
											"  }",
											"",
											"  if (statusCode === 400) {",
											"    pm.test(\"400 INVALID_JSON should include an error message\", function () {",
											"      pm.expect(json).to.be.an('object');",
											"      if (json && json.code === 'INVALID_JSON') {",
											"        pm.expect(json.message, 'Error message should be present').to.be.a('string').and.not.be.empty;",
											"      } else {",
											"        pm.expect(json.message, 'Error message should be present for 400').to.be.a('string');",
											"      }",
											"    });",
											"  }",
											"",
											"  if (statusCode >= 500 && statusCode <= 599) {",
											"    pm.test('Server error should expose an error message', function () {",
											"      pm.expect(json).to.be.an('object');",
											"      pm.expect(json.message || json.error || json.detail, 'Some error detail should be provided').to.exist;",
											"    });",
											"  }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": ""
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - Invalid access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											"",
											"pm.test('Authorization header is present', function () {",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHAiOjE3NjQzNTY2NjMsImlhdCI6MTc2NDM1NTc2MywiaXNzIjoibm92YS1jaGF0LXNlcnZlciIsImxvZ2luIjoiYWxpY2UiLCJzdWIiOiJhY2Nlc3MiLCJ0eXBlIjoiYWNjZXNzIiwidXNlcklEIjoiNDNlN2QyMDUtZWVlMy00ZDBjLTkyMTQtYzBlYTY3NjZkNjkxIn0.o9--8fxDjoZihoSNOYA2ZtvoG0B40UzcOW7ny7WzsSY",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": [\r\n    \"{{messageIDAliceBob1}}\",\r\n    \"{{messageIDAliceBob2}}\",\r\n    \"{{messageIDAliceBob3}}\"\r\n  ]\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - Empty access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {",
											"  pm.expect(pm.response.code).to.be.within(400, 401);",
											"});",
											"",
											"pm.test('Response is JSON', function () {",
											"  pm.response.to.have.jsonBody();",
											"});",
											"",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {",
											"  if (pm.response.code === 401) {",
											"    var json = pm.response.json();",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');",
											"    pm.expect(json).to.have.property('message');",
											"  } else {",
											"    pm.test.skip('Not 401 - skipping invalid token check');",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": [\r\n    \"{{messageIDAliceBob1}}\",\r\n    \"{{messageIDAliceBob2}}\",\r\n    \"{{messageIDAliceBob3}}\"\r\n  ]\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - No access token",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 401', function () {\r",
											"  pm.expect(pm.response.code).to.be.within(400, 401);\r",
											"});\r",
											"\r",
											"pm.test('Response is JSON', function () {\r",
											"  pm.response.to.have.jsonBody();\r",
											"});\r",
											"\r",
											"pm.test('Invalid token returns 401 with INVALID_TOKEN code', function () {\r",
											"  if (pm.response.code === 401) {\r",
											"    var json = pm.response.json();\r",
											"    pm.expect(json).to.have.property('code', 'INVALID_TOKEN');\r",
											"    pm.expect(json).to.have.property('message');\r",
											"  } else {\r",
											"    pm.test.skip('Not 401 - skipping invalid token check');\r",
											"  }\r",
											"});\r",
											"\r",
											"pm.test('Authorization header is present', function () {\r",
											"  pm.expect(pm.request.headers.has('Authorization')).to.be.true;\r",
											"});"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": [\r\n    \"{{messageIDAliceBob1}}\",\r\n    \"{{messageIDAliceBob2}}\",\r\n    \"{{messageIDAliceBob3}}\"\r\n  ]\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - Invalid request type",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"(function () {",
											"    const meta = {",
											"        requestName: pm.info.requestName,",
											"        requestId: pm.info.requestId,",
											"        method: pm.request.method,",
											"        url: pm.request.url.toString(),",
											"        status: pm.response.code,",
											"        timestamp: new Date().toISOString()",
											"    };",
											"    console.log(\"[TEST META]\", JSON.stringify(meta, null, 2));",
											"",
											"    pm.test(\"Status code is 404 (Not Found)\", function () {",
											"        pm.expect(pm.response.code, `Expected 404 but got ${pm.response.code}`).to.eql(404);",
											"    });",
											"",
											"    let json;",
											"    pm.test(\"Response body is valid JSON\", function () {",
											"        try {",
											"            json = pm.response.json();",
											"            pm.expect(json, \"Parsed JSON should be an object\").to.be.an(\"object\");",
											"        } catch (err) {",
											"            console.error(\"[PARSE ERROR]\", err?.message || err);",
											"            throw new Error(\"Response body is not valid JSON: \" + (err?.message || err));",
											"        }",
											"    });",
											"",
											"    pm.test(\"Response has required string properties: code, message, status\", function () {",
											"        pm.expect(json, \"Response must be an object\").to.be.an(\"object\");",
											"        pm.expect(json, \"Missing 'code' property\").to.have.property(\"code\");",
											"        pm.expect(json.code, \"'code' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'message' property\").to.have.property(\"message\");",
											"        pm.expect(json.message, \"'message' must be a string\").to.be.a(\"string\");",
											"",
											"        pm.expect(json, \"Missing 'status' property\").to.have.property(\"status\");",
											"        pm.expect(json.status, \"'status' must be a string\").to.be.a(\"string\");",
											"    });",
											"",
											"    pm.test(\"status equals 'error'\", function () {",
											"        pm.expect(json.status, \"Expected status to be 'error'\").to.eql(\"error\");",
											"    });",
											"",
											"    pm.test(\"code equals 'ENDPOINT_NOT_FOUND'\", function () {",
											"        pm.expect(json.code, \"Expected code to be 'ENDPOINT_NOT_FOUND'\").to.eql(\"ENDPOINT_NOT_FOUND\");",
											"    });",
											"",
											"    try {",
											"        console.log(\"[RESPONSE BODY]\", JSON.stringify(json, null, 2));",
											"    } catch (e) {",
											"        console.log(\"[RESPONSE BODY RAW]\", pm.response.text());",
											"    }",
											"})();"
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "PUT",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": [\r\n    \"{{messageIDAliceBob1}}\",\r\n    \"{{messageIDAliceBob2}}\",\r\n    \"{{messageIDAliceBob3}}\"\r\n  ]\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Messages Read - Successfully mark bob",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test('Status code is 200', function () {",
											"  pm.response.to.have.status(200);",
											"});",
											"",
											"pm.test(\"Response has valid JSON\", function () {",
											"  pm.expect(function(){ pm.response.json(); }).not.to.throw();",
											"});",
											"",
											"const json = (() => { try { return pm.response.json(); } catch (e) { return null; } })();",
											"",
											"pm.test('Response status field is success', function () {",
											"  pm.expect(json, 'response JSON should be parsable').to.be.an('object');",
											"  pm.expect(json).to.have.property('status');",
											"  pm.expect(json.status, `expected status to be \"success\" but got ${json && json.status}`).to.eql('success');",
											"});",
											"",
											"pm.test('Response message is correct', function () {",
											"  pm.expect(json).to.have.property('message');",
											"  pm.expect(json.message, `expected message to be \"Messages marked as read\" but got ${json && json.message}`).to.eql('Messages marked as read');",
											"});",
											"",
											"pm.test('data.read_count exists and matches number of sent message ids', function () {",
											"  let sentIds = []",
											"  try {",
											"    const reqBody = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : null;",
											"    sentIds = reqBody && Array.isArray(reqBody.message_ids) ? reqBody.message_ids : [];",
											"  } catch (e) {",
											"    pm.expect.fail('Could not parse request body to determine sent message ids: ' + e.message);",
											"  }",
											"  pm.expect(json).to.have.property('data');",
											"  pm.expect(json.data).to.have.property('read_count');",
											"  pm.expect(json.data.read_count, `expected read_count to be ${sentIds.length} but got ${json && json.data && json.data.read_count}`).to.eql(sentIds.length);",
											"});",
											"",
											"pm.test('response contains read_message_ids that include all sent ids (if present)', function () {",
											"  let sentIds = []",
											"  try {",
											"    const reqBody = pm.request.body && pm.request.body.raw ? JSON.parse(pm.request.body.raw) : null;",
											"    sentIds = reqBody && Array.isArray(reqBody.message_ids) ? reqBody.message_ids : [];",
											"  } catch (e) {",
											"    // already handled above, but ensure we don't throw here",
											"  }",
											"",
											"  if (json && json.data && Array.isArray(json.data.read_message_ids)) {",
											"    pm.expect(json.data.read_message_ids.length, 'read_message_ids length').to.be.at.least(sentIds.length);",
											"    sentIds.forEach(id => {",
											"      pm.test(`read_message_ids includes ${id}`, function () {",
											"        pm.expect(json.data.read_message_ids).to.include(id);",
											"      });",
											"    });",
											"  } else {",
											"    pm.test('read_message_ids not returned by API - skipping inclusion checks', function () {",
											"      pm.expect(true).to.be.true;",
											"    });",
											"  }",
											"});",
											"",
											"pm.test('Clear stored message IDs', function () {",
											"  if (pm.response.code === 200) {",
											"    if (pm.environment.get('messageIDAliceBob1')) pm.environment.unset('messageIDAliceBob1');",
											"    if (pm.environment.get('messageIDAliceBob2')) pm.environment.unset('messageIDAliceBob2');",
											"    if (pm.environment.get('messageIDAliceBob3')) pm.environment.unset('messageIDAliceBob3');",
											"",
											"    pm.collectionVariables.unset('messageIDAliceBob1');",
											"    pm.collectionVariables.unset('messageIDAliceBob2');",
											"    pm.collectionVariables.unset('messageIDAliceBob3');",
											"    ",
											"    pm.globals.unset('messageIDAliceBob1');",
											"    pm.globals.unset('messageIDAliceBob2');",
											"    pm.globals.unset('messageIDAliceBob3');",
											"",
											"    pm.expect(pm.environment.get('messageIDAliceBob1')).to.be.undefined;",
											"    pm.expect(pm.environment.get('messageIDAliceBob2')).to.be.undefined;",
											"    pm.expect(pm.environment.get('messageIDAliceBob3')).to.be.undefined;",
											"  } else {",
											"    pm.expect.fail('Skipping message IDs clear because read did not return 200');",
											"  }",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "POST",
								"header": [
									{
										"key": "Content-Type",
										"value": "application/json",
										"type": "text"
									},
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"body": {
									"mode": "raw",
									"raw": "{\r\n  \"message_ids\": [\r\n    \"{{messageIDAliceBob1}}\",\r\n    \"{{messageIDAliceBob2}}\",\r\n    \"{{messageIDAliceBob3}}\"\r\n  ]\r\n}"
								},
								"url": {
									"raw": "{{baseURL}}/api/v1/messages/read",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages",
										"read"
									]
								}
							},
							"response": []
						},
						{
							"name": "Unread only true bob TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{bobAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=true",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "true"
										}
									]
								}
							},
							"response": []
						},
						{
							"name": "Unread only false alice TEMP",
							"event": [
								{
									"listen": "test",
									"script": {
										"exec": [
											"pm.test(\"Status code is 200\", function () {",
											"    pm.response.to.have.status(200);",
											"});",
											"",
											"let json;",
											"pm.test(\"Response is valid JSON\", function () {",
											"    try {",
											"        json = pm.response.json();",
											"        pm.expect(json).to.be.an(\"object\");",
											"    } catch (e) {",
											"        pm.expect.fail(\"Response body is not valid JSON: \" + e.message);",
											"    }",
											"});",
											"",
											"pm.test(\"Top-level status is 'success'\", function () {",
											"    pm.expect(json).to.have.property(\"status\");",
											"    pm.expect(json.status, \"status value\").to.eql(\"success\");",
											"});",
											"",
											"pm.test(\"data.messages is an array and meta present\", function () {",
											"    pm.expect(json).to.have.property(\"data\");",
											"    pm.expect(json.data, \"data object\").to.be.an(\"object\");",
											"    pm.expect(json.data).to.have.property(\"messages\");",
											"    pm.expect(json.data.messages, \"data.messages\").to.be.an(\"array\");",
											"    pm.expect(json.data).to.have.property(\"meta\");",
											"    pm.expect(json.data.meta, \"data.meta\").to.be.an(\"object\");",
											"});",
											"",
											"pm.test(\"messages length equals meta.total_count\", function () {",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"    const totalCount = json && json.data && json.data.meta ? json.data.meta.total_count : undefined;",
											"    pm.expect(totalCount, \"meta.total_count is missing\").to.not.be.undefined;",
											"    pm.expect(messages.length, \"messages length\").to.eql(totalCount);",
											"});",
											"",
											"pm.test(\"Each message has required fields with correct types\", function () {",
											"    const requiredFields = [",
											"        { key: \"message_id\", type: \"string\" },",
											"        { key: \"from_user_id\", type: \"string\" },",
											"        { key: \"to_user_id\", type: \"string\" },",
											"        { key: \"message_text\", type: \"string\" },",
											"        { key: \"timestamp\", type: \"string\" },",
											"        { key: \"is_read\", type: \"boolean\" }",
											"    ];",
											"",
											"    const messages = (json && json.data && Array.isArray(json.data.messages)) ? json.data.messages : [];",
											"",
											"    messages.forEach((msg, index) => {",
											"        requiredFields.forEach(field => {",
											"            pm.expect(msg, `message[${index}] missing ${field.key}`).to.have.property(field.key);",
											"            pm.expect(typeof msg[field.key], `message[${index}].${field.key} should be ${field.type}`).to.eql(field.type);",
											"            if (field.type === \"string\") {",
											"                pm.expect(msg[field.key], `message[${index}].${field.key} should not be empty`).to.have.length.greaterThan(0);",
											"            }",
											"        });",
											"    });",
											"});",
											"",
											"pm.test(\"meta.has_more is boolean\", function () {",
											"    const hasMore = json && json.data && json.data.meta ? json.data.meta.has_more : undefined;",
											"    pm.expect(hasMore, \"meta.has_more is missing\").to.not.be.undefined;",
											"    pm.expect(typeof hasMore, \"meta.has_more type\").to.eql(\"boolean\");",
											"});",
											""
										],
										"type": "text/javascript",
										"packages": {},
										"requests": {}
									}
								}
							],
							"request": {
								"method": "GET",
								"header": [
									{
										"key": "Authorization",
										"value": " Bearer {{aliceAccessToken}}",
										"type": "text"
									}
								],
								"url": {
									"raw": "{{baseURL}}/api/v1/messages?unread_only=false",
									"host": [
										"{{baseURL}}"
									],
									"path": [
										"api",
										"v1",
										"messages"
									],
									"query": [
										{
											"key": "unread_only",
											"value": "false"
										}
									]
								}
							},
							"response": []
						}
					]
				}
			]
		},
		{
			"name": "Cleanup",
			"item": [
				{
					"name": "Cleanup account alice",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test(\"Response Content-Type is JSON\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
									"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
									"});",
									"",
									"let json;",
									"pm.test(\"Response body is valid JSON\", function () {",
									"    json = pm.response.json();",
									"    pm.expect(json).to.be.an(\"object\");",
									"});",
									"",
									"pm.test(\"Body has expected message and status\", function () {",
									"    pm.expect(json).to.have.property(\"message\");",
									"    pm.expect(json.message).to.eql(\"Account deleted successfully\");",
									"    pm.expect(json).to.have.property(\"status\");",
									"    pm.expect(json.status).to.eql(\"success\");",
									"});",
									"",
									"pm.test(\"Request has Authorization header with Bearer token\", function () {",
									"    const authHeader = pm.request.headers.get(\"Authorization\");",
									"    pm.expect(authHeader, \"Authorization header should be present on request\").to.be.a(\"string\");",
									"});",
									"",
									"pm.test('Clear stored auth tokens', function () {",
									"  if (pm.response.code === 200) {",
									"    if (pm.environment.get('aliceAccessToken')) pm.environment.unset('aliceAccessToken');",
									"    if (pm.environment.get('aliceRefreshToken')) pm.environment.unset('aliceRefreshToken');",
									"",
									"    pm.collectionVariables.unset('aliceAccessToken');",
									"    pm.collectionVariables.unset('aliceRefreshToken');",
									"    pm.globals.unset('aliceAccessToken');",
									"    pm.globals.unset('aliceRefreshToken');",
									"",
									"    pm.expect(pm.environment.get('aliceAccessToken')).to.be.undefined;",
									"    pm.expect(pm.environment.get('aliceRefreshToken')).to.be.undefined;",
									"  } else {",
									"    pm.expect.fail('Skipping token clear because logout did not return 200');",
									"  }",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						},
						{
							"listen": "prerequest",
							"script": {
								"exec": [
									""
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Authorization",
								"value": " Bearer {{aliceAccessToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseURL}}/api/v1/auth/account",
							"host": [
								"{{baseURL}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"account"
							]
						}
					},
					"response": []
				},
				{
					"name": "Cleanup account bob",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test(\"Response Content-Type is JSON\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
									"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
									"});",
									"",
									"let json;",
									"pm.test(\"Response body is valid JSON\", function () {",
									"    json = pm.response.json();",
									"    pm.expect(json).to.be.an(\"object\");",
									"});",
									"",
									"pm.test(\"Body has expected message and status\", function () {",
									"    pm.expect(json).to.have.property(\"message\");",
									"    pm.expect(json.message).to.eql(\"Account deleted successfully\");",
									"    pm.expect(json).to.have.property(\"status\");",
									"    pm.expect(json.status).to.eql(\"success\");",
									"});",
									"",
									"pm.test(\"Request has Authorization header with Bearer token\", function () {",
									"    const authHeader = pm.request.headers.get(\"Authorization\");",
									"    pm.expect(authHeader, \"Authorization header should be present on request\").to.be.a(\"string\");",
									"});",
									"",
									"pm.test('Clear stored auth tokens', function () {",
									"  if (pm.response.code === 200) {",
									"    if (pm.environment.get('bobAccessToken')) pm.environment.unset('bobAccessToken');",
									"    if (pm.environment.get('bobRefreshToken')) pm.environment.unset('bobRefreshToken');",
									"",
									"    // also clear any global or collection vars commonly used",
									"    pm.collectionVariables.unset('bobAccessToken');",
									"    pm.collectionVariables.unset('bobRefreshToken');",
									"    pm.globals.unset('bobAccessToken');",
									"    pm.globals.unset('bobRefreshToken');",
									"",
									"    pm.expect(pm.environment.get('bobAccessToken')).to.be.undefined;",
									"    pm.expect(pm.environment.get('bobRefreshToken')).to.be.undefined;",
									"  } else {",
									"    pm.expect.fail('Skipping token clear because logout did not return 200');",
									"  }",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Authorization",
								"value": " Bearer {{bobAccessToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseURL}}/api/v1/auth/account",
							"host": [
								"{{baseURL}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"account"
							]
						}
					},
					"response": []
				},
				{
					"name": "Cleanup account charlie",
					"event": [
						{
							"listen": "test",
							"script": {
								"exec": [
									"pm.test(\"Status code is 200\", function () {",
									"    pm.response.to.have.status(200);",
									"});",
									"",
									"pm.test(\"Response Content-Type is JSON\", function () {",
									"    pm.response.to.have.header(\"Content-Type\");",
									"    const ct = pm.response.headers.get(\"Content-Type\") || \"\";",
									"    pm.expect(ct.toLowerCase()).to.include(\"application/json\");",
									"});",
									"",
									"let json;",
									"pm.test(\"Response body is valid JSON\", function () {",
									"    json = pm.response.json();",
									"    pm.expect(json).to.be.an(\"object\");",
									"});",
									"",
									"pm.test(\"Body has expected message and status\", function () {",
									"    pm.expect(json).to.have.property(\"message\");",
									"    pm.expect(json.message).to.eql(\"Account deleted successfully\");",
									"    pm.expect(json).to.have.property(\"status\");",
									"    pm.expect(json.status).to.eql(\"success\");",
									"});",
									"",
									"pm.test(\"Request has Authorization header with Bearer token\", function () {",
									"    const authHeader = pm.request.headers.get(\"Authorization\");",
									"    pm.expect(authHeader, \"Authorization header should be present on request\").to.be.a(\"string\");",
									"});",
									"",
									"pm.test('Clear stored auth tokens', function () {",
									"  if (pm.response.code === 200) {",
									"    if (pm.environment.get('charlieAccessToken')) pm.environment.unset('charlieAccessToken');",
									"    if (pm.environment.get('charlieRefreshToken')) pm.environment.unset('charlieRefreshToken');",
									"",
									"    pm.collectionVariables.unset('charlieAccessToken');",
									"    pm.collectionVariables.unset('charlieRefreshToken');",
									"    pm.globals.unset('charlieAccessToken');",
									"    pm.globals.unset('charlieRefreshToken');",
									"",
									"    pm.expect(pm.environment.get('charlieAccessToken')).to.be.undefined;",
									"    pm.expect(pm.environment.get('charlieRefreshToken')).to.be.undefined;",
									"  } else {",
									"    pm.expect.fail('Skipping token clear because logout did not return 200');",
									"  }",
									"});"
								],
								"type": "text/javascript",
								"packages": {},
								"requests": {}
							}
						}
					],
					"request": {
						"method": "DELETE",
						"header": [
							{
								"key": "Authorization",
								"value": " Bearer {{charlieAccessToken}}",
								"type": "text"
							}
						],
						"url": {
							"raw": "{{baseURL}}/api/v1/auth/account",
							"host": [
								"{{baseURL}}"
							],
							"path": [
								"api",
								"v1",
								"auth",
								"account"
							]
						}
					},
					"response": []
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"packages": {},
				"requests": {},
				"exec": [
					""
				]
			}
		}
	],
	"variable": [
		{
			"key": "baseURL",
			"value": ""
		}
	]
}